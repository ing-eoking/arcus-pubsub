/* automatically generated by rust-bindgen 0.64.0 */

pub const EVENT__HAVE_ARC4RANDOM: u32 = 1;
pub const EVENT__HAVE_ARC4RANDOM_ADDRANDOM: u32 = 1;
pub const EVENT__HAVE_ARC4RANDOM_BUF: u32 = 1;
pub const EVENT__HAVE_ARPA_INET_H: u32 = 1;
pub const EVENT__HAVE_CLOCK_GETTIME: u32 = 1;
pub const EVENT__HAVE_DECL_CTL_KERN: u32 = 1;
pub const EVENT__HAVE_DECL_KERN_ARND: u32 = 0;
pub const EVENT__HAVE_DLFCN_H: u32 = 1;
pub const EVENT__HAVE_ERRNO_H: u32 = 1;
pub const EVENT__HAVE_FCNTL: u32 = 1;
pub const EVENT__HAVE_FCNTL_H: u32 = 1;
pub const EVENT__HAVE_FD_MASK: u32 = 1;
pub const EVENT__HAVE_GETADDRINFO: u32 = 1;
pub const EVENT__HAVE_GETEGID: u32 = 1;
pub const EVENT__HAVE_GETEUID: u32 = 1;
pub const EVENT__HAVE_GETIFADDRS: u32 = 1;
pub const EVENT__HAVE_GETNAMEINFO: u32 = 1;
pub const EVENT__HAVE_GETPROTOBYNUMBER: u32 = 1;
pub const EVENT__HAVE_GETSERVBYNAME: u32 = 1;
pub const EVENT__HAVE_GETTIMEOFDAY: u32 = 1;
pub const EVENT__HAVE_IFADDRS_H: u32 = 1;
pub const EVENT__HAVE_INET_NTOP: u32 = 1;
pub const EVENT__HAVE_INET_PTON: u32 = 1;
pub const EVENT__HAVE_INTTYPES_H: u32 = 1;
pub const EVENT__HAVE_ISSETUGID: u32 = 1;
pub const EVENT__HAVE_KQUEUE: u32 = 1;
pub const EVENT__HAVE_LIBZ: u32 = 1;
pub const EVENT__HAVE_MACH_ABSOLUTE_TIME: u32 = 1;
pub const EVENT__HAVE_MACH_MACH_H: u32 = 1;
pub const EVENT__HAVE_MACH_MACH_TIME_H: u32 = 1;
pub const EVENT__HAVE_MEMORY_H: u32 = 1;
pub const EVENT__HAVE_MMAP: u32 = 1;
pub const EVENT__HAVE_NANOSLEEP: u32 = 1;
pub const EVENT__HAVE_NETDB_H: u32 = 1;
pub const EVENT__HAVE_NETINET_IN_H: u32 = 1;
pub const EVENT__HAVE_NETINET_TCP_H: u32 = 1;
pub const EVENT__HAVE_PIPE: u32 = 1;
pub const EVENT__HAVE_POLL: u32 = 1;
pub const EVENT__HAVE_POLL_H: u32 = 1;
pub const EVENT__HAVE_PTHREADS: u32 = 1;
pub const EVENT__HAVE_PUTENV: u32 = 1;
pub const EVENT__HAVE_SA_FAMILY_T: u32 = 1;
pub const EVENT__HAVE_SELECT: u32 = 1;
pub const EVENT__HAVE_SENDFILE: u32 = 1;
pub const EVENT__HAVE_SETENV: u32 = 1;
pub const EVENT__HAVE_SETFD: u32 = 1;
pub const EVENT__HAVE_SETRLIMIT: u32 = 1;
pub const EVENT__HAVE_SIGACTION: u32 = 1;
pub const EVENT__HAVE_SIGNAL: u32 = 1;
pub const EVENT__HAVE_STDARG_H: u32 = 1;
pub const EVENT__HAVE_STDDEF_H: u32 = 1;
pub const EVENT__HAVE_STDINT_H: u32 = 1;
pub const EVENT__HAVE_STDLIB_H: u32 = 1;
pub const EVENT__HAVE_STRINGS_H: u32 = 1;
pub const EVENT__HAVE_STRING_H: u32 = 1;
pub const EVENT__HAVE_STRLCPY: u32 = 1;
pub const EVENT__HAVE_STRSEP: u32 = 1;
pub const EVENT__HAVE_STRTOK_R: u32 = 1;
pub const EVENT__HAVE_STRTOLL: u32 = 1;
pub const EVENT__HAVE_STRUCT_ADDRINFO: u32 = 1;
pub const EVENT__HAVE_STRUCT_IN6_ADDR: u32 = 1;
pub const EVENT__HAVE_STRUCT_LINGER: u32 = 1;
pub const EVENT__HAVE_STRUCT_SOCKADDR_IN6: u32 = 1;
pub const EVENT__HAVE_STRUCT_SOCKADDR_IN6_SIN6_LEN: u32 = 1;
pub const EVENT__HAVE_STRUCT_SOCKADDR_IN_SIN_LEN: u32 = 1;
pub const EVENT__HAVE_STRUCT_SOCKADDR_STORAGE: u32 = 1;
pub const EVENT__HAVE_STRUCT_SOCKADDR_STORAGE_SS_FAMILY: u32 = 1;
pub const EVENT__HAVE_STRUCT_SOCKADDR_UN: u32 = 1;
pub const EVENT__HAVE_SYSCTL: u32 = 1;
pub const EVENT__HAVE_SYS_EVENT_H: u32 = 1;
pub const EVENT__HAVE_SYS_IOCTL_H: u32 = 1;
pub const EVENT__HAVE_SYS_MMAN_H: u32 = 1;
pub const EVENT__HAVE_SYS_PARAM_H: u32 = 1;
pub const EVENT__HAVE_SYS_QUEUE_H: u32 = 1;
pub const EVENT__HAVE_SYS_RANDOM_H: u32 = 1;
pub const EVENT__HAVE_SYS_RESOURCE_H: u32 = 1;
pub const EVENT__HAVE_SYS_SELECT_H: u32 = 1;
pub const EVENT__HAVE_SYS_SOCKET_H: u32 = 1;
pub const EVENT__HAVE_SYS_STAT_H: u32 = 1;
pub const EVENT__HAVE_SYS_SYSCTL_H: u32 = 1;
pub const EVENT__HAVE_SYS_TIME_H: u32 = 1;
pub const EVENT__HAVE_SYS_TYPES_H: u32 = 1;
pub const EVENT__HAVE_SYS_UIO_H: u32 = 1;
pub const EVENT__HAVE_SYS_UN_H: u32 = 1;
pub const EVENT__HAVE_SYS_WAIT_H: u32 = 1;
pub const EVENT__HAVE_TAILQFOREACH: u32 = 1;
pub const EVENT__HAVE_TIMERADD: u32 = 1;
pub const EVENT__HAVE_TIMERCLEAR: u32 = 1;
pub const EVENT__HAVE_TIMERCMP: u32 = 1;
pub const EVENT__HAVE_TIMERISSET: u32 = 1;
pub const EVENT__HAVE_UINT16_T: u32 = 1;
pub const EVENT__HAVE_UINT32_T: u32 = 1;
pub const EVENT__HAVE_UINT64_T: u32 = 1;
pub const EVENT__HAVE_UINT8_T: u32 = 1;
pub const EVENT__HAVE_UINTPTR_T: u32 = 1;
pub const EVENT__HAVE_UMASK: u32 = 1;
pub const EVENT__HAVE_UNISTD_H: u32 = 1;
pub const EVENT__HAVE_UNSETENV: u32 = 1;
pub const EVENT__HAVE_USLEEP: u32 = 1;
pub const EVENT__HAVE_VASPRINTF: u32 = 1;
pub const EVENT__HAVE_WORKING_KQUEUE: u32 = 1;
pub const EVENT__HAVE_ZLIB_H: u32 = 1;
pub const EVENT__HAVE___FUNCTION__: u32 = 1;
pub const EVENT__HAVE___func__: u32 = 1;
pub const EVENT__LT_OBJDIR: &[u8; 7usize] = b".libs/\0";
pub const EVENT__NUMERIC_VERSION: u32 = 33623040;
pub const EVENT__PACKAGE: &[u8; 9usize] = b"libevent\0";
pub const EVENT__PACKAGE_BUGREPORT: &[u8; 1usize] = b"\0";
pub const EVENT__PACKAGE_NAME: &[u8; 9usize] = b"libevent\0";
pub const EVENT__PACKAGE_STRING: &[u8; 23usize] = b"libevent 2.1.12-stable\0";
pub const EVENT__PACKAGE_TARNAME: &[u8; 9usize] = b"libevent\0";
pub const EVENT__PACKAGE_URL: &[u8; 1usize] = b"\0";
pub const EVENT__PACKAGE_VERSION: &[u8; 14usize] = b"2.1.12-stable\0";
pub const EVENT__SIZEOF_INT: u32 = 4;
pub const EVENT__SIZEOF_LONG: u32 = 8;
pub const EVENT__SIZEOF_LONG_LONG: u32 = 8;
pub const EVENT__SIZEOF_OFF_T: u32 = 8;
pub const EVENT__SIZEOF_PTHREAD_T: u32 = 8;
pub const EVENT__SIZEOF_SHORT: u32 = 2;
pub const EVENT__SIZEOF_SIZE_T: u32 = 8;
pub const EVENT__SIZEOF_TIME_T: u32 = 8;
pub const EVENT__SIZEOF_VOID_P: u32 = 8;
pub const EVENT__STDC_HEADERS: u32 = 1;
pub const EVENT__TIME_WITH_SYS_TIME: u32 = 1;
pub const _ALL_SOURCE: u32 = 1;
pub const _GNU_SOURCE: u32 = 1;
pub const _POSIX_PTHREAD_SEMANTICS: u32 = 1;
pub const _TANDEM_SOURCE: u32 = 1;
pub const __EXTENSIONS__: u32 = 1;
pub const EVENT__VERSION: &[u8; 14usize] = b"2.1.12-stable\0";
pub const _DARWIN_USE_64_BIT_INODE: u32 = 1;
pub const __DARWIN_ONLY_64_BIT_INO_T: u32 = 0;
pub const __DARWIN_ONLY_UNIX_CONFORMANCE: u32 = 1;
pub const __DARWIN_ONLY_VERS_1050: u32 = 0;
pub const __DARWIN_UNIX03: u32 = 1;
pub const __DARWIN_64_BIT_INO_T: u32 = 1;
pub const __DARWIN_VERS_1050: u32 = 1;
pub const __DARWIN_NON_CANCELABLE: u32 = 0;
pub const __DARWIN_SUF_64_BIT_INO_T: &[u8; 9usize] = b"$INODE64\0";
pub const __DARWIN_SUF_1050: &[u8; 6usize] = b"$1050\0";
pub const __DARWIN_SUF_EXTSN: &[u8; 14usize] = b"$DARWIN_EXTSN\0";
pub const __DARWIN_C_ANSI: u32 = 4096;
pub const __DARWIN_C_FULL: u32 = 900000;
pub const __DARWIN_C_LEVEL: u32 = 900000;
pub const __STDC_WANT_LIB_EXT1__: u32 = 1;
pub const __DARWIN_NO_LONG_LONG: u32 = 0;
pub const _DARWIN_FEATURE_64_BIT_INODE: u32 = 1;
pub const _DARWIN_FEATURE_ONLY_UNIX_CONFORMANCE: u32 = 1;
pub const _DARWIN_FEATURE_UNIX_CONFORMANCE: u32 = 3;
pub const __has_ptrcheck: u32 = 0;
pub const __PTHREAD_SIZE__: u32 = 8176;
pub const __PTHREAD_ATTR_SIZE__: u32 = 56;
pub const __PTHREAD_MUTEXATTR_SIZE__: u32 = 8;
pub const __PTHREAD_MUTEX_SIZE__: u32 = 56;
pub const __PTHREAD_CONDATTR_SIZE__: u32 = 8;
pub const __PTHREAD_COND_SIZE__: u32 = 40;
pub const __PTHREAD_ONCE_SIZE__: u32 = 8;
pub const __PTHREAD_RWLOCK_SIZE__: u32 = 192;
pub const __PTHREAD_RWLOCKATTR_SIZE__: u32 = 16;
pub const _QUAD_HIGHWORD: u32 = 1;
pub const _QUAD_LOWWORD: u32 = 0;
pub const __DARWIN_LITTLE_ENDIAN: u32 = 1234;
pub const __DARWIN_BIG_ENDIAN: u32 = 4321;
pub const __DARWIN_PDP_ENDIAN: u32 = 3412;
pub const __DARWIN_BYTE_ORDER: u32 = 1234;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const BYTE_ORDER: u32 = 1234;
pub const __API_TO_BE_DEPRECATED: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_MACOS: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_IOS: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_TVOS: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_WATCHOS: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_MACCATALYST: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_DRIVERKIT: u32 = 100000;
pub const __MAC_10_0: u32 = 1000;
pub const __MAC_10_1: u32 = 1010;
pub const __MAC_10_2: u32 = 1020;
pub const __MAC_10_3: u32 = 1030;
pub const __MAC_10_4: u32 = 1040;
pub const __MAC_10_5: u32 = 1050;
pub const __MAC_10_6: u32 = 1060;
pub const __MAC_10_7: u32 = 1070;
pub const __MAC_10_8: u32 = 1080;
pub const __MAC_10_9: u32 = 1090;
pub const __MAC_10_10: u32 = 101000;
pub const __MAC_10_10_2: u32 = 101002;
pub const __MAC_10_10_3: u32 = 101003;
pub const __MAC_10_11: u32 = 101100;
pub const __MAC_10_11_2: u32 = 101102;
pub const __MAC_10_11_3: u32 = 101103;
pub const __MAC_10_11_4: u32 = 101104;
pub const __MAC_10_12: u32 = 101200;
pub const __MAC_10_12_1: u32 = 101201;
pub const __MAC_10_12_2: u32 = 101202;
pub const __MAC_10_12_4: u32 = 101204;
pub const __MAC_10_13: u32 = 101300;
pub const __MAC_10_13_1: u32 = 101301;
pub const __MAC_10_13_2: u32 = 101302;
pub const __MAC_10_13_4: u32 = 101304;
pub const __MAC_10_14: u32 = 101400;
pub const __MAC_10_14_1: u32 = 101401;
pub const __MAC_10_14_4: u32 = 101404;
pub const __MAC_10_14_6: u32 = 101406;
pub const __MAC_10_15: u32 = 101500;
pub const __MAC_10_15_1: u32 = 101501;
pub const __MAC_10_15_4: u32 = 101504;
pub const __MAC_10_16: u32 = 101600;
pub const __MAC_11_0: u32 = 110000;
pub const __MAC_11_1: u32 = 110100;
pub const __MAC_11_3: u32 = 110300;
pub const __MAC_11_4: u32 = 110400;
pub const __MAC_11_5: u32 = 110500;
pub const __MAC_11_6: u32 = 110600;
pub const __MAC_12_0: u32 = 120000;
pub const __MAC_12_1: u32 = 120100;
pub const __MAC_12_2: u32 = 120200;
pub const __MAC_12_3: u32 = 120300;
pub const __MAC_13_0: u32 = 130000;
pub const __MAC_13_1: u32 = 130100;
pub const __MAC_13_2: u32 = 130200;
pub const __MAC_13_3: u32 = 130300;
pub const __IPHONE_2_0: u32 = 20000;
pub const __IPHONE_2_1: u32 = 20100;
pub const __IPHONE_2_2: u32 = 20200;
pub const __IPHONE_3_0: u32 = 30000;
pub const __IPHONE_3_1: u32 = 30100;
pub const __IPHONE_3_2: u32 = 30200;
pub const __IPHONE_4_0: u32 = 40000;
pub const __IPHONE_4_1: u32 = 40100;
pub const __IPHONE_4_2: u32 = 40200;
pub const __IPHONE_4_3: u32 = 40300;
pub const __IPHONE_5_0: u32 = 50000;
pub const __IPHONE_5_1: u32 = 50100;
pub const __IPHONE_6_0: u32 = 60000;
pub const __IPHONE_6_1: u32 = 60100;
pub const __IPHONE_7_0: u32 = 70000;
pub const __IPHONE_7_1: u32 = 70100;
pub const __IPHONE_8_0: u32 = 80000;
pub const __IPHONE_8_1: u32 = 80100;
pub const __IPHONE_8_2: u32 = 80200;
pub const __IPHONE_8_3: u32 = 80300;
pub const __IPHONE_8_4: u32 = 80400;
pub const __IPHONE_9_0: u32 = 90000;
pub const __IPHONE_9_1: u32 = 90100;
pub const __IPHONE_9_2: u32 = 90200;
pub const __IPHONE_9_3: u32 = 90300;
pub const __IPHONE_10_0: u32 = 100000;
pub const __IPHONE_10_1: u32 = 100100;
pub const __IPHONE_10_2: u32 = 100200;
pub const __IPHONE_10_3: u32 = 100300;
pub const __IPHONE_11_0: u32 = 110000;
pub const __IPHONE_11_1: u32 = 110100;
pub const __IPHONE_11_2: u32 = 110200;
pub const __IPHONE_11_3: u32 = 110300;
pub const __IPHONE_11_4: u32 = 110400;
pub const __IPHONE_12_0: u32 = 120000;
pub const __IPHONE_12_1: u32 = 120100;
pub const __IPHONE_12_2: u32 = 120200;
pub const __IPHONE_12_3: u32 = 120300;
pub const __IPHONE_12_4: u32 = 120400;
pub const __IPHONE_13_0: u32 = 130000;
pub const __IPHONE_13_1: u32 = 130100;
pub const __IPHONE_13_2: u32 = 130200;
pub const __IPHONE_13_3: u32 = 130300;
pub const __IPHONE_13_4: u32 = 130400;
pub const __IPHONE_13_5: u32 = 130500;
pub const __IPHONE_13_6: u32 = 130600;
pub const __IPHONE_13_7: u32 = 130700;
pub const __IPHONE_14_0: u32 = 140000;
pub const __IPHONE_14_1: u32 = 140100;
pub const __IPHONE_14_2: u32 = 140200;
pub const __IPHONE_14_3: u32 = 140300;
pub const __IPHONE_14_5: u32 = 140500;
pub const __IPHONE_14_6: u32 = 140600;
pub const __IPHONE_14_7: u32 = 140700;
pub const __IPHONE_14_8: u32 = 140800;
pub const __IPHONE_15_0: u32 = 150000;
pub const __IPHONE_15_1: u32 = 150100;
pub const __IPHONE_15_2: u32 = 150200;
pub const __IPHONE_15_3: u32 = 150300;
pub const __IPHONE_15_4: u32 = 150400;
pub const __IPHONE_16_0: u32 = 160000;
pub const __IPHONE_16_1: u32 = 160100;
pub const __IPHONE_16_2: u32 = 160200;
pub const __IPHONE_16_3: u32 = 160300;
pub const __IPHONE_16_4: u32 = 160400;
pub const __TVOS_9_0: u32 = 90000;
pub const __TVOS_9_1: u32 = 90100;
pub const __TVOS_9_2: u32 = 90200;
pub const __TVOS_10_0: u32 = 100000;
pub const __TVOS_10_0_1: u32 = 100001;
pub const __TVOS_10_1: u32 = 100100;
pub const __TVOS_10_2: u32 = 100200;
pub const __TVOS_11_0: u32 = 110000;
pub const __TVOS_11_1: u32 = 110100;
pub const __TVOS_11_2: u32 = 110200;
pub const __TVOS_11_3: u32 = 110300;
pub const __TVOS_11_4: u32 = 110400;
pub const __TVOS_12_0: u32 = 120000;
pub const __TVOS_12_1: u32 = 120100;
pub const __TVOS_12_2: u32 = 120200;
pub const __TVOS_12_3: u32 = 120300;
pub const __TVOS_12_4: u32 = 120400;
pub const __TVOS_13_0: u32 = 130000;
pub const __TVOS_13_2: u32 = 130200;
pub const __TVOS_13_3: u32 = 130300;
pub const __TVOS_13_4: u32 = 130400;
pub const __TVOS_14_0: u32 = 140000;
pub const __TVOS_14_1: u32 = 140100;
pub const __TVOS_14_2: u32 = 140200;
pub const __TVOS_14_3: u32 = 140300;
pub const __TVOS_14_5: u32 = 140500;
pub const __TVOS_14_6: u32 = 140600;
pub const __TVOS_14_7: u32 = 140700;
pub const __TVOS_15_0: u32 = 150000;
pub const __TVOS_15_1: u32 = 150100;
pub const __TVOS_15_2: u32 = 150200;
pub const __TVOS_15_3: u32 = 150300;
pub const __TVOS_15_4: u32 = 150400;
pub const __TVOS_16_0: u32 = 160000;
pub const __TVOS_16_1: u32 = 160100;
pub const __TVOS_16_2: u32 = 160200;
pub const __TVOS_16_3: u32 = 160300;
pub const __TVOS_16_4: u32 = 160400;
pub const __WATCHOS_1_0: u32 = 10000;
pub const __WATCHOS_2_0: u32 = 20000;
pub const __WATCHOS_2_1: u32 = 20100;
pub const __WATCHOS_2_2: u32 = 20200;
pub const __WATCHOS_3_0: u32 = 30000;
pub const __WATCHOS_3_1: u32 = 30100;
pub const __WATCHOS_3_1_1: u32 = 30101;
pub const __WATCHOS_3_2: u32 = 30200;
pub const __WATCHOS_4_0: u32 = 40000;
pub const __WATCHOS_4_1: u32 = 40100;
pub const __WATCHOS_4_2: u32 = 40200;
pub const __WATCHOS_4_3: u32 = 40300;
pub const __WATCHOS_5_0: u32 = 50000;
pub const __WATCHOS_5_1: u32 = 50100;
pub const __WATCHOS_5_2: u32 = 50200;
pub const __WATCHOS_5_3: u32 = 50300;
pub const __WATCHOS_6_0: u32 = 60000;
pub const __WATCHOS_6_1: u32 = 60100;
pub const __WATCHOS_6_2: u32 = 60200;
pub const __WATCHOS_7_0: u32 = 70000;
pub const __WATCHOS_7_1: u32 = 70100;
pub const __WATCHOS_7_2: u32 = 70200;
pub const __WATCHOS_7_3: u32 = 70300;
pub const __WATCHOS_7_4: u32 = 70400;
pub const __WATCHOS_7_5: u32 = 70500;
pub const __WATCHOS_7_6: u32 = 70600;
pub const __WATCHOS_8_0: u32 = 80000;
pub const __WATCHOS_8_1: u32 = 80100;
pub const __WATCHOS_8_3: u32 = 80300;
pub const __WATCHOS_8_4: u32 = 80400;
pub const __WATCHOS_8_5: u32 = 80500;
pub const __WATCHOS_9_0: u32 = 90000;
pub const __WATCHOS_9_1: u32 = 90100;
pub const __WATCHOS_9_2: u32 = 90200;
pub const __WATCHOS_9_3: u32 = 90300;
pub const __WATCHOS_9_4: u32 = 90400;
pub const MAC_OS_X_VERSION_10_0: u32 = 1000;
pub const MAC_OS_X_VERSION_10_1: u32 = 1010;
pub const MAC_OS_X_VERSION_10_2: u32 = 1020;
pub const MAC_OS_X_VERSION_10_3: u32 = 1030;
pub const MAC_OS_X_VERSION_10_4: u32 = 1040;
pub const MAC_OS_X_VERSION_10_5: u32 = 1050;
pub const MAC_OS_X_VERSION_10_6: u32 = 1060;
pub const MAC_OS_X_VERSION_10_7: u32 = 1070;
pub const MAC_OS_X_VERSION_10_8: u32 = 1080;
pub const MAC_OS_X_VERSION_10_9: u32 = 1090;
pub const MAC_OS_X_VERSION_10_10: u32 = 101000;
pub const MAC_OS_X_VERSION_10_10_2: u32 = 101002;
pub const MAC_OS_X_VERSION_10_10_3: u32 = 101003;
pub const MAC_OS_X_VERSION_10_11: u32 = 101100;
pub const MAC_OS_X_VERSION_10_11_2: u32 = 101102;
pub const MAC_OS_X_VERSION_10_11_3: u32 = 101103;
pub const MAC_OS_X_VERSION_10_11_4: u32 = 101104;
pub const MAC_OS_X_VERSION_10_12: u32 = 101200;
pub const MAC_OS_X_VERSION_10_12_1: u32 = 101201;
pub const MAC_OS_X_VERSION_10_12_2: u32 = 101202;
pub const MAC_OS_X_VERSION_10_12_4: u32 = 101204;
pub const MAC_OS_X_VERSION_10_13: u32 = 101300;
pub const MAC_OS_X_VERSION_10_13_1: u32 = 101301;
pub const MAC_OS_X_VERSION_10_13_2: u32 = 101302;
pub const MAC_OS_X_VERSION_10_13_4: u32 = 101304;
pub const MAC_OS_X_VERSION_10_14: u32 = 101400;
pub const MAC_OS_X_VERSION_10_14_1: u32 = 101401;
pub const MAC_OS_X_VERSION_10_14_4: u32 = 101404;
pub const MAC_OS_X_VERSION_10_14_6: u32 = 101406;
pub const MAC_OS_X_VERSION_10_15: u32 = 101500;
pub const MAC_OS_X_VERSION_10_15_1: u32 = 101501;
pub const MAC_OS_X_VERSION_10_16: u32 = 101600;
pub const MAC_OS_VERSION_11_0: u32 = 110000;
pub const MAC_OS_VERSION_12_0: u32 = 120000;
pub const MAC_OS_VERSION_13_0: u32 = 130000;
pub const __DRIVERKIT_19_0: u32 = 190000;
pub const __DRIVERKIT_20_0: u32 = 200000;
pub const __DRIVERKIT_21_0: u32 = 210000;
pub const __MAC_OS_X_VERSION_MAX_ALLOWED: u32 = 130300;
pub const __ENABLE_LEGACY_MAC_AVAILABILITY: u32 = 1;
pub const __DARWIN_FD_SETSIZE: u32 = 1024;
pub const __DARWIN_NBBY: u32 = 8;
pub const NBBY: u32 = 8;
pub const FD_SETSIZE: u32 = 1024;
pub const ITIMER_REAL: u32 = 0;
pub const ITIMER_VIRTUAL: u32 = 1;
pub const ITIMER_PROF: u32 = 2;
pub const DST_NONE: u32 = 0;
pub const DST_USA: u32 = 1;
pub const DST_AUST: u32 = 2;
pub const DST_WET: u32 = 3;
pub const DST_MET: u32 = 4;
pub const DST_EET: u32 = 5;
pub const DST_CAN: u32 = 6;
pub const __DARWIN_WCHAR_MIN: i32 = -2147483648;
pub const _FORTIFY_SOURCE: u32 = 2;
pub const TIME_UTC: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const INT64_MAX: u64 = 9223372036854775807;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT64_MIN: i64 = -9223372036854775808;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const UINT64_MAX: i32 = -1;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST64_MIN: i64 = -9223372036854775808;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const INT_LEAST64_MAX: u64 = 9223372036854775807;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const UINT_LEAST64_MAX: i32 = -1;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i32 = -32768;
pub const INT_FAST32_MIN: i32 = -2147483648;
pub const INT_FAST64_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u32 = 32767;
pub const INT_FAST32_MAX: u32 = 2147483647;
pub const INT_FAST64_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: u32 = 65535;
pub const UINT_FAST32_MAX: u32 = 4294967295;
pub const UINT_FAST64_MAX: i32 = -1;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const UINTPTR_MAX: i32 = -1;
pub const SIZE_MAX: i32 = -1;
pub const RSIZE_MAX: i32 = -1;
pub const WINT_MIN: i32 = -2147483648;
pub const WINT_MAX: u32 = 2147483647;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const KEV_INET_SUBCLASS: u32 = 1;
pub const KEV_INET_NEW_ADDR: u32 = 1;
pub const KEV_INET_CHANGED_ADDR: u32 = 2;
pub const KEV_INET_ADDR_DELETED: u32 = 3;
pub const KEV_INET_SIFDSTADDR: u32 = 4;
pub const KEV_INET_SIFBRDADDR: u32 = 5;
pub const KEV_INET_SIFNETMASK: u32 = 6;
pub const KEV_INET_ARPCOLLISION: u32 = 7;
pub const KEV_INET_PORTINUSE: u32 = 8;
pub const KEV_INET_ARPRTRFAILURE: u32 = 9;
pub const KEV_INET_ARPRTRALIVE: u32 = 10;
pub const KEV_DL_SUBCLASS: u32 = 2;
pub const KEV_DL_SIFFLAGS: u32 = 1;
pub const KEV_DL_SIFMETRICS: u32 = 2;
pub const KEV_DL_SIFMTU: u32 = 3;
pub const KEV_DL_SIFPHYS: u32 = 4;
pub const KEV_DL_SIFMEDIA: u32 = 5;
pub const KEV_DL_SIFGENERIC: u32 = 6;
pub const KEV_DL_ADDMULTI: u32 = 7;
pub const KEV_DL_DELMULTI: u32 = 8;
pub const KEV_DL_IF_ATTACHED: u32 = 9;
pub const KEV_DL_IF_DETACHING: u32 = 10;
pub const KEV_DL_IF_DETACHED: u32 = 11;
pub const KEV_DL_LINK_OFF: u32 = 12;
pub const KEV_DL_LINK_ON: u32 = 13;
pub const KEV_DL_PROTO_ATTACHED: u32 = 14;
pub const KEV_DL_PROTO_DETACHED: u32 = 15;
pub const KEV_DL_LINK_ADDRESS_CHANGED: u32 = 16;
pub const KEV_DL_WAKEFLAGS_CHANGED: u32 = 17;
pub const KEV_DL_IF_IDLE_ROUTE_REFCNT: u32 = 18;
pub const KEV_DL_IFCAP_CHANGED: u32 = 19;
pub const KEV_DL_LINK_QUALITY_METRIC_CHANGED: u32 = 20;
pub const KEV_DL_NODE_PRESENCE: u32 = 21;
pub const KEV_DL_NODE_ABSENCE: u32 = 22;
pub const KEV_DL_PRIMARY_ELECTED: u32 = 23;
pub const KEV_DL_ISSUES: u32 = 24;
pub const KEV_DL_IFDELEGATE_CHANGED: u32 = 25;
pub const KEV_DL_AWDL_RESTRICTED: u32 = 26;
pub const KEV_DL_AWDL_UNRESTRICTED: u32 = 27;
pub const KEV_DL_RRC_STATE_CHANGED: u32 = 28;
pub const KEV_DL_QOS_MODE_CHANGED: u32 = 29;
pub const KEV_DL_LOW_POWER_MODE_CHANGED: u32 = 30;
pub const KEV_INET6_SUBCLASS: u32 = 6;
pub const KEV_INET6_NEW_USER_ADDR: u32 = 1;
pub const KEV_INET6_CHANGED_ADDR: u32 = 2;
pub const KEV_INET6_ADDR_DELETED: u32 = 3;
pub const KEV_INET6_NEW_LL_ADDR: u32 = 4;
pub const KEV_INET6_NEW_RTADV_ADDR: u32 = 5;
pub const KEV_INET6_DEFROUTER: u32 = 6;
pub const KEV_INET6_REQUEST_NAT64_PREFIX: u32 = 7;
pub const SOCK_STREAM: u32 = 1;
pub const SOCK_DGRAM: u32 = 2;
pub const SOCK_RAW: u32 = 3;
pub const SOCK_RDM: u32 = 4;
pub const SOCK_SEQPACKET: u32 = 5;
pub const SO_DEBUG: u32 = 1;
pub const SO_ACCEPTCONN: u32 = 2;
pub const SO_REUSEADDR: u32 = 4;
pub const SO_KEEPALIVE: u32 = 8;
pub const SO_DONTROUTE: u32 = 16;
pub const SO_BROADCAST: u32 = 32;
pub const SO_USELOOPBACK: u32 = 64;
pub const SO_LINGER: u32 = 128;
pub const SO_LINGER_SEC: u32 = 4224;
pub const SO_OOBINLINE: u32 = 256;
pub const SO_REUSEPORT: u32 = 512;
pub const SO_TIMESTAMP: u32 = 1024;
pub const SO_TIMESTAMP_MONOTONIC: u32 = 2048;
pub const SO_DONTTRUNC: u32 = 8192;
pub const SO_WANTMORE: u32 = 16384;
pub const SO_WANTOOBFLAG: u32 = 32768;
pub const SO_SNDBUF: u32 = 4097;
pub const SO_RCVBUF: u32 = 4098;
pub const SO_SNDLOWAT: u32 = 4099;
pub const SO_RCVLOWAT: u32 = 4100;
pub const SO_SNDTIMEO: u32 = 4101;
pub const SO_RCVTIMEO: u32 = 4102;
pub const SO_ERROR: u32 = 4103;
pub const SO_TYPE: u32 = 4104;
pub const SO_LABEL: u32 = 4112;
pub const SO_PEERLABEL: u32 = 4113;
pub const SO_NREAD: u32 = 4128;
pub const SO_NKE: u32 = 4129;
pub const SO_NOSIGPIPE: u32 = 4130;
pub const SO_NOADDRERR: u32 = 4131;
pub const SO_NWRITE: u32 = 4132;
pub const SO_REUSESHAREUID: u32 = 4133;
pub const SO_NOTIFYCONFLICT: u32 = 4134;
pub const SO_UPCALLCLOSEWAIT: u32 = 4135;
pub const SO_RANDOMPORT: u32 = 4226;
pub const SO_NP_EXTENSIONS: u32 = 4227;
pub const SO_NUMRCVPKT: u32 = 4370;
pub const SO_NET_SERVICE_TYPE: u32 = 4374;
pub const SO_NETSVC_MARKING_LEVEL: u32 = 4377;
pub const SO_RESOLVER_SIGNATURE: u32 = 4401;
pub const NET_SERVICE_TYPE_BE: u32 = 0;
pub const NET_SERVICE_TYPE_BK: u32 = 1;
pub const NET_SERVICE_TYPE_SIG: u32 = 2;
pub const NET_SERVICE_TYPE_VI: u32 = 3;
pub const NET_SERVICE_TYPE_VO: u32 = 4;
pub const NET_SERVICE_TYPE_RV: u32 = 5;
pub const NET_SERVICE_TYPE_AV: u32 = 6;
pub const NET_SERVICE_TYPE_OAM: u32 = 7;
pub const NET_SERVICE_TYPE_RD: u32 = 8;
pub const NETSVC_MRKNG_UNKNOWN: u32 = 0;
pub const NETSVC_MRKNG_LVL_L2: u32 = 1;
pub const NETSVC_MRKNG_LVL_L3L2_ALL: u32 = 2;
pub const NETSVC_MRKNG_LVL_L3L2_BK: u32 = 3;
pub const SAE_ASSOCID_ANY: u32 = 0;
pub const SAE_CONNID_ANY: u32 = 0;
pub const CONNECT_RESUME_ON_READ_WRITE: u32 = 1;
pub const CONNECT_DATA_IDEMPOTENT: u32 = 2;
pub const CONNECT_DATA_AUTHENTICATED: u32 = 4;
pub const SONPX_SETOPTSHUT: u32 = 1;
pub const SOL_SOCKET: u32 = 65535;
pub const AF_UNSPEC: u32 = 0;
pub const AF_UNIX: u32 = 1;
pub const AF_LOCAL: u32 = 1;
pub const AF_INET: u32 = 2;
pub const AF_IMPLINK: u32 = 3;
pub const AF_PUP: u32 = 4;
pub const AF_CHAOS: u32 = 5;
pub const AF_NS: u32 = 6;
pub const AF_ISO: u32 = 7;
pub const AF_OSI: u32 = 7;
pub const AF_ECMA: u32 = 8;
pub const AF_DATAKIT: u32 = 9;
pub const AF_CCITT: u32 = 10;
pub const AF_SNA: u32 = 11;
pub const AF_DECnet: u32 = 12;
pub const AF_DLI: u32 = 13;
pub const AF_LAT: u32 = 14;
pub const AF_HYLINK: u32 = 15;
pub const AF_APPLETALK: u32 = 16;
pub const AF_ROUTE: u32 = 17;
pub const AF_LINK: u32 = 18;
pub const pseudo_AF_XTP: u32 = 19;
pub const AF_COIP: u32 = 20;
pub const AF_CNT: u32 = 21;
pub const pseudo_AF_RTIP: u32 = 22;
pub const AF_IPX: u32 = 23;
pub const AF_SIP: u32 = 24;
pub const pseudo_AF_PIP: u32 = 25;
pub const AF_NDRV: u32 = 27;
pub const AF_ISDN: u32 = 28;
pub const AF_E164: u32 = 28;
pub const pseudo_AF_KEY: u32 = 29;
pub const AF_INET6: u32 = 30;
pub const AF_NATM: u32 = 31;
pub const AF_SYSTEM: u32 = 32;
pub const AF_NETBIOS: u32 = 33;
pub const AF_PPP: u32 = 34;
pub const pseudo_AF_HDRCMPLT: u32 = 35;
pub const AF_RESERVED_36: u32 = 36;
pub const AF_IEEE80211: u32 = 37;
pub const AF_UTUN: u32 = 38;
pub const AF_VSOCK: u32 = 40;
pub const AF_MAX: u32 = 41;
pub const SOCK_MAXADDRLEN: u32 = 255;
pub const _SS_MAXSIZE: u32 = 128;
pub const PF_UNSPEC: u32 = 0;
pub const PF_LOCAL: u32 = 1;
pub const PF_UNIX: u32 = 1;
pub const PF_INET: u32 = 2;
pub const PF_IMPLINK: u32 = 3;
pub const PF_PUP: u32 = 4;
pub const PF_CHAOS: u32 = 5;
pub const PF_NS: u32 = 6;
pub const PF_ISO: u32 = 7;
pub const PF_OSI: u32 = 7;
pub const PF_ECMA: u32 = 8;
pub const PF_DATAKIT: u32 = 9;
pub const PF_CCITT: u32 = 10;
pub const PF_SNA: u32 = 11;
pub const PF_DECnet: u32 = 12;
pub const PF_DLI: u32 = 13;
pub const PF_LAT: u32 = 14;
pub const PF_HYLINK: u32 = 15;
pub const PF_APPLETALK: u32 = 16;
pub const PF_ROUTE: u32 = 17;
pub const PF_LINK: u32 = 18;
pub const PF_XTP: u32 = 19;
pub const PF_COIP: u32 = 20;
pub const PF_CNT: u32 = 21;
pub const PF_SIP: u32 = 24;
pub const PF_IPX: u32 = 23;
pub const PF_RTIP: u32 = 22;
pub const PF_PIP: u32 = 25;
pub const PF_NDRV: u32 = 27;
pub const PF_ISDN: u32 = 28;
pub const PF_KEY: u32 = 29;
pub const PF_INET6: u32 = 30;
pub const PF_NATM: u32 = 31;
pub const PF_SYSTEM: u32 = 32;
pub const PF_NETBIOS: u32 = 33;
pub const PF_PPP: u32 = 34;
pub const PF_RESERVED_36: u32 = 36;
pub const PF_UTUN: u32 = 38;
pub const PF_VSOCK: u32 = 40;
pub const PF_MAX: u32 = 41;
pub const NET_MAXID: u32 = 41;
pub const NET_RT_DUMP: u32 = 1;
pub const NET_RT_FLAGS: u32 = 2;
pub const NET_RT_IFLIST: u32 = 3;
pub const NET_RT_STAT: u32 = 4;
pub const NET_RT_TRASH: u32 = 5;
pub const NET_RT_IFLIST2: u32 = 6;
pub const NET_RT_DUMP2: u32 = 7;
pub const NET_RT_FLAGS_PRIV: u32 = 10;
pub const NET_RT_MAXID: u32 = 11;
pub const SOMAXCONN: u32 = 128;
pub const MSG_OOB: u32 = 1;
pub const MSG_PEEK: u32 = 2;
pub const MSG_DONTROUTE: u32 = 4;
pub const MSG_EOR: u32 = 8;
pub const MSG_TRUNC: u32 = 16;
pub const MSG_CTRUNC: u32 = 32;
pub const MSG_WAITALL: u32 = 64;
pub const MSG_DONTWAIT: u32 = 128;
pub const MSG_EOF: u32 = 256;
pub const MSG_WAITSTREAM: u32 = 512;
pub const MSG_FLUSH: u32 = 1024;
pub const MSG_HOLD: u32 = 2048;
pub const MSG_SEND: u32 = 4096;
pub const MSG_HAVEMORE: u32 = 8192;
pub const MSG_RCVMORE: u32 = 16384;
pub const MSG_NEEDSA: u32 = 65536;
pub const MSG_NOSIGNAL: u32 = 524288;
pub const SCM_RIGHTS: u32 = 1;
pub const SCM_TIMESTAMP: u32 = 2;
pub const SCM_CREDS: u32 = 3;
pub const SCM_TIMESTAMP_MONOTONIC: u32 = 4;
pub const SHUT_RD: u32 = 0;
pub const SHUT_WR: u32 = 1;
pub const SHUT_RDWR: u32 = 2;
pub const IPPROTO_IP: u32 = 0;
pub const IPPROTO_HOPOPTS: u32 = 0;
pub const IPPROTO_ICMP: u32 = 1;
pub const IPPROTO_IGMP: u32 = 2;
pub const IPPROTO_GGP: u32 = 3;
pub const IPPROTO_IPV4: u32 = 4;
pub const IPPROTO_IPIP: u32 = 4;
pub const IPPROTO_TCP: u32 = 6;
pub const IPPROTO_ST: u32 = 7;
pub const IPPROTO_EGP: u32 = 8;
pub const IPPROTO_PIGP: u32 = 9;
pub const IPPROTO_RCCMON: u32 = 10;
pub const IPPROTO_NVPII: u32 = 11;
pub const IPPROTO_PUP: u32 = 12;
pub const IPPROTO_ARGUS: u32 = 13;
pub const IPPROTO_EMCON: u32 = 14;
pub const IPPROTO_XNET: u32 = 15;
pub const IPPROTO_CHAOS: u32 = 16;
pub const IPPROTO_UDP: u32 = 17;
pub const IPPROTO_MUX: u32 = 18;
pub const IPPROTO_MEAS: u32 = 19;
pub const IPPROTO_HMP: u32 = 20;
pub const IPPROTO_PRM: u32 = 21;
pub const IPPROTO_IDP: u32 = 22;
pub const IPPROTO_TRUNK1: u32 = 23;
pub const IPPROTO_TRUNK2: u32 = 24;
pub const IPPROTO_LEAF1: u32 = 25;
pub const IPPROTO_LEAF2: u32 = 26;
pub const IPPROTO_RDP: u32 = 27;
pub const IPPROTO_IRTP: u32 = 28;
pub const IPPROTO_TP: u32 = 29;
pub const IPPROTO_BLT: u32 = 30;
pub const IPPROTO_NSP: u32 = 31;
pub const IPPROTO_INP: u32 = 32;
pub const IPPROTO_SEP: u32 = 33;
pub const IPPROTO_3PC: u32 = 34;
pub const IPPROTO_IDPR: u32 = 35;
pub const IPPROTO_XTP: u32 = 36;
pub const IPPROTO_DDP: u32 = 37;
pub const IPPROTO_CMTP: u32 = 38;
pub const IPPROTO_TPXX: u32 = 39;
pub const IPPROTO_IL: u32 = 40;
pub const IPPROTO_IPV6: u32 = 41;
pub const IPPROTO_SDRP: u32 = 42;
pub const IPPROTO_ROUTING: u32 = 43;
pub const IPPROTO_FRAGMENT: u32 = 44;
pub const IPPROTO_IDRP: u32 = 45;
pub const IPPROTO_RSVP: u32 = 46;
pub const IPPROTO_GRE: u32 = 47;
pub const IPPROTO_MHRP: u32 = 48;
pub const IPPROTO_BHA: u32 = 49;
pub const IPPROTO_ESP: u32 = 50;
pub const IPPROTO_AH: u32 = 51;
pub const IPPROTO_INLSP: u32 = 52;
pub const IPPROTO_SWIPE: u32 = 53;
pub const IPPROTO_NHRP: u32 = 54;
pub const IPPROTO_ICMPV6: u32 = 58;
pub const IPPROTO_NONE: u32 = 59;
pub const IPPROTO_DSTOPTS: u32 = 60;
pub const IPPROTO_AHIP: u32 = 61;
pub const IPPROTO_CFTP: u32 = 62;
pub const IPPROTO_HELLO: u32 = 63;
pub const IPPROTO_SATEXPAK: u32 = 64;
pub const IPPROTO_KRYPTOLAN: u32 = 65;
pub const IPPROTO_RVD: u32 = 66;
pub const IPPROTO_IPPC: u32 = 67;
pub const IPPROTO_ADFS: u32 = 68;
pub const IPPROTO_SATMON: u32 = 69;
pub const IPPROTO_VISA: u32 = 70;
pub const IPPROTO_IPCV: u32 = 71;
pub const IPPROTO_CPNX: u32 = 72;
pub const IPPROTO_CPHB: u32 = 73;
pub const IPPROTO_WSN: u32 = 74;
pub const IPPROTO_PVP: u32 = 75;
pub const IPPROTO_BRSATMON: u32 = 76;
pub const IPPROTO_ND: u32 = 77;
pub const IPPROTO_WBMON: u32 = 78;
pub const IPPROTO_WBEXPAK: u32 = 79;
pub const IPPROTO_EON: u32 = 80;
pub const IPPROTO_VMTP: u32 = 81;
pub const IPPROTO_SVMTP: u32 = 82;
pub const IPPROTO_VINES: u32 = 83;
pub const IPPROTO_TTP: u32 = 84;
pub const IPPROTO_IGP: u32 = 85;
pub const IPPROTO_DGP: u32 = 86;
pub const IPPROTO_TCF: u32 = 87;
pub const IPPROTO_IGRP: u32 = 88;
pub const IPPROTO_OSPFIGP: u32 = 89;
pub const IPPROTO_SRPC: u32 = 90;
pub const IPPROTO_LARP: u32 = 91;
pub const IPPROTO_MTP: u32 = 92;
pub const IPPROTO_AX25: u32 = 93;
pub const IPPROTO_IPEIP: u32 = 94;
pub const IPPROTO_MICP: u32 = 95;
pub const IPPROTO_SCCSP: u32 = 96;
pub const IPPROTO_ETHERIP: u32 = 97;
pub const IPPROTO_ENCAP: u32 = 98;
pub const IPPROTO_APES: u32 = 99;
pub const IPPROTO_GMTP: u32 = 100;
pub const IPPROTO_PIM: u32 = 103;
pub const IPPROTO_IPCOMP: u32 = 108;
pub const IPPROTO_PGM: u32 = 113;
pub const IPPROTO_SCTP: u32 = 132;
pub const IPPROTO_DIVERT: u32 = 254;
pub const IPPROTO_RAW: u32 = 255;
pub const IPPROTO_MAX: u32 = 256;
pub const IPPROTO_DONE: u32 = 257;
pub const __DARWIN_IPPORT_RESERVED: u32 = 1024;
pub const IPPORT_USERRESERVED: u32 = 5000;
pub const IPPORT_HIFIRSTAUTO: u32 = 49152;
pub const IPPORT_HILASTAUTO: u32 = 65535;
pub const IPPORT_RESERVEDSTART: u32 = 600;
pub const IN_CLASSA_NET: u32 = 4278190080;
pub const IN_CLASSA_NSHIFT: u32 = 24;
pub const IN_CLASSA_HOST: u32 = 16777215;
pub const IN_CLASSA_MAX: u32 = 128;
pub const IN_CLASSB_NET: u32 = 4294901760;
pub const IN_CLASSB_NSHIFT: u32 = 16;
pub const IN_CLASSB_HOST: u32 = 65535;
pub const IN_CLASSB_MAX: u32 = 65536;
pub const IN_CLASSC_NET: u32 = 4294967040;
pub const IN_CLASSC_NSHIFT: u32 = 8;
pub const IN_CLASSC_HOST: u32 = 255;
pub const IN_CLASSD_NET: u32 = 4026531840;
pub const IN_CLASSD_NSHIFT: u32 = 28;
pub const IN_CLASSD_HOST: u32 = 268435455;
pub const INADDR_NONE: u32 = 4294967295;
pub const IN_LOOPBACKNET: u32 = 127;
pub const INET_ADDRSTRLEN: u32 = 16;
pub const IP_OPTIONS: u32 = 1;
pub const IP_HDRINCL: u32 = 2;
pub const IP_TOS: u32 = 3;
pub const IP_TTL: u32 = 4;
pub const IP_RECVOPTS: u32 = 5;
pub const IP_RECVRETOPTS: u32 = 6;
pub const IP_RECVDSTADDR: u32 = 7;
pub const IP_RETOPTS: u32 = 8;
pub const IP_MULTICAST_IF: u32 = 9;
pub const IP_MULTICAST_TTL: u32 = 10;
pub const IP_MULTICAST_LOOP: u32 = 11;
pub const IP_ADD_MEMBERSHIP: u32 = 12;
pub const IP_DROP_MEMBERSHIP: u32 = 13;
pub const IP_MULTICAST_VIF: u32 = 14;
pub const IP_RSVP_ON: u32 = 15;
pub const IP_RSVP_OFF: u32 = 16;
pub const IP_RSVP_VIF_ON: u32 = 17;
pub const IP_RSVP_VIF_OFF: u32 = 18;
pub const IP_PORTRANGE: u32 = 19;
pub const IP_RECVIF: u32 = 20;
pub const IP_IPSEC_POLICY: u32 = 21;
pub const IP_FAITH: u32 = 22;
pub const IP_STRIPHDR: u32 = 23;
pub const IP_RECVTTL: u32 = 24;
pub const IP_BOUND_IF: u32 = 25;
pub const IP_PKTINFO: u32 = 26;
pub const IP_RECVPKTINFO: u32 = 26;
pub const IP_RECVTOS: u32 = 27;
pub const IP_DONTFRAG: u32 = 28;
pub const IP_FW_ADD: u32 = 40;
pub const IP_FW_DEL: u32 = 41;
pub const IP_FW_FLUSH: u32 = 42;
pub const IP_FW_ZERO: u32 = 43;
pub const IP_FW_GET: u32 = 44;
pub const IP_FW_RESETLOG: u32 = 45;
pub const IP_OLD_FW_ADD: u32 = 50;
pub const IP_OLD_FW_DEL: u32 = 51;
pub const IP_OLD_FW_FLUSH: u32 = 52;
pub const IP_OLD_FW_ZERO: u32 = 53;
pub const IP_OLD_FW_GET: u32 = 54;
pub const IP_NAT__XXX: u32 = 55;
pub const IP_OLD_FW_RESETLOG: u32 = 56;
pub const IP_DUMMYNET_CONFIGURE: u32 = 60;
pub const IP_DUMMYNET_DEL: u32 = 61;
pub const IP_DUMMYNET_FLUSH: u32 = 62;
pub const IP_DUMMYNET_GET: u32 = 64;
pub const IP_TRAFFIC_MGT_BACKGROUND: u32 = 65;
pub const IP_MULTICAST_IFINDEX: u32 = 66;
pub const IP_ADD_SOURCE_MEMBERSHIP: u32 = 70;
pub const IP_DROP_SOURCE_MEMBERSHIP: u32 = 71;
pub const IP_BLOCK_SOURCE: u32 = 72;
pub const IP_UNBLOCK_SOURCE: u32 = 73;
pub const IP_MSFILTER: u32 = 74;
pub const MCAST_JOIN_GROUP: u32 = 80;
pub const MCAST_LEAVE_GROUP: u32 = 81;
pub const MCAST_JOIN_SOURCE_GROUP: u32 = 82;
pub const MCAST_LEAVE_SOURCE_GROUP: u32 = 83;
pub const MCAST_BLOCK_SOURCE: u32 = 84;
pub const MCAST_UNBLOCK_SOURCE: u32 = 85;
pub const IP_DEFAULT_MULTICAST_TTL: u32 = 1;
pub const IP_DEFAULT_MULTICAST_LOOP: u32 = 1;
pub const IP_MIN_MEMBERSHIPS: u32 = 31;
pub const IP_MAX_MEMBERSHIPS: u32 = 4095;
pub const IP_MAX_GROUP_SRC_FILTER: u32 = 512;
pub const IP_MAX_SOCK_SRC_FILTER: u32 = 128;
pub const IP_MAX_SOCK_MUTE_FILTER: u32 = 128;
pub const MCAST_UNDEFINED: u32 = 0;
pub const MCAST_INCLUDE: u32 = 1;
pub const MCAST_EXCLUDE: u32 = 2;
pub const IP_PORTRANGE_DEFAULT: u32 = 0;
pub const IP_PORTRANGE_HIGH: u32 = 1;
pub const IP_PORTRANGE_LOW: u32 = 2;
pub const IPPROTO_MAXID: u32 = 52;
pub const IPCTL_FORWARDING: u32 = 1;
pub const IPCTL_SENDREDIRECTS: u32 = 2;
pub const IPCTL_DEFTTL: u32 = 3;
pub const IPCTL_RTEXPIRE: u32 = 5;
pub const IPCTL_RTMINEXPIRE: u32 = 6;
pub const IPCTL_RTMAXCACHE: u32 = 7;
pub const IPCTL_SOURCEROUTE: u32 = 8;
pub const IPCTL_DIRECTEDBROADCAST: u32 = 9;
pub const IPCTL_INTRQMAXLEN: u32 = 10;
pub const IPCTL_INTRQDROPS: u32 = 11;
pub const IPCTL_STATS: u32 = 12;
pub const IPCTL_ACCEPTSOURCEROUTE: u32 = 13;
pub const IPCTL_FASTFORWARDING: u32 = 14;
pub const IPCTL_KEEPFAITH: u32 = 15;
pub const IPCTL_GIF_TTL: u32 = 16;
pub const IPCTL_MAXID: u32 = 17;
pub const __KAME_VERSION: &[u8; 18usize] = b"2009/apple-darwin\0";
pub const IPV6PORT_RESERVED: u32 = 1024;
pub const IPV6PORT_ANONMIN: u32 = 49152;
pub const IPV6PORT_ANONMAX: u32 = 65535;
pub const IPV6PORT_RESERVEDMIN: u32 = 600;
pub const IPV6PORT_RESERVEDMAX: u32 = 1023;
pub const INET6_ADDRSTRLEN: u32 = 46;
pub const __IPV6_ADDR_SCOPE_NODELOCAL: u32 = 1;
pub const __IPV6_ADDR_SCOPE_INTFACELOCAL: u32 = 1;
pub const __IPV6_ADDR_SCOPE_LINKLOCAL: u32 = 2;
pub const __IPV6_ADDR_SCOPE_SITELOCAL: u32 = 5;
pub const __IPV6_ADDR_SCOPE_ORGLOCAL: u32 = 8;
pub const __IPV6_ADDR_SCOPE_GLOBAL: u32 = 14;
pub const IPV6_ADDR_MC_FLAGS_TRANSIENT: u32 = 16;
pub const IPV6_ADDR_MC_FLAGS_PREFIX: u32 = 32;
pub const IPV6_ADDR_MC_FLAGS_UNICAST_BASED: u32 = 48;
pub const IPV6_SOCKOPT_RESERVED1: u32 = 3;
pub const IPV6_UNICAST_HOPS: u32 = 4;
pub const IPV6_MULTICAST_IF: u32 = 9;
pub const IPV6_MULTICAST_HOPS: u32 = 10;
pub const IPV6_MULTICAST_LOOP: u32 = 11;
pub const IPV6_JOIN_GROUP: u32 = 12;
pub const IPV6_LEAVE_GROUP: u32 = 13;
pub const IPV6_PORTRANGE: u32 = 14;
pub const ICMP6_FILTER: u32 = 18;
pub const IPV6_2292PKTINFO: u32 = 19;
pub const IPV6_2292HOPLIMIT: u32 = 20;
pub const IPV6_2292NEXTHOP: u32 = 21;
pub const IPV6_2292HOPOPTS: u32 = 22;
pub const IPV6_2292DSTOPTS: u32 = 23;
pub const IPV6_2292RTHDR: u32 = 24;
pub const IPV6_2292PKTOPTIONS: u32 = 25;
pub const IPV6_CHECKSUM: u32 = 26;
pub const IPV6_V6ONLY: u32 = 27;
pub const IPV6_BINDV6ONLY: u32 = 27;
pub const IPV6_IPSEC_POLICY: u32 = 28;
pub const IPV6_FAITH: u32 = 29;
pub const IPV6_FW_ADD: u32 = 30;
pub const IPV6_FW_DEL: u32 = 31;
pub const IPV6_FW_FLUSH: u32 = 32;
pub const IPV6_FW_ZERO: u32 = 33;
pub const IPV6_FW_GET: u32 = 34;
pub const IPV6_RECVTCLASS: u32 = 35;
pub const IPV6_TCLASS: u32 = 36;
pub const IPV6_BOUND_IF: u32 = 125;
pub const IPV6_RTHDR_LOOSE: u32 = 0;
pub const IPV6_RTHDR_STRICT: u32 = 1;
pub const IPV6_RTHDR_TYPE_0: u32 = 0;
pub const IPV6_DEFAULT_MULTICAST_HOPS: u32 = 1;
pub const IPV6_DEFAULT_MULTICAST_LOOP: u32 = 1;
pub const IPV6_MIN_MEMBERSHIPS: u32 = 31;
pub const IPV6_MAX_MEMBERSHIPS: u32 = 4095;
pub const IPV6_MAX_GROUP_SRC_FILTER: u32 = 512;
pub const IPV6_MAX_SOCK_SRC_FILTER: u32 = 128;
pub const IPV6_PORTRANGE_DEFAULT: u32 = 0;
pub const IPV6_PORTRANGE_HIGH: u32 = 1;
pub const IPV6_PORTRANGE_LOW: u32 = 2;
pub const IPV6PROTO_MAXID: u32 = 104;
pub const IPV6CTL_FORWARDING: u32 = 1;
pub const IPV6CTL_SENDREDIRECTS: u32 = 2;
pub const IPV6CTL_DEFHLIM: u32 = 3;
pub const IPV6CTL_FORWSRCRT: u32 = 5;
pub const IPV6CTL_STATS: u32 = 6;
pub const IPV6CTL_MRTSTATS: u32 = 7;
pub const IPV6CTL_MRTPROTO: u32 = 8;
pub const IPV6CTL_MAXFRAGPACKETS: u32 = 9;
pub const IPV6CTL_SOURCECHECK: u32 = 10;
pub const IPV6CTL_SOURCECHECK_LOGINT: u32 = 11;
pub const IPV6CTL_ACCEPT_RTADV: u32 = 12;
pub const IPV6CTL_KEEPFAITH: u32 = 13;
pub const IPV6CTL_LOG_INTERVAL: u32 = 14;
pub const IPV6CTL_HDRNESTLIMIT: u32 = 15;
pub const IPV6CTL_DAD_COUNT: u32 = 16;
pub const IPV6CTL_AUTO_FLOWLABEL: u32 = 17;
pub const IPV6CTL_DEFMCASTHLIM: u32 = 18;
pub const IPV6CTL_GIF_HLIM: u32 = 19;
pub const IPV6CTL_KAME_VERSION: u32 = 20;
pub const IPV6CTL_USE_DEPRECATED: u32 = 21;
pub const IPV6CTL_RR_PRUNE: u32 = 22;
pub const IPV6CTL_V6ONLY: u32 = 24;
pub const IPV6CTL_RTEXPIRE: u32 = 25;
pub const IPV6CTL_RTMINEXPIRE: u32 = 26;
pub const IPV6CTL_RTMAXCACHE: u32 = 27;
pub const IPV6CTL_USETEMPADDR: u32 = 32;
pub const IPV6CTL_TEMPPLTIME: u32 = 33;
pub const IPV6CTL_TEMPVLTIME: u32 = 34;
pub const IPV6CTL_AUTO_LINKLOCAL: u32 = 35;
pub const IPV6CTL_RIP6STATS: u32 = 36;
pub const IPV6CTL_PREFER_TEMPADDR: u32 = 37;
pub const IPV6CTL_ADDRCTLPOLICY: u32 = 38;
pub const IPV6CTL_USE_DEFAULTZONE: u32 = 39;
pub const IPV6CTL_MAXFRAGS: u32 = 41;
pub const IPV6CTL_MCAST_PMTU: u32 = 44;
pub const IPV6CTL_NEIGHBORGCTHRESH: u32 = 46;
pub const IPV6CTL_MAXIFPREFIXES: u32 = 47;
pub const IPV6CTL_MAXIFDEFROUTERS: u32 = 48;
pub const IPV6CTL_MAXDYNROUTES: u32 = 49;
pub const ICMPV6CTL_ND6_ONLINKNSRFC4861: u32 = 50;
pub const IPV6CTL_ULA_USETEMPADDR: u32 = 51;
pub const IPV6CTL_MAXID: u32 = 51;
pub const _PATH_HEQUIV: &[u8; 17usize] = b"/etc/hosts.equiv\0";
pub const _PATH_HOSTS: &[u8; 11usize] = b"/etc/hosts\0";
pub const _PATH_NETWORKS: &[u8; 14usize] = b"/etc/networks\0";
pub const _PATH_PROTOCOLS: &[u8; 15usize] = b"/etc/protocols\0";
pub const _PATH_SERVICES: &[u8; 14usize] = b"/etc/services\0";
pub const NETDB_INTERNAL: i32 = -1;
pub const NETDB_SUCCESS: u32 = 0;
pub const HOST_NOT_FOUND: u32 = 1;
pub const TRY_AGAIN: u32 = 2;
pub const NO_RECOVERY: u32 = 3;
pub const NO_DATA: u32 = 4;
pub const NO_ADDRESS: u32 = 4;
pub const EAI_ADDRFAMILY: u32 = 1;
pub const EAI_AGAIN: u32 = 2;
pub const EAI_BADFLAGS: u32 = 3;
pub const EAI_FAIL: u32 = 4;
pub const EAI_FAMILY: u32 = 5;
pub const EAI_MEMORY: u32 = 6;
pub const EAI_NODATA: u32 = 7;
pub const EAI_NONAME: u32 = 8;
pub const EAI_SERVICE: u32 = 9;
pub const EAI_SOCKTYPE: u32 = 10;
pub const EAI_SYSTEM: u32 = 11;
pub const EAI_BADHINTS: u32 = 12;
pub const EAI_PROTOCOL: u32 = 13;
pub const EAI_OVERFLOW: u32 = 14;
pub const EAI_MAX: u32 = 15;
pub const AI_PASSIVE: u32 = 1;
pub const AI_CANONNAME: u32 = 2;
pub const AI_NUMERICHOST: u32 = 4;
pub const AI_NUMERICSERV: u32 = 4096;
pub const AI_ALL: u32 = 256;
pub const AI_V4MAPPED_CFG: u32 = 512;
pub const AI_ADDRCONFIG: u32 = 1024;
pub const AI_V4MAPPED: u32 = 2048;
pub const AI_DEFAULT: u32 = 1536;
pub const AI_UNUSABLE: u32 = 268435456;
pub const NI_MAXHOST: u32 = 1025;
pub const NI_MAXSERV: u32 = 32;
pub const NI_NOFQDN: u32 = 1;
pub const NI_NUMERICHOST: u32 = 2;
pub const NI_NAMEREQD: u32 = 4;
pub const NI_NUMERICSERV: u32 = 8;
pub const NI_NUMERICSCOPE: u32 = 256;
pub const NI_DGRAM: u32 = 16;
pub const NI_WITHSCOPEID: u32 = 32;
pub const SCOPE_DELIMITER: u8 = 37u8;
pub const EPERM: u32 = 1;
pub const ENOENT: u32 = 2;
pub const ESRCH: u32 = 3;
pub const EINTR: u32 = 4;
pub const EIO: u32 = 5;
pub const ENXIO: u32 = 6;
pub const E2BIG: u32 = 7;
pub const ENOEXEC: u32 = 8;
pub const EBADF: u32 = 9;
pub const ECHILD: u32 = 10;
pub const EDEADLK: u32 = 11;
pub const ENOMEM: u32 = 12;
pub const EACCES: u32 = 13;
pub const EFAULT: u32 = 14;
pub const ENOTBLK: u32 = 15;
pub const EBUSY: u32 = 16;
pub const EEXIST: u32 = 17;
pub const EXDEV: u32 = 18;
pub const ENODEV: u32 = 19;
pub const ENOTDIR: u32 = 20;
pub const EISDIR: u32 = 21;
pub const EINVAL: u32 = 22;
pub const ENFILE: u32 = 23;
pub const EMFILE: u32 = 24;
pub const ENOTTY: u32 = 25;
pub const ETXTBSY: u32 = 26;
pub const EFBIG: u32 = 27;
pub const ENOSPC: u32 = 28;
pub const ESPIPE: u32 = 29;
pub const EROFS: u32 = 30;
pub const EMLINK: u32 = 31;
pub const EPIPE: u32 = 32;
pub const EDOM: u32 = 33;
pub const ERANGE: u32 = 34;
pub const EAGAIN: u32 = 35;
pub const EWOULDBLOCK: u32 = 35;
pub const EINPROGRESS: u32 = 36;
pub const EALREADY: u32 = 37;
pub const ENOTSOCK: u32 = 38;
pub const EDESTADDRREQ: u32 = 39;
pub const EMSGSIZE: u32 = 40;
pub const EPROTOTYPE: u32 = 41;
pub const ENOPROTOOPT: u32 = 42;
pub const EPROTONOSUPPORT: u32 = 43;
pub const ESOCKTNOSUPPORT: u32 = 44;
pub const ENOTSUP: u32 = 45;
pub const EPFNOSUPPORT: u32 = 46;
pub const EAFNOSUPPORT: u32 = 47;
pub const EADDRINUSE: u32 = 48;
pub const EADDRNOTAVAIL: u32 = 49;
pub const ENETDOWN: u32 = 50;
pub const ENETUNREACH: u32 = 51;
pub const ENETRESET: u32 = 52;
pub const ECONNABORTED: u32 = 53;
pub const ECONNRESET: u32 = 54;
pub const ENOBUFS: u32 = 55;
pub const EISCONN: u32 = 56;
pub const ENOTCONN: u32 = 57;
pub const ESHUTDOWN: u32 = 58;
pub const ETOOMANYREFS: u32 = 59;
pub const ETIMEDOUT: u32 = 60;
pub const ECONNREFUSED: u32 = 61;
pub const ELOOP: u32 = 62;
pub const ENAMETOOLONG: u32 = 63;
pub const EHOSTDOWN: u32 = 64;
pub const EHOSTUNREACH: u32 = 65;
pub const ENOTEMPTY: u32 = 66;
pub const EPROCLIM: u32 = 67;
pub const EUSERS: u32 = 68;
pub const EDQUOT: u32 = 69;
pub const ESTALE: u32 = 70;
pub const EREMOTE: u32 = 71;
pub const EBADRPC: u32 = 72;
pub const ERPCMISMATCH: u32 = 73;
pub const EPROGUNAVAIL: u32 = 74;
pub const EPROGMISMATCH: u32 = 75;
pub const EPROCUNAVAIL: u32 = 76;
pub const ENOLCK: u32 = 77;
pub const ENOSYS: u32 = 78;
pub const EFTYPE: u32 = 79;
pub const EAUTH: u32 = 80;
pub const ENEEDAUTH: u32 = 81;
pub const EPWROFF: u32 = 82;
pub const EDEVERR: u32 = 83;
pub const EOVERFLOW: u32 = 84;
pub const EBADEXEC: u32 = 85;
pub const EBADARCH: u32 = 86;
pub const ESHLIBVERS: u32 = 87;
pub const EBADMACHO: u32 = 88;
pub const ECANCELED: u32 = 89;
pub const EIDRM: u32 = 90;
pub const ENOMSG: u32 = 91;
pub const EILSEQ: u32 = 92;
pub const ENOATTR: u32 = 93;
pub const EBADMSG: u32 = 94;
pub const EMULTIHOP: u32 = 95;
pub const ENODATA: u32 = 96;
pub const ENOLINK: u32 = 97;
pub const ENOSR: u32 = 98;
pub const ENOSTR: u32 = 99;
pub const EPROTO: u32 = 100;
pub const ETIME: u32 = 101;
pub const EOPNOTSUPP: u32 = 102;
pub const ENOPOLICY: u32 = 103;
pub const ENOTRECOVERABLE: u32 = 104;
pub const EOWNERDEAD: u32 = 105;
pub const EQFULL: u32 = 106;
pub const ELAST: u32 = 106;
pub const EV_UINT64_MAX: i32 = -1;
pub const EV_INT64_MAX: u64 = 9223372036854775807;
pub const EV_INT64_MIN: i64 = -9223372036854775808;
pub const EV_UINT32_MAX: u32 = 4294967295;
pub const EV_INT32_MAX: u32 = 2147483647;
pub const EV_INT32_MIN: i32 = -2147483648;
pub const EV_UINT16_MAX: u32 = 65535;
pub const EV_INT16_MIN: i32 = -32768;
pub const EV_INT16_MAX: u32 = 32767;
pub const EV_UINT8_MAX: u32 = 255;
pub const EV_INT8_MAX: u32 = 127;
pub const EV_INT8_MIN: i32 = -128;
pub const EV_SIZE_MAX: i32 = -1;
pub const EV_SSIZE_MAX: u64 = 9223372036854775807;
pub const EV_SSIZE_MIN: i64 = -9223372036854775808;
pub const EV_MONOT_PRECISE: u32 = 1;
pub const EV_MONOT_FALLBACK: u32 = 2;
pub const EVUTIL_INVALID_SOCKET: i32 = -1;
pub const EVUTIL_EAI_ADDRFAMILY: u32 = 1;
pub const EVUTIL_EAI_AGAIN: u32 = 2;
pub const EVUTIL_EAI_BADFLAGS: u32 = 3;
pub const EVUTIL_EAI_FAIL: u32 = 4;
pub const EVUTIL_EAI_FAMILY: u32 = 5;
pub const EVUTIL_EAI_MEMORY: u32 = 6;
pub const EVUTIL_EAI_NODATA: u32 = 7;
pub const EVUTIL_EAI_NONAME: u32 = 8;
pub const EVUTIL_EAI_SERVICE: u32 = 9;
pub const EVUTIL_EAI_SOCKTYPE: u32 = 10;
pub const EVUTIL_EAI_SYSTEM: u32 = 11;
pub const EVUTIL_EAI_CANCEL: i32 = -90001;
pub const EVUTIL_AI_PASSIVE: u32 = 1;
pub const EVUTIL_AI_CANONNAME: u32 = 2;
pub const EVUTIL_AI_NUMERICHOST: u32 = 4;
pub const EVUTIL_AI_NUMERICSERV: u32 = 4096;
pub const EVUTIL_AI_V4MAPPED: u32 = 2048;
pub const EVUTIL_AI_ALL: u32 = 256;
pub const EVUTIL_AI_ADDRCONFIG: u32 = 1024;
pub const EVLIST_TIMEOUT: u32 = 1;
pub const EVLIST_INSERTED: u32 = 2;
pub const EVLIST_SIGNAL: u32 = 4;
pub const EVLIST_ACTIVE: u32 = 8;
pub const EVLIST_INTERNAL: u32 = 16;
pub const EVLIST_ACTIVE_LATER: u32 = 32;
pub const EVLIST_FINALIZING: u32 = 64;
pub const EVLIST_INIT: u32 = 128;
pub const EVLIST_ALL: u32 = 255;
pub const RENAME_SECLUDE: u32 = 1;
pub const RENAME_SWAP: u32 = 2;
pub const RENAME_EXCL: u32 = 4;
pub const RENAME_RESERVED1: u32 = 8;
pub const RENAME_NOFOLLOW_ANY: u32 = 16;
pub const __SLBF: u32 = 1;
pub const __SNBF: u32 = 2;
pub const __SRD: u32 = 4;
pub const __SWR: u32 = 8;
pub const __SRW: u32 = 16;
pub const __SEOF: u32 = 32;
pub const __SERR: u32 = 64;
pub const __SMBF: u32 = 128;
pub const __SAPP: u32 = 256;
pub const __SSTR: u32 = 512;
pub const __SOPT: u32 = 1024;
pub const __SNPT: u32 = 2048;
pub const __SOFF: u32 = 4096;
pub const __SMOD: u32 = 8192;
pub const __SALC: u32 = 16384;
pub const __SIGN: u32 = 32768;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 1;
pub const _IONBF: u32 = 2;
pub const BUFSIZ: u32 = 1024;
pub const EOF: i32 = -1;
pub const FOPEN_MAX: u32 = 20;
pub const FILENAME_MAX: u32 = 1024;
pub const P_tmpdir: &[u8; 10usize] = b"/var/tmp/\0";
pub const L_tmpnam: u32 = 1024;
pub const TMP_MAX: u32 = 308915776;
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const L_ctermid: u32 = 1024;
pub const _USE_FORTIFY_LEVEL: u32 = 2;
pub const EVENT_BASE_COUNT_ACTIVE: u32 = 1;
pub const EVENT_BASE_COUNT_VIRTUAL: u32 = 2;
pub const EVENT_BASE_COUNT_ADDED: u32 = 4;
pub const EVENT_LOG_DEBUG: u32 = 0;
pub const EVENT_LOG_MSG: u32 = 1;
pub const EVENT_LOG_WARN: u32 = 2;
pub const EVENT_LOG_ERR: u32 = 3;
pub const _EVENT_LOG_DEBUG: u32 = 0;
pub const _EVENT_LOG_MSG: u32 = 1;
pub const _EVENT_LOG_WARN: u32 = 2;
pub const _EVENT_LOG_ERR: u32 = 3;
pub const EVENT_DBG_ALL: u32 = 4294967295;
pub const EVENT_DBG_NONE: u32 = 0;
pub const EVLOOP_ONCE: u32 = 1;
pub const EVLOOP_NONBLOCK: u32 = 2;
pub const EVLOOP_NO_EXIT_ON_EMPTY: u32 = 4;
pub const EV_TIMEOUT: u32 = 1;
pub const EV_READ: u32 = 2;
pub const EV_WRITE: u32 = 4;
pub const EV_SIGNAL: u32 = 8;
pub const EV_PERSIST: u32 = 16;
pub const EV_ET: u32 = 32;
pub const EV_FINALIZE: u32 = 64;
pub const EV_CLOSED: u32 = 128;
pub const LIBEVENT_VERSION: &[u8; 14usize] = b"2.1.12-stable\0";
pub const LIBEVENT_VERSION_NUMBER: u32 = 33623040;
pub const EVENT_MAX_PRIORITIES: u32 = 256;
pub const EVBUFFER_FLAG_DRAINS_TO_FD: u32 = 1;
pub const EVBUF_FS_CLOSE_ON_FREE: u32 = 1;
pub const EVBUF_FS_DISABLE_MMAP: u32 = 2;
pub const EVBUF_FS_DISABLE_SENDFILE: u32 = 4;
pub const EVBUF_FS_DISABLE_LOCKING: u32 = 8;
pub const EVBUFFER_CB_ENABLED: u32 = 1;
pub const BEV_EVENT_READING: u32 = 1;
pub const BEV_EVENT_WRITING: u32 = 2;
pub const BEV_EVENT_EOF: u32 = 16;
pub const BEV_EVENT_ERROR: u32 = 32;
pub const BEV_EVENT_TIMEOUT: u32 = 64;
pub const BEV_EVENT_CONNECTED: u32 = 128;
pub const EV_RATE_LIMIT_MAX: u64 = 9223372036854775807;
pub const EVBUFFER_READ: u32 = 1;
pub const EVBUFFER_WRITE: u32 = 2;
pub const EVBUFFER_EOF: u32 = 16;
pub const EVBUFFER_ERROR: u32 = 32;
pub const EVBUFFER_TIMEOUT: u32 = 64;
pub const DNS_ERR_NONE: u32 = 0;
pub const DNS_ERR_FORMAT: u32 = 1;
pub const DNS_ERR_SERVERFAILED: u32 = 2;
pub const DNS_ERR_NOTEXIST: u32 = 3;
pub const DNS_ERR_NOTIMPL: u32 = 4;
pub const DNS_ERR_REFUSED: u32 = 5;
pub const DNS_ERR_TRUNCATED: u32 = 65;
pub const DNS_ERR_UNKNOWN: u32 = 66;
pub const DNS_ERR_TIMEOUT: u32 = 67;
pub const DNS_ERR_SHUTDOWN: u32 = 68;
pub const DNS_ERR_CANCEL: u32 = 69;
pub const DNS_ERR_NODATA: u32 = 70;
pub const DNS_IPv4_A: u32 = 1;
pub const DNS_PTR: u32 = 2;
pub const DNS_IPv6_AAAA: u32 = 3;
pub const DNS_QUERY_NO_SEARCH: u32 = 1;
pub const DNS_OPTION_SEARCH: u32 = 1;
pub const DNS_OPTION_NAMESERVERS: u32 = 2;
pub const DNS_OPTION_MISC: u32 = 4;
pub const DNS_OPTION_HOSTSFILE: u32 = 8;
pub const DNS_OPTION_NAMESERVERS_NO_DEFAULT: u32 = 16;
pub const DNS_NO_SEARCH: u32 = 1;
pub const EVDNS_BASE_INITIALIZE_NAMESERVERS: u32 = 1;
pub const EVDNS_BASE_DISABLE_WHEN_INACTIVE: u32 = 32768;
pub const EVDNS_BASE_NAMESERVERS_NO_DEFAULT: u32 = 65536;
pub const EVDNS_ANSWER_SECTION: u32 = 0;
pub const EVDNS_AUTHORITY_SECTION: u32 = 1;
pub const EVDNS_ADDITIONAL_SECTION: u32 = 2;
pub const EVDNS_TYPE_A: u32 = 1;
pub const EVDNS_TYPE_NS: u32 = 2;
pub const EVDNS_TYPE_CNAME: u32 = 5;
pub const EVDNS_TYPE_SOA: u32 = 6;
pub const EVDNS_TYPE_PTR: u32 = 12;
pub const EVDNS_TYPE_MX: u32 = 15;
pub const EVDNS_TYPE_TXT: u32 = 16;
pub const EVDNS_TYPE_AAAA: u32 = 28;
pub const EVDNS_QTYPE_AXFR: u32 = 252;
pub const EVDNS_QTYPE_ALL: u32 = 255;
pub const EVDNS_CLASS_INET: u32 = 1;
pub const EVDNS_FLAGS_AA: u32 = 1024;
pub const EVDNS_FLAGS_RD: u32 = 128;
pub const HTTP_OK: u32 = 200;
pub const HTTP_NOCONTENT: u32 = 204;
pub const HTTP_MOVEPERM: u32 = 301;
pub const HTTP_MOVETEMP: u32 = 302;
pub const HTTP_NOTMODIFIED: u32 = 304;
pub const HTTP_BADREQUEST: u32 = 400;
pub const HTTP_NOTFOUND: u32 = 404;
pub const HTTP_BADMETHOD: u32 = 405;
pub const HTTP_ENTITYTOOLARGE: u32 = 413;
pub const HTTP_EXPECTATIONFAILED: u32 = 417;
pub const HTTP_INTERNAL: u32 = 500;
pub const HTTP_NOTIMPLEMENTED: u32 = 501;
pub const HTTP_SERVUNAVAIL: u32 = 503;
pub const EVHTTP_SERVER_LINGERING_CLOSE: u32 = 1;
pub const EVHTTP_CON_REUSE_CONNECTED_ADDR: u32 = 8;
pub const EVHTTP_CON_READ_ON_WRITE_ERROR: u32 = 16;
pub const EVHTTP_CON_LINGERING_CLOSE: u32 = 32;
pub const EVHTTP_CON_PUBLIC_FLAGS_END: u32 = 1048576;
pub const EVHTTP_URI_NONCONFORMANT: u32 = 1;
pub const EVTHREAD_WRITE: u32 = 4;
pub const EVTHREAD_READ: u32 = 8;
pub const EVTHREAD_TRY: u32 = 16;
pub const EVTHREAD_LOCK_API_VERSION: u32 = 1;
pub const EVTHREAD_LOCKTYPE_RECURSIVE: u32 = 1;
pub const EVTHREAD_LOCKTYPE_READWRITE: u32 = 2;
pub const EVTHREAD_CONDITION_API_VERSION: u32 = 1;
pub const EVTHREAD_USE_PTHREADS_IMPLEMENTED: u32 = 1;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_longlong;
pub type __uint64_t = ::std::os::raw::c_ulonglong;
pub type __darwin_intptr_t = ::std::os::raw::c_long;
pub type __darwin_natural_t = ::std::os::raw::c_uint;
pub type __darwin_ct_rune_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t {
    pub __mbstate8: [::std::os::raw::c_char; 128usize],
    pub _mbstateL: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    const UNINIT: ::std::mem::MaybeUninit<__mbstate_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t>(),
        128usize,
        concat!("Size of: ", stringify!(__mbstate_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__mbstate_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__mbstate8) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__mbstate8)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._mbstateL) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(_mbstateL)
        )
    );
}
pub type __darwin_mbstate_t = __mbstate_t;
pub type __darwin_ptrdiff_t = ::std::os::raw::c_long;
pub type __darwin_size_t = ::std::os::raw::c_ulong;
pub type __darwin_va_list = __builtin_va_list;
pub type __darwin_wchar_t = ::std::os::raw::c_int;
pub type __darwin_rune_t = __darwin_wchar_t;
pub type __darwin_wint_t = ::std::os::raw::c_int;
pub type __darwin_clock_t = ::std::os::raw::c_ulong;
pub type __darwin_socklen_t = __uint32_t;
pub type __darwin_ssize_t = ::std::os::raw::c_long;
pub type __darwin_time_t = ::std::os::raw::c_long;
pub type u_int8_t = ::std::os::raw::c_uchar;
pub type u_int16_t = ::std::os::raw::c_ushort;
pub type u_int32_t = ::std::os::raw::c_uint;
pub type u_int64_t = ::std::os::raw::c_ulonglong;
pub type register_t = i64;
pub type user_addr_t = u_int64_t;
pub type user_size_t = u_int64_t;
pub type user_ssize_t = i64;
pub type user_long_t = i64;
pub type user_ulong_t = u_int64_t;
pub type user_time_t = i64;
pub type user_off_t = i64;
pub type syscall_arg_t = u_int64_t;
pub type __darwin_blkcnt_t = __int64_t;
pub type __darwin_blksize_t = __int32_t;
pub type __darwin_dev_t = __int32_t;
pub type __darwin_fsblkcnt_t = ::std::os::raw::c_uint;
pub type __darwin_fsfilcnt_t = ::std::os::raw::c_uint;
pub type __darwin_gid_t = __uint32_t;
pub type __darwin_id_t = __uint32_t;
pub type __darwin_ino64_t = __uint64_t;
pub type __darwin_ino_t = __darwin_ino64_t;
pub type __darwin_mach_port_name_t = __darwin_natural_t;
pub type __darwin_mach_port_t = __darwin_mach_port_name_t;
pub type __darwin_mode_t = __uint16_t;
pub type __darwin_off_t = __int64_t;
pub type __darwin_pid_t = __int32_t;
pub type __darwin_sigset_t = __uint32_t;
pub type __darwin_suseconds_t = __int32_t;
pub type __darwin_uid_t = __uint32_t;
pub type __darwin_useconds_t = __uint32_t;
pub type __darwin_uuid_t = [::std::os::raw::c_uchar; 16usize];
pub type __darwin_uuid_string_t = [::std::os::raw::c_char; 37usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_pthread_handler_rec {
    pub __routine: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    pub __arg: *mut ::std::os::raw::c_void,
    pub __next: *mut __darwin_pthread_handler_rec,
}
#[test]
fn bindgen_test_layout___darwin_pthread_handler_rec() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_pthread_handler_rec> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_pthread_handler_rec>(),
        24usize,
        concat!("Size of: ", stringify!(__darwin_pthread_handler_rec))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_pthread_handler_rec>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_pthread_handler_rec))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__routine) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_pthread_handler_rec),
            "::",
            stringify!(__routine)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__arg) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_pthread_handler_rec),
            "::",
            stringify!(__arg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__next) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_pthread_handler_rec),
            "::",
            stringify!(__next)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_attr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 56usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_attr_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_attr_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_attr_t>(),
        64usize,
        concat!("Size of: ", stringify!(_opaque_pthread_attr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_attr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_attr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_attr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_attr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_cond_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 40usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_cond_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_cond_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_cond_t>(),
        48usize,
        concat!("Size of: ", stringify!(_opaque_pthread_cond_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_cond_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_cond_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_cond_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_cond_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_condattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_condattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_condattr_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_condattr_t>(),
        16usize,
        concat!("Size of: ", stringify!(_opaque_pthread_condattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_condattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_condattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_condattr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_condattr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_mutex_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 56usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_mutex_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_mutex_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_mutex_t>(),
        64usize,
        concat!("Size of: ", stringify!(_opaque_pthread_mutex_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_mutex_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_mutex_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutex_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutex_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_mutexattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_mutexattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_mutexattr_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_mutexattr_t>(),
        16usize,
        concat!("Size of: ", stringify!(_opaque_pthread_mutexattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_mutexattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_mutexattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutexattr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutexattr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_once_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_once_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_once_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_once_t>(),
        16usize,
        concat!("Size of: ", stringify!(_opaque_pthread_once_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_once_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_once_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_once_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_once_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_rwlock_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 192usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_rwlock_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_rwlock_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_rwlock_t>(),
        200usize,
        concat!("Size of: ", stringify!(_opaque_pthread_rwlock_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_rwlock_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_rwlock_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlock_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlock_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_rwlockattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 16usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_rwlockattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_rwlockattr_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_rwlockattr_t>(),
        24usize,
        concat!("Size of: ", stringify!(_opaque_pthread_rwlockattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_rwlockattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_rwlockattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlockattr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlockattr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_t {
    pub __sig: ::std::os::raw::c_long,
    pub __cleanup_stack: *mut __darwin_pthread_handler_rec,
    pub __opaque: [::std::os::raw::c_char; 8176usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_t>(),
        8192usize,
        concat!("Size of: ", stringify!(_opaque_pthread_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__cleanup_stack) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_t),
            "::",
            stringify!(__cleanup_stack)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_t),
            "::",
            stringify!(__opaque)
        )
    );
}
pub type __darwin_pthread_attr_t = _opaque_pthread_attr_t;
pub type __darwin_pthread_cond_t = _opaque_pthread_cond_t;
pub type __darwin_pthread_condattr_t = _opaque_pthread_condattr_t;
pub type __darwin_pthread_key_t = ::std::os::raw::c_ulong;
pub type __darwin_pthread_mutex_t = _opaque_pthread_mutex_t;
pub type __darwin_pthread_mutexattr_t = _opaque_pthread_mutexattr_t;
pub type __darwin_pthread_once_t = _opaque_pthread_once_t;
pub type __darwin_pthread_rwlock_t = _opaque_pthread_rwlock_t;
pub type __darwin_pthread_rwlockattr_t = _opaque_pthread_rwlockattr_t;
pub type __darwin_pthread_t = *mut _opaque_pthread_t;
pub type u_char = ::std::os::raw::c_uchar;
pub type u_short = ::std::os::raw::c_ushort;
pub type u_int = ::std::os::raw::c_uint;
pub type u_long = ::std::os::raw::c_ulong;
pub type ushort = ::std::os::raw::c_ushort;
pub type uint = ::std::os::raw::c_uint;
pub type u_quad_t = u_int64_t;
pub type quad_t = i64;
pub type qaddr_t = *mut quad_t;
pub type caddr_t = *mut ::std::os::raw::c_char;
pub type daddr_t = i32;
pub type dev_t = __darwin_dev_t;
pub type fixpt_t = u_int32_t;
pub type blkcnt_t = __darwin_blkcnt_t;
pub type blksize_t = __darwin_blksize_t;
pub type gid_t = __darwin_gid_t;
pub type in_addr_t = __uint32_t;
pub type in_port_t = __uint16_t;
pub type ino_t = __darwin_ino_t;
pub type ino64_t = __darwin_ino64_t;
pub type key_t = __int32_t;
pub type mode_t = __darwin_mode_t;
pub type nlink_t = __uint16_t;
pub type id_t = __darwin_id_t;
pub type pid_t = __darwin_pid_t;
pub type off_t = __darwin_off_t;
pub type segsz_t = i32;
pub type swblk_t = i32;
pub type uid_t = __darwin_uid_t;
pub type clock_t = __darwin_clock_t;
pub type time_t = __darwin_time_t;
pub type useconds_t = __darwin_useconds_t;
pub type suseconds_t = __darwin_suseconds_t;
pub type rsize_t = __darwin_size_t;
pub type errno_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fd_set {
    pub fds_bits: [__int32_t; 32usize],
}
#[test]
fn bindgen_test_layout_fd_set() {
    const UNINIT: ::std::mem::MaybeUninit<fd_set> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<fd_set>(),
        128usize,
        concat!("Size of: ", stringify!(fd_set))
    );
    assert_eq!(
        ::std::mem::align_of::<fd_set>(),
        4usize,
        concat!("Alignment of ", stringify!(fd_set))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fds_bits) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fd_set),
            "::",
            stringify!(fds_bits)
        )
    );
}
extern "C" {
    pub fn __darwin_check_fd_set_overflow(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_void,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
pub type fd_mask = __int32_t;
pub type pthread_attr_t = __darwin_pthread_attr_t;
pub type pthread_cond_t = __darwin_pthread_cond_t;
pub type pthread_condattr_t = __darwin_pthread_condattr_t;
pub type pthread_mutex_t = __darwin_pthread_mutex_t;
pub type pthread_mutexattr_t = __darwin_pthread_mutexattr_t;
pub type pthread_once_t = __darwin_pthread_once_t;
pub type pthread_rwlock_t = __darwin_pthread_rwlock_t;
pub type pthread_rwlockattr_t = __darwin_pthread_rwlockattr_t;
pub type pthread_t = __darwin_pthread_t;
pub type pthread_key_t = __darwin_pthread_key_t;
pub type fsblkcnt_t = __darwin_fsblkcnt_t;
pub type fsfilcnt_t = __darwin_fsfilcnt_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: __darwin_time_t,
    pub tv_nsec: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_timespec() {
    const UNINIT: ::std::mem::MaybeUninit<timespec> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<timespec>(),
        16usize,
        concat!("Size of: ", stringify!(timespec))
    );
    assert_eq!(
        ::std::mem::align_of::<timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(timespec))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_nsec) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_nsec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval {
    pub tv_sec: __darwin_time_t,
    pub tv_usec: __darwin_suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    const UNINIT: ::std::mem::MaybeUninit<timeval> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<timeval>(),
        16usize,
        concat!("Size of: ", stringify!(timeval))
    );
    assert_eq!(
        ::std::mem::align_of::<timeval>(),
        8usize,
        concat!("Alignment of ", stringify!(timeval))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_usec) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_usec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval64 {
    pub tv_sec: __int64_t,
    pub tv_usec: __int64_t,
}
#[test]
fn bindgen_test_layout_timeval64() {
    const UNINIT: ::std::mem::MaybeUninit<timeval64> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<timeval64>(),
        16usize,
        concat!("Size of: ", stringify!(timeval64))
    );
    assert_eq!(
        ::std::mem::align_of::<timeval64>(),
        8usize,
        concat!("Alignment of ", stringify!(timeval64))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval64),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_usec) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval64),
            "::",
            stringify!(tv_usec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct itimerval {
    pub it_interval: timeval,
    pub it_value: timeval,
}
#[test]
fn bindgen_test_layout_itimerval() {
    const UNINIT: ::std::mem::MaybeUninit<itimerval> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<itimerval>(),
        32usize,
        concat!("Size of: ", stringify!(itimerval))
    );
    assert_eq!(
        ::std::mem::align_of::<itimerval>(),
        8usize,
        concat!("Alignment of ", stringify!(itimerval))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).it_interval) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerval),
            "::",
            stringify!(it_interval)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).it_value) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerval),
            "::",
            stringify!(it_value)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timezone {
    pub tz_minuteswest: ::std::os::raw::c_int,
    pub tz_dsttime: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_timezone() {
    const UNINIT: ::std::mem::MaybeUninit<timezone> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<timezone>(),
        8usize,
        concat!("Size of: ", stringify!(timezone))
    );
    assert_eq!(
        ::std::mem::align_of::<timezone>(),
        4usize,
        concat!("Alignment of ", stringify!(timezone))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tz_minuteswest) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timezone),
            "::",
            stringify!(tz_minuteswest)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tz_dsttime) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(timezone),
            "::",
            stringify!(tz_dsttime)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct clockinfo {
    pub hz: ::std::os::raw::c_int,
    pub tick: ::std::os::raw::c_int,
    pub tickadj: ::std::os::raw::c_int,
    pub stathz: ::std::os::raw::c_int,
    pub profhz: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_clockinfo() {
    const UNINIT: ::std::mem::MaybeUninit<clockinfo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<clockinfo>(),
        20usize,
        concat!("Size of: ", stringify!(clockinfo))
    );
    assert_eq!(
        ::std::mem::align_of::<clockinfo>(),
        4usize,
        concat!("Alignment of ", stringify!(clockinfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hz) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(clockinfo),
            "::",
            stringify!(hz)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tick) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(clockinfo),
            "::",
            stringify!(tick)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tickadj) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(clockinfo),
            "::",
            stringify!(tickadj)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stathz) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(clockinfo),
            "::",
            stringify!(stathz)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).profhz) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(clockinfo),
            "::",
            stringify!(profhz)
        )
    );
}
pub type __darwin_nl_item = ::std::os::raw::c_int;
pub type __darwin_wctrans_t = ::std::os::raw::c_int;
pub type __darwin_wctype_t = __uint32_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tm {
    pub tm_sec: ::std::os::raw::c_int,
    pub tm_min: ::std::os::raw::c_int,
    pub tm_hour: ::std::os::raw::c_int,
    pub tm_mday: ::std::os::raw::c_int,
    pub tm_mon: ::std::os::raw::c_int,
    pub tm_year: ::std::os::raw::c_int,
    pub tm_wday: ::std::os::raw::c_int,
    pub tm_yday: ::std::os::raw::c_int,
    pub tm_isdst: ::std::os::raw::c_int,
    pub tm_gmtoff: ::std::os::raw::c_long,
    pub tm_zone: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_tm() {
    const UNINIT: ::std::mem::MaybeUninit<tm> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<tm>(),
        56usize,
        concat!("Size of: ", stringify!(tm))
    );
    assert_eq!(
        ::std::mem::align_of::<tm>(),
        8usize,
        concat!("Alignment of ", stringify!(tm))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_min) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_min)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_hour) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_hour)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_mday) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_mday)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_mon) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_mon)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_year) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_year)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_wday) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_wday)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_yday) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_yday)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_isdst) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_isdst)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_gmtoff) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_gmtoff)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_zone) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_zone)
        )
    );
}
extern "C" {
    pub static mut tzname: [*mut ::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut getdate_err: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut timezone: ::std::os::raw::c_long;
}
extern "C" {
    pub static mut daylight: ::std::os::raw::c_int;
}
extern "C" {
    pub fn asctime(arg1: *const tm) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn clock() -> clock_t;
}
extern "C" {
    pub fn ctime(arg1: *const time_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn difftime(arg1: time_t, arg2: time_t) -> f64;
}
extern "C" {
    pub fn getdate(arg1: *const ::std::os::raw::c_char) -> *mut tm;
}
extern "C" {
    pub fn gmtime(arg1: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn localtime(arg1: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn mktime(arg1: *mut tm) -> time_t;
}
extern "C" {
    pub fn strftime(
        arg1: *mut ::std::os::raw::c_char,
        arg2: usize,
        arg3: *const ::std::os::raw::c_char,
        arg4: *const tm,
    ) -> usize;
}
extern "C" {
    pub fn strptime(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut tm,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn time(arg1: *mut time_t) -> time_t;
}
extern "C" {
    pub fn tzset();
}
extern "C" {
    pub fn asctime_r(
        arg1: *const tm,
        arg2: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ctime_r(
        arg1: *const time_t,
        arg2: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn gmtime_r(arg1: *const time_t, arg2: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn localtime_r(arg1: *const time_t, arg2: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn posix2time(arg1: time_t) -> time_t;
}
extern "C" {
    pub fn tzsetwall();
}
extern "C" {
    pub fn time2posix(arg1: time_t) -> time_t;
}
extern "C" {
    pub fn timelocal(arg1: *mut tm) -> time_t;
}
extern "C" {
    pub fn timegm(arg1: *mut tm) -> time_t;
}
extern "C" {
    pub fn nanosleep(__rqtp: *const timespec, __rmtp: *mut timespec) -> ::std::os::raw::c_int;
}
pub const clockid_t__CLOCK_REALTIME: clockid_t = 0;
pub const clockid_t__CLOCK_MONOTONIC: clockid_t = 6;
pub const clockid_t__CLOCK_MONOTONIC_RAW: clockid_t = 4;
pub const clockid_t__CLOCK_MONOTONIC_RAW_APPROX: clockid_t = 5;
pub const clockid_t__CLOCK_UPTIME_RAW: clockid_t = 8;
pub const clockid_t__CLOCK_UPTIME_RAW_APPROX: clockid_t = 9;
pub const clockid_t__CLOCK_PROCESS_CPUTIME_ID: clockid_t = 12;
pub const clockid_t__CLOCK_THREAD_CPUTIME_ID: clockid_t = 16;
pub type clockid_t = ::std::os::raw::c_uint;
extern "C" {
    pub fn clock_getres(__clock_id: clockid_t, __res: *mut timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_gettime(__clock_id: clockid_t, __tp: *mut timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_gettime_nsec_np(__clock_id: clockid_t) -> __uint64_t;
}
extern "C" {
    pub fn clock_settime(__clock_id: clockid_t, __tp: *const timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timespec_get(ts: *mut timespec, base: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn adjtime(arg1: *const timeval, arg2: *mut timeval) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn futimes(arg1: ::std::os::raw::c_int, arg2: *const timeval) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lutimes(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const timeval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn settimeofday(arg1: *const timeval, arg2: *const timezone) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getitimer(arg1: ::std::os::raw::c_int, arg2: *mut itimerval) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gettimeofday(
        arg1: *mut timeval,
        arg2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_select$1050"]
    pub fn select(
        arg1: ::std::os::raw::c_int,
        arg2: *mut fd_set,
        arg3: *mut fd_set,
        arg4: *mut fd_set,
        arg5: *mut timeval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setitimer(
        arg1: ::std::os::raw::c_int,
        arg2: *const itimerval,
        arg3: *mut itimerval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn utimes(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const timeval,
    ) -> ::std::os::raw::c_int;
}
pub type int_least8_t = i8;
pub type int_least16_t = i16;
pub type int_least32_t = i32;
pub type int_least64_t = i64;
pub type uint_least8_t = u8;
pub type uint_least16_t = u16;
pub type uint_least32_t = u32;
pub type uint_least64_t = u64;
pub type int_fast8_t = i8;
pub type int_fast16_t = i16;
pub type int_fast32_t = i32;
pub type int_fast64_t = i64;
pub type uint_fast8_t = u8;
pub type uint_fast16_t = u16;
pub type uint_fast32_t = u32;
pub type uint_fast64_t = u64;
pub type intmax_t = ::std::os::raw::c_long;
pub type uintmax_t = ::std::os::raw::c_ulong;
pub type __gnuc_va_list = __builtin_va_list;
pub type va_list = __builtin_va_list;
pub type wchar_t = ::std::os::raw::c_int;
pub type max_align_t = u128;
pub type socklen_t = __darwin_socklen_t;
pub type sa_family_t = __uint8_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iovec {
    pub iov_base: *mut ::std::os::raw::c_void,
    pub iov_len: usize,
}
#[test]
fn bindgen_test_layout_iovec() {
    const UNINIT: ::std::mem::MaybeUninit<iovec> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<iovec>(),
        16usize,
        concat!("Size of: ", stringify!(iovec))
    );
    assert_eq!(
        ::std::mem::align_of::<iovec>(),
        8usize,
        concat!("Alignment of ", stringify!(iovec))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).iov_base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(iovec),
            "::",
            stringify!(iov_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).iov_len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(iovec),
            "::",
            stringify!(iov_len)
        )
    );
}
pub type sae_associd_t = __uint32_t;
pub type sae_connid_t = __uint32_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sa_endpoints {
    pub sae_srcif: ::std::os::raw::c_uint,
    pub sae_srcaddr: *const sockaddr,
    pub sae_srcaddrlen: socklen_t,
    pub sae_dstaddr: *const sockaddr,
    pub sae_dstaddrlen: socklen_t,
}
#[test]
fn bindgen_test_layout_sa_endpoints() {
    const UNINIT: ::std::mem::MaybeUninit<sa_endpoints> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sa_endpoints>(),
        40usize,
        concat!("Size of: ", stringify!(sa_endpoints))
    );
    assert_eq!(
        ::std::mem::align_of::<sa_endpoints>(),
        8usize,
        concat!("Alignment of ", stringify!(sa_endpoints))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sae_srcif) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sa_endpoints),
            "::",
            stringify!(sae_srcif)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sae_srcaddr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sa_endpoints),
            "::",
            stringify!(sae_srcaddr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sae_srcaddrlen) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sa_endpoints),
            "::",
            stringify!(sae_srcaddrlen)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sae_dstaddr) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sa_endpoints),
            "::",
            stringify!(sae_dstaddr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sae_dstaddrlen) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(sa_endpoints),
            "::",
            stringify!(sae_dstaddrlen)
        )
    );
}
pub type sa_endpoints_t = sa_endpoints;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct linger {
    pub l_onoff: ::std::os::raw::c_int,
    pub l_linger: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_linger() {
    const UNINIT: ::std::mem::MaybeUninit<linger> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<linger>(),
        8usize,
        concat!("Size of: ", stringify!(linger))
    );
    assert_eq!(
        ::std::mem::align_of::<linger>(),
        4usize,
        concat!("Alignment of ", stringify!(linger))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).l_onoff) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(linger),
            "::",
            stringify!(l_onoff)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).l_linger) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(linger),
            "::",
            stringify!(l_linger)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct so_np_extensions {
    pub npx_flags: u_int32_t,
    pub npx_mask: u_int32_t,
}
#[test]
fn bindgen_test_layout_so_np_extensions() {
    const UNINIT: ::std::mem::MaybeUninit<so_np_extensions> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<so_np_extensions>(),
        8usize,
        concat!("Size of: ", stringify!(so_np_extensions))
    );
    assert_eq!(
        ::std::mem::align_of::<so_np_extensions>(),
        4usize,
        concat!("Alignment of ", stringify!(so_np_extensions))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).npx_flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(so_np_extensions),
            "::",
            stringify!(npx_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).npx_mask) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(so_np_extensions),
            "::",
            stringify!(npx_mask)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr {
    pub sa_len: __uint8_t,
    pub sa_family: sa_family_t,
    pub sa_data: [::std::os::raw::c_char; 14usize],
}
#[test]
fn bindgen_test_layout_sockaddr() {
    const UNINIT: ::std::mem::MaybeUninit<sockaddr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sockaddr>(),
        16usize,
        concat!("Size of: ", stringify!(sockaddr))
    );
    assert_eq!(
        ::std::mem::align_of::<sockaddr>(),
        1usize,
        concat!("Alignment of ", stringify!(sockaddr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sa_len) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr),
            "::",
            stringify!(sa_len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sa_family) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr),
            "::",
            stringify!(sa_family)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sa_data) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr),
            "::",
            stringify!(sa_data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sockaddr_header {
    pub sa_len: __uint8_t,
    pub sa_family: sa_family_t,
}
#[test]
fn bindgen_test_layout___sockaddr_header() {
    const UNINIT: ::std::mem::MaybeUninit<__sockaddr_header> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__sockaddr_header>(),
        2usize,
        concat!("Size of: ", stringify!(__sockaddr_header))
    );
    assert_eq!(
        ::std::mem::align_of::<__sockaddr_header>(),
        1usize,
        concat!("Alignment of ", stringify!(__sockaddr_header))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sa_len) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sockaddr_header),
            "::",
            stringify!(sa_len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sa_family) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(__sockaddr_header),
            "::",
            stringify!(sa_family)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockproto {
    pub sp_family: __uint16_t,
    pub sp_protocol: __uint16_t,
}
#[test]
fn bindgen_test_layout_sockproto() {
    const UNINIT: ::std::mem::MaybeUninit<sockproto> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sockproto>(),
        4usize,
        concat!("Size of: ", stringify!(sockproto))
    );
    assert_eq!(
        ::std::mem::align_of::<sockproto>(),
        2usize,
        concat!("Alignment of ", stringify!(sockproto))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sp_family) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sockproto),
            "::",
            stringify!(sp_family)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sp_protocol) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sockproto),
            "::",
            stringify!(sp_protocol)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr_storage {
    pub ss_len: __uint8_t,
    pub ss_family: sa_family_t,
    pub __ss_pad1: [::std::os::raw::c_char; 6usize],
    pub __ss_align: __int64_t,
    pub __ss_pad2: [::std::os::raw::c_char; 112usize],
}
#[test]
fn bindgen_test_layout_sockaddr_storage() {
    const UNINIT: ::std::mem::MaybeUninit<sockaddr_storage> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sockaddr_storage>(),
        128usize,
        concat!("Size of: ", stringify!(sockaddr_storage))
    );
    assert_eq!(
        ::std::mem::align_of::<sockaddr_storage>(),
        8usize,
        concat!("Alignment of ", stringify!(sockaddr_storage))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ss_len) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_storage),
            "::",
            stringify!(ss_len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ss_family) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_storage),
            "::",
            stringify!(ss_family)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ss_pad1) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_storage),
            "::",
            stringify!(__ss_pad1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ss_align) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_storage),
            "::",
            stringify!(__ss_align)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ss_pad2) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_storage),
            "::",
            stringify!(__ss_pad2)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct msghdr {
    pub msg_name: *mut ::std::os::raw::c_void,
    pub msg_namelen: socklen_t,
    pub msg_iov: *mut iovec,
    pub msg_iovlen: ::std::os::raw::c_int,
    pub msg_control: *mut ::std::os::raw::c_void,
    pub msg_controllen: socklen_t,
    pub msg_flags: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_msghdr() {
    const UNINIT: ::std::mem::MaybeUninit<msghdr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<msghdr>(),
        48usize,
        concat!("Size of: ", stringify!(msghdr))
    );
    assert_eq!(
        ::std::mem::align_of::<msghdr>(),
        8usize,
        concat!("Alignment of ", stringify!(msghdr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msg_name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(msg_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msg_namelen) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(msg_namelen)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msg_iov) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(msg_iov)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msg_iovlen) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(msg_iovlen)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msg_control) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(msg_control)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msg_controllen) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(msg_controllen)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msg_flags) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(msg_flags)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cmsghdr {
    pub cmsg_len: socklen_t,
    pub cmsg_level: ::std::os::raw::c_int,
    pub cmsg_type: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_cmsghdr() {
    const UNINIT: ::std::mem::MaybeUninit<cmsghdr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cmsghdr>(),
        12usize,
        concat!("Size of: ", stringify!(cmsghdr))
    );
    assert_eq!(
        ::std::mem::align_of::<cmsghdr>(),
        4usize,
        concat!("Alignment of ", stringify!(cmsghdr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cmsg_len) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cmsghdr),
            "::",
            stringify!(cmsg_len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cmsg_level) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cmsghdr),
            "::",
            stringify!(cmsg_level)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cmsg_type) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cmsghdr),
            "::",
            stringify!(cmsg_type)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sf_hdtr {
    pub headers: *mut iovec,
    pub hdr_cnt: ::std::os::raw::c_int,
    pub trailers: *mut iovec,
    pub trl_cnt: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_sf_hdtr() {
    const UNINIT: ::std::mem::MaybeUninit<sf_hdtr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sf_hdtr>(),
        32usize,
        concat!("Size of: ", stringify!(sf_hdtr))
    );
    assert_eq!(
        ::std::mem::align_of::<sf_hdtr>(),
        8usize,
        concat!("Alignment of ", stringify!(sf_hdtr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).headers) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sf_hdtr),
            "::",
            stringify!(headers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hdr_cnt) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sf_hdtr),
            "::",
            stringify!(hdr_cnt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).trailers) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sf_hdtr),
            "::",
            stringify!(trailers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).trl_cnt) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sf_hdtr),
            "::",
            stringify!(trl_cnt)
        )
    );
}
extern "C" {
    pub fn accept(
        arg1: ::std::os::raw::c_int,
        arg2: *mut sockaddr,
        arg3: *mut socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bind(
        arg1: ::std::os::raw::c_int,
        arg2: *const sockaddr,
        arg3: socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn connect(
        arg1: ::std::os::raw::c_int,
        arg2: *const sockaddr,
        arg3: socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getpeername(
        arg1: ::std::os::raw::c_int,
        arg2: *mut sockaddr,
        arg3: *mut socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getsockname(
        arg1: ::std::os::raw::c_int,
        arg2: *mut sockaddr,
        arg3: *mut socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getsockopt(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
        arg4: *mut ::std::os::raw::c_void,
        arg5: *mut socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn listen(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn recv(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_void,
        arg3: usize,
        arg4: ::std::os::raw::c_int,
    ) -> isize;
}
extern "C" {
    pub fn recvfrom(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_void,
        arg3: usize,
        arg4: ::std::os::raw::c_int,
        arg5: *mut sockaddr,
        arg6: *mut socklen_t,
    ) -> isize;
}
extern "C" {
    pub fn recvmsg(
        arg1: ::std::os::raw::c_int,
        arg2: *mut msghdr,
        arg3: ::std::os::raw::c_int,
    ) -> isize;
}
extern "C" {
    pub fn send(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_void,
        arg3: usize,
        arg4: ::std::os::raw::c_int,
    ) -> isize;
}
extern "C" {
    pub fn sendmsg(
        arg1: ::std::os::raw::c_int,
        arg2: *const msghdr,
        arg3: ::std::os::raw::c_int,
    ) -> isize;
}
extern "C" {
    pub fn sendto(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_void,
        arg3: usize,
        arg4: ::std::os::raw::c_int,
        arg5: *const sockaddr,
        arg6: socklen_t,
    ) -> isize;
}
extern "C" {
    pub fn setsockopt(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
        arg4: *const ::std::os::raw::c_void,
        arg5: socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn shutdown(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sockatmark(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn socket(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn socketpair(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
        arg4: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sendfile(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
        arg3: off_t,
        arg4: *mut off_t,
        arg5: *mut sf_hdtr,
        arg6: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pfctlinput(arg1: ::std::os::raw::c_int, arg2: *mut sockaddr);
}
extern "C" {
    pub fn connectx(
        arg1: ::std::os::raw::c_int,
        arg2: *const sa_endpoints_t,
        arg3: sae_associd_t,
        arg4: ::std::os::raw::c_uint,
        arg5: *const iovec,
        arg6: ::std::os::raw::c_uint,
        arg7: *mut usize,
        arg8: *mut sae_connid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn disconnectx(
        arg1: ::std::os::raw::c_int,
        arg2: sae_associd_t,
        arg3: sae_connid_t,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct in_addr {
    pub s_addr: in_addr_t,
}
#[test]
fn bindgen_test_layout_in_addr() {
    const UNINIT: ::std::mem::MaybeUninit<in_addr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<in_addr>(),
        4usize,
        concat!("Size of: ", stringify!(in_addr))
    );
    assert_eq!(
        ::std::mem::align_of::<in_addr>(),
        4usize,
        concat!("Alignment of ", stringify!(in_addr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).s_addr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in_addr),
            "::",
            stringify!(s_addr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr_in {
    pub sin_len: __uint8_t,
    pub sin_family: sa_family_t,
    pub sin_port: in_port_t,
    pub sin_addr: in_addr,
    pub sin_zero: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout_sockaddr_in() {
    const UNINIT: ::std::mem::MaybeUninit<sockaddr_in> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sockaddr_in>(),
        16usize,
        concat!("Size of: ", stringify!(sockaddr_in))
    );
    assert_eq!(
        ::std::mem::align_of::<sockaddr_in>(),
        4usize,
        concat!("Alignment of ", stringify!(sockaddr_in))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sin_len) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in),
            "::",
            stringify!(sin_len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sin_family) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in),
            "::",
            stringify!(sin_family)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sin_port) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in),
            "::",
            stringify!(sin_port)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sin_addr) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in),
            "::",
            stringify!(sin_addr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sin_zero) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in),
            "::",
            stringify!(sin_zero)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip_opts {
    pub ip_dst: in_addr,
    pub ip_opts: [::std::os::raw::c_char; 40usize],
}
#[test]
fn bindgen_test_layout_ip_opts() {
    const UNINIT: ::std::mem::MaybeUninit<ip_opts> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ip_opts>(),
        44usize,
        concat!("Size of: ", stringify!(ip_opts))
    );
    assert_eq!(
        ::std::mem::align_of::<ip_opts>(),
        4usize,
        concat!("Alignment of ", stringify!(ip_opts))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ip_dst) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_opts),
            "::",
            stringify!(ip_dst)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ip_opts) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_opts),
            "::",
            stringify!(ip_opts)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip_mreq {
    pub imr_multiaddr: in_addr,
    pub imr_interface: in_addr,
}
#[test]
fn bindgen_test_layout_ip_mreq() {
    const UNINIT: ::std::mem::MaybeUninit<ip_mreq> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ip_mreq>(),
        8usize,
        concat!("Size of: ", stringify!(ip_mreq))
    );
    assert_eq!(
        ::std::mem::align_of::<ip_mreq>(),
        4usize,
        concat!("Alignment of ", stringify!(ip_mreq))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).imr_multiaddr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_mreq),
            "::",
            stringify!(imr_multiaddr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).imr_interface) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_mreq),
            "::",
            stringify!(imr_interface)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip_mreqn {
    pub imr_multiaddr: in_addr,
    pub imr_address: in_addr,
    pub imr_ifindex: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_ip_mreqn() {
    const UNINIT: ::std::mem::MaybeUninit<ip_mreqn> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ip_mreqn>(),
        12usize,
        concat!("Size of: ", stringify!(ip_mreqn))
    );
    assert_eq!(
        ::std::mem::align_of::<ip_mreqn>(),
        4usize,
        concat!("Alignment of ", stringify!(ip_mreqn))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).imr_multiaddr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_mreqn),
            "::",
            stringify!(imr_multiaddr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).imr_address) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_mreqn),
            "::",
            stringify!(imr_address)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).imr_ifindex) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_mreqn),
            "::",
            stringify!(imr_ifindex)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip_mreq_source {
    pub imr_multiaddr: in_addr,
    pub imr_sourceaddr: in_addr,
    pub imr_interface: in_addr,
}
#[test]
fn bindgen_test_layout_ip_mreq_source() {
    const UNINIT: ::std::mem::MaybeUninit<ip_mreq_source> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ip_mreq_source>(),
        12usize,
        concat!("Size of: ", stringify!(ip_mreq_source))
    );
    assert_eq!(
        ::std::mem::align_of::<ip_mreq_source>(),
        4usize,
        concat!("Alignment of ", stringify!(ip_mreq_source))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).imr_multiaddr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_mreq_source),
            "::",
            stringify!(imr_multiaddr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).imr_sourceaddr) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_mreq_source),
            "::",
            stringify!(imr_sourceaddr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).imr_interface) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_mreq_source),
            "::",
            stringify!(imr_interface)
        )
    );
}
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct group_req {
    pub gr_interface: u32,
    pub gr_group: sockaddr_storage,
}
#[test]
fn bindgen_test_layout_group_req() {
    const UNINIT: ::std::mem::MaybeUninit<group_req> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<group_req>(),
        132usize,
        concat!("Size of: ", stringify!(group_req))
    );
    assert_eq!(
        ::std::mem::align_of::<group_req>(),
        4usize,
        concat!("Alignment of ", stringify!(group_req))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gr_interface) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(group_req),
            "::",
            stringify!(gr_interface)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gr_group) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(group_req),
            "::",
            stringify!(gr_group)
        )
    );
}
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct group_source_req {
    pub gsr_interface: u32,
    pub gsr_group: sockaddr_storage,
    pub gsr_source: sockaddr_storage,
}
#[test]
fn bindgen_test_layout_group_source_req() {
    const UNINIT: ::std::mem::MaybeUninit<group_source_req> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<group_source_req>(),
        260usize,
        concat!("Size of: ", stringify!(group_source_req))
    );
    assert_eq!(
        ::std::mem::align_of::<group_source_req>(),
        4usize,
        concat!("Alignment of ", stringify!(group_source_req))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gsr_interface) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(group_source_req),
            "::",
            stringify!(gsr_interface)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gsr_group) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(group_source_req),
            "::",
            stringify!(gsr_group)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gsr_source) as usize - ptr as usize },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(group_source_req),
            "::",
            stringify!(gsr_source)
        )
    );
}
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct __msfilterreq {
    pub msfr_ifindex: u32,
    pub msfr_fmode: u32,
    pub msfr_nsrcs: u32,
    pub __msfr_align: u32,
    pub msfr_group: sockaddr_storage,
    pub msfr_srcs: *mut sockaddr_storage,
}
#[test]
fn bindgen_test_layout___msfilterreq() {
    const UNINIT: ::std::mem::MaybeUninit<__msfilterreq> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__msfilterreq>(),
        152usize,
        concat!("Size of: ", stringify!(__msfilterreq))
    );
    assert_eq!(
        ::std::mem::align_of::<__msfilterreq>(),
        4usize,
        concat!("Alignment of ", stringify!(__msfilterreq))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msfr_ifindex) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__msfilterreq),
            "::",
            stringify!(msfr_ifindex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msfr_fmode) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__msfilterreq),
            "::",
            stringify!(msfr_fmode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msfr_nsrcs) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__msfilterreq),
            "::",
            stringify!(msfr_nsrcs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__msfr_align) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__msfilterreq),
            "::",
            stringify!(__msfr_align)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msfr_group) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__msfilterreq),
            "::",
            stringify!(msfr_group)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msfr_srcs) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(__msfilterreq),
            "::",
            stringify!(msfr_srcs)
        )
    );
}
extern "C" {
    pub fn setipv4sourcefilter(
        arg1: ::std::os::raw::c_int,
        arg2: in_addr,
        arg3: in_addr,
        arg4: u32,
        arg5: u32,
        arg6: *mut in_addr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getipv4sourcefilter(
        arg1: ::std::os::raw::c_int,
        arg2: in_addr,
        arg3: in_addr,
        arg4: *mut u32,
        arg5: *mut u32,
        arg6: *mut in_addr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setsourcefilter(
        arg1: ::std::os::raw::c_int,
        arg2: u32,
        arg3: *mut sockaddr,
        arg4: socklen_t,
        arg5: u32,
        arg6: u32,
        arg7: *mut sockaddr_storage,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getsourcefilter(
        arg1: ::std::os::raw::c_int,
        arg2: u32,
        arg3: *mut sockaddr,
        arg4: socklen_t,
        arg5: *mut u32,
        arg6: *mut u32,
        arg7: *mut sockaddr_storage,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct in_pktinfo {
    pub ipi_ifindex: ::std::os::raw::c_uint,
    pub ipi_spec_dst: in_addr,
    pub ipi_addr: in_addr,
}
#[test]
fn bindgen_test_layout_in_pktinfo() {
    const UNINIT: ::std::mem::MaybeUninit<in_pktinfo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<in_pktinfo>(),
        12usize,
        concat!("Size of: ", stringify!(in_pktinfo))
    );
    assert_eq!(
        ::std::mem::align_of::<in_pktinfo>(),
        4usize,
        concat!("Alignment of ", stringify!(in_pktinfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ipi_ifindex) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in_pktinfo),
            "::",
            stringify!(ipi_ifindex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ipi_spec_dst) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(in_pktinfo),
            "::",
            stringify!(ipi_spec_dst)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ipi_addr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(in_pktinfo),
            "::",
            stringify!(ipi_addr)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct in6_addr {
    pub __u6_addr: in6_addr__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union in6_addr__bindgen_ty_1 {
    pub __u6_addr8: [__uint8_t; 16usize],
    pub __u6_addr16: [__uint16_t; 8usize],
    pub __u6_addr32: [__uint32_t; 4usize],
}
#[test]
fn bindgen_test_layout_in6_addr__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<in6_addr__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<in6_addr__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(in6_addr__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<in6_addr__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(in6_addr__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__u6_addr8) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in6_addr__bindgen_ty_1),
            "::",
            stringify!(__u6_addr8)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__u6_addr16) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in6_addr__bindgen_ty_1),
            "::",
            stringify!(__u6_addr16)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__u6_addr32) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in6_addr__bindgen_ty_1),
            "::",
            stringify!(__u6_addr32)
        )
    );
}
#[test]
fn bindgen_test_layout_in6_addr() {
    const UNINIT: ::std::mem::MaybeUninit<in6_addr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<in6_addr>(),
        16usize,
        concat!("Size of: ", stringify!(in6_addr))
    );
    assert_eq!(
        ::std::mem::align_of::<in6_addr>(),
        4usize,
        concat!("Alignment of ", stringify!(in6_addr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__u6_addr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in6_addr),
            "::",
            stringify!(__u6_addr)
        )
    );
}
pub type in6_addr_t = in6_addr;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sockaddr_in6 {
    pub sin6_len: __uint8_t,
    pub sin6_family: sa_family_t,
    pub sin6_port: in_port_t,
    pub sin6_flowinfo: __uint32_t,
    pub sin6_addr: in6_addr,
    pub sin6_scope_id: __uint32_t,
}
#[test]
fn bindgen_test_layout_sockaddr_in6() {
    const UNINIT: ::std::mem::MaybeUninit<sockaddr_in6> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sockaddr_in6>(),
        28usize,
        concat!("Size of: ", stringify!(sockaddr_in6))
    );
    assert_eq!(
        ::std::mem::align_of::<sockaddr_in6>(),
        4usize,
        concat!("Alignment of ", stringify!(sockaddr_in6))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sin6_len) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in6),
            "::",
            stringify!(sin6_len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sin6_family) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in6),
            "::",
            stringify!(sin6_family)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sin6_port) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in6),
            "::",
            stringify!(sin6_port)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sin6_flowinfo) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in6),
            "::",
            stringify!(sin6_flowinfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sin6_addr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in6),
            "::",
            stringify!(sin6_addr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sin6_scope_id) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in6),
            "::",
            stringify!(sin6_scope_id)
        )
    );
}
extern "C" {
    pub static in6addr_any: in6_addr;
}
extern "C" {
    pub static in6addr_loopback: in6_addr;
}
extern "C" {
    pub static in6addr_nodelocal_allnodes: in6_addr;
}
extern "C" {
    pub static in6addr_linklocal_allnodes: in6_addr;
}
extern "C" {
    pub static in6addr_linklocal_allrouters: in6_addr;
}
extern "C" {
    pub static in6addr_linklocal_allv2routers: in6_addr;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ipv6_mreq {
    pub ipv6mr_multiaddr: in6_addr,
    pub ipv6mr_interface: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_ipv6_mreq() {
    const UNINIT: ::std::mem::MaybeUninit<ipv6_mreq> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ipv6_mreq>(),
        20usize,
        concat!("Size of: ", stringify!(ipv6_mreq))
    );
    assert_eq!(
        ::std::mem::align_of::<ipv6_mreq>(),
        4usize,
        concat!("Alignment of ", stringify!(ipv6_mreq))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ipv6mr_multiaddr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ipv6_mreq),
            "::",
            stringify!(ipv6mr_multiaddr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ipv6mr_interface) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ipv6_mreq),
            "::",
            stringify!(ipv6mr_interface)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct in6_pktinfo {
    pub ipi6_addr: in6_addr,
    pub ipi6_ifindex: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_in6_pktinfo() {
    const UNINIT: ::std::mem::MaybeUninit<in6_pktinfo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<in6_pktinfo>(),
        20usize,
        concat!("Size of: ", stringify!(in6_pktinfo))
    );
    assert_eq!(
        ::std::mem::align_of::<in6_pktinfo>(),
        4usize,
        concat!("Alignment of ", stringify!(in6_pktinfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ipi6_addr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in6_pktinfo),
            "::",
            stringify!(ipi6_addr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ipi6_ifindex) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(in6_pktinfo),
            "::",
            stringify!(ipi6_ifindex)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ip6_mtuinfo {
    pub ip6m_addr: sockaddr_in6,
    pub ip6m_mtu: u32,
}
#[test]
fn bindgen_test_layout_ip6_mtuinfo() {
    const UNINIT: ::std::mem::MaybeUninit<ip6_mtuinfo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ip6_mtuinfo>(),
        32usize,
        concat!("Size of: ", stringify!(ip6_mtuinfo))
    );
    assert_eq!(
        ::std::mem::align_of::<ip6_mtuinfo>(),
        4usize,
        concat!("Alignment of ", stringify!(ip6_mtuinfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ip6m_addr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ip6_mtuinfo),
            "::",
            stringify!(ip6m_addr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ip6m_mtu) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(ip6_mtuinfo),
            "::",
            stringify!(ip6m_mtu)
        )
    );
}
extern "C" {
    pub fn inet6_option_space(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inet6_option_init(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut *mut cmsghdr,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inet6_option_append(
        arg1: *mut cmsghdr,
        arg2: *const __uint8_t,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inet6_option_alloc(
        arg1: *mut cmsghdr,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
    ) -> *mut __uint8_t;
}
extern "C" {
    pub fn inet6_option_next(
        arg1: *const cmsghdr,
        arg2: *mut *mut __uint8_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inet6_option_find(
        arg1: *const cmsghdr,
        arg2: *mut *mut __uint8_t,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inet6_rthdr_space(arg1: ::std::os::raw::c_int, arg2: ::std::os::raw::c_int) -> usize;
}
extern "C" {
    pub fn inet6_rthdr_init(
        arg1: *mut ::std::os::raw::c_void,
        arg2: ::std::os::raw::c_int,
    ) -> *mut cmsghdr;
}
extern "C" {
    pub fn inet6_rthdr_add(
        arg1: *mut cmsghdr,
        arg2: *const in6_addr,
        arg3: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inet6_rthdr_lasthop(
        arg1: *mut cmsghdr,
        arg2: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inet6_rthdr_segments(arg1: *const cmsghdr) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inet6_rthdr_getaddr(arg1: *mut cmsghdr, arg2: ::std::os::raw::c_int) -> *mut in6_addr;
}
extern "C" {
    pub fn inet6_rthdr_getflags(
        arg1: *const cmsghdr,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inet6_opt_init(
        arg1: *mut ::std::os::raw::c_void,
        arg2: socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inet6_opt_append(
        arg1: *mut ::std::os::raw::c_void,
        arg2: socklen_t,
        arg3: ::std::os::raw::c_int,
        arg4: __uint8_t,
        arg5: socklen_t,
        arg6: __uint8_t,
        arg7: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inet6_opt_finish(
        arg1: *mut ::std::os::raw::c_void,
        arg2: socklen_t,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inet6_opt_set_val(
        arg1: *mut ::std::os::raw::c_void,
        arg2: ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_void,
        arg4: socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inet6_opt_next(
        arg1: *mut ::std::os::raw::c_void,
        arg2: socklen_t,
        arg3: ::std::os::raw::c_int,
        arg4: *mut __uint8_t,
        arg5: *mut socklen_t,
        arg6: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inet6_opt_find(
        arg1: *mut ::std::os::raw::c_void,
        arg2: socklen_t,
        arg3: ::std::os::raw::c_int,
        arg4: __uint8_t,
        arg5: *mut socklen_t,
        arg6: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inet6_opt_get_val(
        arg1: *mut ::std::os::raw::c_void,
        arg2: ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_void,
        arg4: socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inet6_rth_space(arg1: ::std::os::raw::c_int, arg2: ::std::os::raw::c_int) -> socklen_t;
}
extern "C" {
    pub fn inet6_rth_init(
        arg1: *mut ::std::os::raw::c_void,
        arg2: socklen_t,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn inet6_rth_add(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const in6_addr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inet6_rth_reverse(
        arg1: *const ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inet6_rth_segments(arg1: *const ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inet6_rth_getaddr(
        arg1: *const ::std::os::raw::c_void,
        arg2: ::std::os::raw::c_int,
    ) -> *mut in6_addr;
}
extern "C" {
    pub fn bindresvport(
        arg1: ::std::os::raw::c_int,
        arg2: *mut sockaddr_in,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bindresvport_sa(
        arg1: ::std::os::raw::c_int,
        arg2: *mut sockaddr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static mut h_errno: ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hostent {
    pub h_name: *mut ::std::os::raw::c_char,
    pub h_aliases: *mut *mut ::std::os::raw::c_char,
    pub h_addrtype: ::std::os::raw::c_int,
    pub h_length: ::std::os::raw::c_int,
    pub h_addr_list: *mut *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_hostent() {
    const UNINIT: ::std::mem::MaybeUninit<hostent> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hostent>(),
        32usize,
        concat!("Size of: ", stringify!(hostent))
    );
    assert_eq!(
        ::std::mem::align_of::<hostent>(),
        8usize,
        concat!("Alignment of ", stringify!(hostent))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).h_name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hostent),
            "::",
            stringify!(h_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).h_aliases) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hostent),
            "::",
            stringify!(h_aliases)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).h_addrtype) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(hostent),
            "::",
            stringify!(h_addrtype)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).h_length) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(hostent),
            "::",
            stringify!(h_length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).h_addr_list) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(hostent),
            "::",
            stringify!(h_addr_list)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct netent {
    pub n_name: *mut ::std::os::raw::c_char,
    pub n_aliases: *mut *mut ::std::os::raw::c_char,
    pub n_addrtype: ::std::os::raw::c_int,
    pub n_net: u32,
}
#[test]
fn bindgen_test_layout_netent() {
    const UNINIT: ::std::mem::MaybeUninit<netent> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<netent>(),
        24usize,
        concat!("Size of: ", stringify!(netent))
    );
    assert_eq!(
        ::std::mem::align_of::<netent>(),
        8usize,
        concat!("Alignment of ", stringify!(netent))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).n_name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(netent),
            "::",
            stringify!(n_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).n_aliases) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(netent),
            "::",
            stringify!(n_aliases)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).n_addrtype) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(netent),
            "::",
            stringify!(n_addrtype)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).n_net) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(netent),
            "::",
            stringify!(n_net)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct servent {
    pub s_name: *mut ::std::os::raw::c_char,
    pub s_aliases: *mut *mut ::std::os::raw::c_char,
    pub s_port: ::std::os::raw::c_int,
    pub s_proto: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_servent() {
    const UNINIT: ::std::mem::MaybeUninit<servent> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<servent>(),
        32usize,
        concat!("Size of: ", stringify!(servent))
    );
    assert_eq!(
        ::std::mem::align_of::<servent>(),
        8usize,
        concat!("Alignment of ", stringify!(servent))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).s_name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(servent),
            "::",
            stringify!(s_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).s_aliases) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(servent),
            "::",
            stringify!(s_aliases)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).s_port) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(servent),
            "::",
            stringify!(s_port)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).s_proto) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(servent),
            "::",
            stringify!(s_proto)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct protoent {
    pub p_name: *mut ::std::os::raw::c_char,
    pub p_aliases: *mut *mut ::std::os::raw::c_char,
    pub p_proto: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_protoent() {
    const UNINIT: ::std::mem::MaybeUninit<protoent> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<protoent>(),
        24usize,
        concat!("Size of: ", stringify!(protoent))
    );
    assert_eq!(
        ::std::mem::align_of::<protoent>(),
        8usize,
        concat!("Alignment of ", stringify!(protoent))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).p_name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(protoent),
            "::",
            stringify!(p_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).p_aliases) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(protoent),
            "::",
            stringify!(p_aliases)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).p_proto) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(protoent),
            "::",
            stringify!(p_proto)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct addrinfo {
    pub ai_flags: ::std::os::raw::c_int,
    pub ai_family: ::std::os::raw::c_int,
    pub ai_socktype: ::std::os::raw::c_int,
    pub ai_protocol: ::std::os::raw::c_int,
    pub ai_addrlen: socklen_t,
    pub ai_canonname: *mut ::std::os::raw::c_char,
    pub ai_addr: *mut sockaddr,
    pub ai_next: *mut addrinfo,
}
#[test]
fn bindgen_test_layout_addrinfo() {
    const UNINIT: ::std::mem::MaybeUninit<addrinfo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<addrinfo>(),
        48usize,
        concat!("Size of: ", stringify!(addrinfo))
    );
    assert_eq!(
        ::std::mem::align_of::<addrinfo>(),
        8usize,
        concat!("Alignment of ", stringify!(addrinfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ai_flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(addrinfo),
            "::",
            stringify!(ai_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ai_family) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(addrinfo),
            "::",
            stringify!(ai_family)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ai_socktype) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(addrinfo),
            "::",
            stringify!(ai_socktype)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ai_protocol) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(addrinfo),
            "::",
            stringify!(ai_protocol)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ai_addrlen) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(addrinfo),
            "::",
            stringify!(ai_addrlen)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ai_canonname) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(addrinfo),
            "::",
            stringify!(ai_canonname)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ai_addr) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(addrinfo),
            "::",
            stringify!(ai_addr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ai_next) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(addrinfo),
            "::",
            stringify!(ai_next)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rpcent {
    pub r_name: *mut ::std::os::raw::c_char,
    pub r_aliases: *mut *mut ::std::os::raw::c_char,
    pub r_number: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_rpcent() {
    const UNINIT: ::std::mem::MaybeUninit<rpcent> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rpcent>(),
        24usize,
        concat!("Size of: ", stringify!(rpcent))
    );
    assert_eq!(
        ::std::mem::align_of::<rpcent>(),
        8usize,
        concat!("Alignment of ", stringify!(rpcent))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).r_name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rpcent),
            "::",
            stringify!(r_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).r_aliases) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rpcent),
            "::",
            stringify!(r_aliases)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).r_number) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rpcent),
            "::",
            stringify!(r_number)
        )
    );
}
extern "C" {
    pub fn endhostent();
}
extern "C" {
    pub fn endnetent();
}
extern "C" {
    pub fn endprotoent();
}
extern "C" {
    pub fn endservent();
}
extern "C" {
    pub fn freeaddrinfo(arg1: *mut addrinfo);
}
extern "C" {
    pub fn gai_strerror(arg1: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn getaddrinfo(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *const addrinfo,
        arg4: *mut *mut addrinfo,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gethostbyaddr(
        arg1: *const ::std::os::raw::c_void,
        arg2: socklen_t,
        arg3: ::std::os::raw::c_int,
    ) -> *mut hostent;
}
extern "C" {
    pub fn gethostbyname(arg1: *const ::std::os::raw::c_char) -> *mut hostent;
}
extern "C" {
    pub fn gethostent() -> *mut hostent;
}
extern "C" {
    pub fn getnameinfo(
        arg1: *const sockaddr,
        arg2: socklen_t,
        arg3: *mut ::std::os::raw::c_char,
        arg4: socklen_t,
        arg5: *mut ::std::os::raw::c_char,
        arg6: socklen_t,
        arg7: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getnetbyaddr(arg1: u32, arg2: ::std::os::raw::c_int) -> *mut netent;
}
extern "C" {
    pub fn getnetbyname(arg1: *const ::std::os::raw::c_char) -> *mut netent;
}
extern "C" {
    pub fn getnetent() -> *mut netent;
}
extern "C" {
    pub fn getprotobyname(arg1: *const ::std::os::raw::c_char) -> *mut protoent;
}
extern "C" {
    pub fn getprotobynumber(arg1: ::std::os::raw::c_int) -> *mut protoent;
}
extern "C" {
    pub fn getprotoent() -> *mut protoent;
}
extern "C" {
    pub fn getservbyname(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut servent;
}
extern "C" {
    pub fn getservbyport(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut servent;
}
extern "C" {
    pub fn getservent() -> *mut servent;
}
extern "C" {
    pub fn sethostent(arg1: ::std::os::raw::c_int);
}
extern "C" {
    pub fn setnetent(arg1: ::std::os::raw::c_int);
}
extern "C" {
    pub fn setprotoent(arg1: ::std::os::raw::c_int);
}
extern "C" {
    pub fn setservent(arg1: ::std::os::raw::c_int);
}
extern "C" {
    pub fn freehostent(arg1: *mut hostent);
}
extern "C" {
    pub fn gethostbyname2(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> *mut hostent;
}
extern "C" {
    pub fn getipnodebyaddr(
        arg1: *const ::std::os::raw::c_void,
        arg2: usize,
        arg3: ::std::os::raw::c_int,
        arg4: *mut ::std::os::raw::c_int,
    ) -> *mut hostent;
}
extern "C" {
    pub fn getipnodebyname(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
        arg4: *mut ::std::os::raw::c_int,
    ) -> *mut hostent;
}
extern "C" {
    pub fn getrpcbyname(name: *const ::std::os::raw::c_char) -> *mut rpcent;
}
extern "C" {
    pub fn getrpcbynumber(number: ::std::os::raw::c_int) -> *mut rpcent;
}
extern "C" {
    pub fn getrpcent() -> *mut rpcent;
}
extern "C" {
    pub fn setrpcent(stayopen: ::std::os::raw::c_int);
}
extern "C" {
    pub fn endrpcent();
}
extern "C" {
    pub fn herror(arg1: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn hstrerror(arg1: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn innetgr(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *const ::std::os::raw::c_char,
        arg4: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getnetgrent(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
        arg3: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn endnetgrent();
}
extern "C" {
    pub fn setnetgrent(arg1: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn __error() -> *mut ::std::os::raw::c_int;
}
#[doc = " Structure to hold information about a monotonic timer\n\n Use this with evutil_configure_monotonic_time() and\n evutil_gettime_monotonic().\n\n This is an opaque structure; you can allocate one using\n evutil_monotonic_timer_new().\n\n @see evutil_monotonic_timer_new(), evutil_monotonic_timer_free(),\n evutil_configure_monotonic_time(), evutil_gettime_monotonic()"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct evutil_monotonic_timer {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Format a date string using RFC 1123 format (used in HTTP).\n If `tm` is NULL, current system's time will be used.\n The number of characters written will be returned.\n One should check if the return value is smaller than `datelen` to check if\n the result is truncated or not."]
    pub fn evutil_date_rfc1123(
        date: *mut ::std::os::raw::c_char,
        datelen: usize,
        tm: *const tm,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Allocate a new struct evutil_monotonic_timer for use with the\n evutil_configure_monotonic_time() and evutil_gettime_monotonic()\n functions.  You must configure the timer with\n evutil_configure_monotonic_time() before using it."]
    pub fn evutil_monotonic_timer_new() -> *mut evutil_monotonic_timer;
}
extern "C" {
    #[doc = " Free a struct evutil_monotonic_timer that was allocated using\n evutil_monotonic_timer_new()."]
    pub fn evutil_monotonic_timer_free(timer: *mut evutil_monotonic_timer);
}
extern "C" {
    #[doc = " Set up a struct evutil_monotonic_timer; flags can include\n EV_MONOT_PRECISE and EV_MONOT_FALLBACK."]
    pub fn evutil_configure_monotonic_time(
        timer: *mut evutil_monotonic_timer,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Query the current monotonic time from a struct evutil_monotonic_timer\n previously configured with evutil_configure_monotonic_time().  Monotonic\n time is guaranteed never to run in reverse, but is not necessarily epoch-\n based, or relative to any other definite point.  Use it to make reliable\n measurements of elapsed time between events even when the system time\n may be changed.\n\n It is not safe to use this funtion on the same timer from multiple\n threads."]
    pub fn evutil_gettime_monotonic(
        timer: *mut evutil_monotonic_timer,
        tp: *mut timeval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Create two new sockets that are connected to each other.\n\nOn Unix, this simply calls socketpair().  On Windows, it uses the\nloopback network interface on 127.0.0.1, and only\nAF_INET,SOCK_STREAM are supported.\n\n(This may fail on some Windows hosts where firewall software has cleverly\ndecided to keep 127.0.0.1 from talking to itself.)\n\nParameters and return values are as for socketpair()"]
    pub fn evutil_socketpair(
        d: ::std::os::raw::c_int,
        type_: ::std::os::raw::c_int,
        protocol: ::std::os::raw::c_int,
        sv: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Do platform-specific operations as needed to make a socket nonblocking.\n\n@param sock The socket to make nonblocking\n@return 0 on success, -1 on failure"]
    pub fn evutil_make_socket_nonblocking(sock: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Do platform-specific operations to make a listener socket reusable.\n\nSpecifically, we want to make sure that another program will be able\nto bind this address right after we've closed the listener.\n\nThis differs from Windows's interpretation of \"reusable\", which\nallows multiple listeners to bind the same address at the same time.\n\n@param sock The socket to make reusable\n@return 0 on success, -1 on failure"]
    pub fn evutil_make_listen_socket_reuseable(
        sock: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Do platform-specific operations to make a listener port reusable.\n\nSpecifically, we want to make sure that multiple programs which also\nset the same socket option will be able to bind, listen at the same time.\n\nThis is a feature available only to Linux 3.9+\n\n@param sock The socket to make reusable\n@return 0 on success, -1 on failure"]
    pub fn evutil_make_listen_socket_reuseable_port(
        sock: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set ipv6 only bind socket option to make listener work only in ipv6 sockets.\n\nAccording to RFC3493 and most Linux distributions, default value for the\nsockets is to work in IPv4-mapped mode. In IPv4-mapped mode, it is not possible\nto bind same port from different IPv4 and IPv6 handlers.\n\n@param sock The socket to make in ipv6only working mode\n@return 0 on success, -1 on failure"]
    pub fn evutil_make_listen_socket_ipv6only(sock: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Do platform-specific operations as needed to close a socket upon a\nsuccessful execution of one of the exec*() functions.\n\n@param sock The socket to be closed\n@return 0 on success, -1 on failure"]
    pub fn evutil_make_socket_closeonexec(sock: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Do the platform-specific call needed to close a socket returned from\nsocket() or accept().\n\n@param sock The socket to be closed\n@return 0 on success (whether the operation is supported or not),\n-1 on failure"]
    pub fn evutil_closesocket(sock: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Do platform-specific operations, if possible, to make a tcp listener\n  socket defer accept()s until there is data to read.\n\n  Not all platforms support this.  You don't want to do this for every\n  listener socket: only the ones that implement a protocol where the\n  client transmits before the server needs to respond.\n\n  @param sock The listening socket to to make deferred\n  @return 0 on success (whether the operation is supported or not),\n       -1 on failure"]
    pub fn evutil_make_tcp_listen_socket_deferred(
        sock: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Parse a 64-bit value from a string.  Arguments are as for strtol."]
    pub fn evutil_strtoll(
        s: *const ::std::os::raw::c_char,
        endptr: *mut *mut ::std::os::raw::c_char,
        base: ::std::os::raw::c_int,
    ) -> i64;
}
extern "C" {
    #[doc = " Replacement for snprintf to get consistent behavior on platforms for\nwhich the return value of snprintf does not conform to C99."]
    pub fn evutil_snprintf(
        buf: *mut ::std::os::raw::c_char,
        buflen: usize,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Replacement for vsnprintf to get consistent behavior on platforms for\nwhich the return value of snprintf does not conform to C99."]
    pub fn evutil_vsnprintf(
        buf: *mut ::std::os::raw::c_char,
        buflen: usize,
        format: *const ::std::os::raw::c_char,
        ap: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Replacement for inet_ntop for platforms which lack it."]
    pub fn evutil_inet_ntop(
        af: ::std::os::raw::c_int,
        src: *const ::std::os::raw::c_void,
        dst: *mut ::std::os::raw::c_char,
        len: usize,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Variation of inet_pton that also parses IPv6 scopes. Public for\nunit tests. No reason to call this directly."]
    pub fn evutil_inet_pton_scope(
        af: ::std::os::raw::c_int,
        src: *const ::std::os::raw::c_char,
        dst: *mut ::std::os::raw::c_void,
        indexp: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Replacement for inet_pton for platforms which lack it."]
    pub fn evutil_inet_pton(
        af: ::std::os::raw::c_int,
        src: *const ::std::os::raw::c_char,
        dst: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Parse an IPv4 or IPv6 address, with optional port, from a string.\n\nRecognized formats are:\n- [IPv6Address]:port\n- [IPv6Address]\n- IPv6Address\n- IPv4Address:port\n- IPv4Address\n\nIf no port is specified, the port in the output is set to 0.\n\n@param str The string to parse.\n@param out A struct sockaddr to hold the result.  This should probably be\na struct sockaddr_storage.\n@param outlen A pointer to the number of bytes that that 'out' can safely\nhold.  Set to the number of bytes used in 'out' on success.\n@return -1 if the address is not well-formed, if the port is out of range,\nor if out is not large enough to hold the result.  Otherwise returns\n0 on success."]
    pub fn evutil_parse_sockaddr_port(
        str_: *const ::std::os::raw::c_char,
        out: *mut sockaddr,
        outlen: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Compare two sockaddrs; return 0 if they are equal, or less than 0 if sa1\n preceeds sa2, or greater than 0 if sa1 follows sa2.  If include_port is\n true, consider the port as well as the address.  Only implemented for\n AF_INET and AF_INET6 addresses. The ordering is not guaranteed to remain\n the same between Libevent versions."]
    pub fn evutil_sockaddr_cmp(
        sa1: *const sockaddr,
        sa2: *const sockaddr,
        include_port: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " As strcasecmp, but always compares the characters in locale-independent\nASCII.  That's useful if you're handling data in ASCII-based protocols."]
    pub fn evutil_ascii_strcasecmp(
        str1: *const ::std::os::raw::c_char,
        str2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " As strncasecmp, but always compares the characters in locale-independent\nASCII.  That's useful if you're handling data in ASCII-based protocols."]
    pub fn evutil_ascii_strncasecmp(
        str1: *const ::std::os::raw::c_char,
        str2: *const ::std::os::raw::c_char,
        n: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " This function clones getaddrinfo for systems that don't have it.  For full\n details, see RFC 3493, section 6.1.\n\n Limitations:\n - When the system has no getaddrinfo, we fall back to gethostbyname_r or\n   gethostbyname, with their attendant issues.\n - The AI_V4MAPPED and AI_ALL flags are not currently implemented.\n\n For a nonblocking variant, see evdns_getaddrinfo."]
    pub fn evutil_getaddrinfo(
        nodename: *const ::std::os::raw::c_char,
        servname: *const ::std::os::raw::c_char,
        hints_in: *const addrinfo,
        res: *mut *mut addrinfo,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Release storage allocated by evutil_getaddrinfo or evdns_getaddrinfo."]
    pub fn evutil_freeaddrinfo(ai: *mut addrinfo);
}
extern "C" {
    pub fn evutil_gai_strerror(err: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Generate n bytes of secure pseudorandom data, and store them in buf.\n\n Current versions of Libevent use an ARC4-based random number generator,\n seeded using the platform's entropy source (/dev/urandom on Unix-like\n systems; CryptGenRandom on Windows).  This is not actually as secure as it\n should be: ARC4 is a pretty lousy cipher, and the current implementation\n provides only rudimentary prediction- and backtracking-resistance.  Don't\n use this for serious cryptographic applications."]
    pub fn evutil_secure_rng_get_bytes(buf: *mut ::std::os::raw::c_void, n: usize);
}
extern "C" {
    #[doc = " Seed the secure random number generator if needed, and return 0 on\n success or -1 on failure.\n\n It is okay to call this function more than once; it will still return\n 0 if the RNG has been successfully seeded and -1 if it can't be\n seeded.\n\n Ordinarily you don't need to call this function from your own code;\n Libevent will seed the RNG itself the first time it needs good random\n numbers.  You only need to call it if (a) you want to double-check\n that one of the seeding methods did succeed, or (b) you plan to drop\n the capability to seed (by chrooting, or dropping capabilities, or\n whatever), and you want to make sure that seeding happens before your\n program loses the ability to do it."]
    pub fn evutil_secure_rng_init() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set a filename to use in place of /dev/urandom for seeding the secure\n PRNG. Return 0 on success, -1 on failure.\n\n Call this function BEFORE calling any other initialization or RNG\n functions.\n\n (This string will _NOT_ be copied internally. Do not free it while any\n user of the secure RNG might be running. Don't pass anything other than a\n real /dev/...random device file here, or you might lose security.)\n\n This API is unstable, and might change in a future libevent version."]
    pub fn evutil_secure_rng_set_urandom_device_file(
        fname: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Seed the random number generator with extra random bytes.\n\nYou should almost never need to call this function; it should be\nsufficient to invoke evutil_secure_rng_init(), or let Libevent take\ncare of calling evutil_secure_rng_init() on its own.\n\nIf you call this function as a _replacement_ for the regular\nentropy sources, then you need to be sure that your input\ncontains a fairly large amount of strong entropy.  Doing so is\nnotoriously hard: most people who try get it wrong.  Watch out!\n\n@param dat a buffer full of a strong source of random numbers\n@param datlen the number of bytes to read from datlen"]
    pub fn evutil_secure_rng_add_bytes(dat: *const ::std::os::raw::c_char, datlen: usize);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct evkeyval {
    pub next: evkeyval__bindgen_ty_1,
    pub key: *mut ::std::os::raw::c_char,
    pub value: *mut ::std::os::raw::c_char,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct evkeyval__bindgen_ty_1 {
    pub tqe_next: *mut evkeyval,
    pub tqe_prev: *mut *mut evkeyval,
}
#[test]
fn bindgen_test_layout_evkeyval__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<evkeyval__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<evkeyval__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(evkeyval__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<evkeyval__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(evkeyval__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tqe_next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(evkeyval__bindgen_ty_1),
            "::",
            stringify!(tqe_next)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tqe_prev) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(evkeyval__bindgen_ty_1),
            "::",
            stringify!(tqe_prev)
        )
    );
}
#[test]
fn bindgen_test_layout_evkeyval() {
    const UNINIT: ::std::mem::MaybeUninit<evkeyval> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<evkeyval>(),
        32usize,
        concat!("Size of: ", stringify!(evkeyval))
    );
    assert_eq!(
        ::std::mem::align_of::<evkeyval>(),
        8usize,
        concat!("Alignment of ", stringify!(evkeyval))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(evkeyval),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).key) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(evkeyval),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(evkeyval),
            "::",
            stringify!(value)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct evkeyvalq {
    pub tqh_first: *mut evkeyval,
    pub tqh_last: *mut *mut evkeyval,
}
#[test]
fn bindgen_test_layout_evkeyvalq() {
    const UNINIT: ::std::mem::MaybeUninit<evkeyvalq> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<evkeyvalq>(),
        16usize,
        concat!("Size of: ", stringify!(evkeyvalq))
    );
    assert_eq!(
        ::std::mem::align_of::<evkeyvalq>(),
        8usize,
        concat!("Alignment of ", stringify!(evkeyvalq))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tqh_first) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(evkeyvalq),
            "::",
            stringify!(tqh_first)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tqh_last) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(evkeyvalq),
            "::",
            stringify!(tqh_last)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct event_callback {
    pub evcb_active_next: event_callback__bindgen_ty_1,
    pub evcb_flags: ::std::os::raw::c_short,
    pub evcb_pri: u8,
    pub evcb_closure: u8,
    pub evcb_cb_union: event_callback__bindgen_ty_2,
    pub evcb_arg: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct event_callback__bindgen_ty_1 {
    pub tqe_next: *mut event_callback,
    pub tqe_prev: *mut *mut event_callback,
}
#[test]
fn bindgen_test_layout_event_callback__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<event_callback__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<event_callback__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(event_callback__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<event_callback__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(event_callback__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tqe_next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(event_callback__bindgen_ty_1),
            "::",
            stringify!(tqe_next)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tqe_prev) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(event_callback__bindgen_ty_1),
            "::",
            stringify!(tqe_prev)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union event_callback__bindgen_ty_2 {
    pub evcb_callback: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: ::std::os::raw::c_short,
            arg3: *mut ::std::os::raw::c_void,
        ),
    >,
    pub evcb_selfcb: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut event_callback, arg2: *mut ::std::os::raw::c_void),
    >,
    pub evcb_evfinalize: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut event, arg2: *mut ::std::os::raw::c_void),
    >,
    pub evcb_cbfinalize: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut event_callback, arg2: *mut ::std::os::raw::c_void),
    >,
}
#[test]
fn bindgen_test_layout_event_callback__bindgen_ty_2() {
    const UNINIT: ::std::mem::MaybeUninit<event_callback__bindgen_ty_2> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<event_callback__bindgen_ty_2>(),
        8usize,
        concat!("Size of: ", stringify!(event_callback__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<event_callback__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(event_callback__bindgen_ty_2))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).evcb_callback) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(event_callback__bindgen_ty_2),
            "::",
            stringify!(evcb_callback)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).evcb_selfcb) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(event_callback__bindgen_ty_2),
            "::",
            stringify!(evcb_selfcb)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).evcb_evfinalize) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(event_callback__bindgen_ty_2),
            "::",
            stringify!(evcb_evfinalize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).evcb_cbfinalize) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(event_callback__bindgen_ty_2),
            "::",
            stringify!(evcb_cbfinalize)
        )
    );
}
#[test]
fn bindgen_test_layout_event_callback() {
    const UNINIT: ::std::mem::MaybeUninit<event_callback> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<event_callback>(),
        40usize,
        concat!("Size of: ", stringify!(event_callback))
    );
    assert_eq!(
        ::std::mem::align_of::<event_callback>(),
        8usize,
        concat!("Alignment of ", stringify!(event_callback))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).evcb_active_next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(event_callback),
            "::",
            stringify!(evcb_active_next)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).evcb_flags) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(event_callback),
            "::",
            stringify!(evcb_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).evcb_pri) as usize - ptr as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(event_callback),
            "::",
            stringify!(evcb_pri)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).evcb_closure) as usize - ptr as usize },
        19usize,
        concat!(
            "Offset of field: ",
            stringify!(event_callback),
            "::",
            stringify!(evcb_closure)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).evcb_cb_union) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(event_callback),
            "::",
            stringify!(evcb_cb_union)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).evcb_arg) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(event_callback),
            "::",
            stringify!(evcb_arg)
        )
    );
}
#[doc = " Structure to hold information and state for a Libevent dispatch loop.\n\n The event_base lies at the center of Libevent; every application will\n have one.  It keeps track of all pending and active events, and\n notifies your application of the active ones.\n\n This is an opaque structure; you can allocate one using\n event_base_new() or event_base_new_with_config().\n\n @see event_base_new(), event_base_free(), event_base_loop(),\n    event_base_new_with_config()"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct event_base {
    _unused: [u8; 0],
}
#[doc = " @struct event\n\n Structure to represent a single event.\n\n An event can have some underlying condition it represents: a socket\n becoming readable or writeable (or both), or a signal becoming raised.\n (An event that represents no underlying condition is still useful: you\n can use one to implement a timer, or to communicate between threads.)\n\n Generally, you can create events with event_new(), then make them\n pending with event_add().  As your event_base runs, it will run the\n callbacks of an events whose conditions are triggered.  When you no\n longer want the event, free it with event_free().\n\n In more depth:\n\n An event may be \"pending\" (one whose condition we are watching),\n \"active\" (one whose condition has triggered and whose callback is about\n to run), neither, or both.  Events come into existence via\n event_assign() or event_new(), and are then neither active nor pending.\n\n To make an event pending, pass it to event_add().  When doing so, you\n can also set a timeout for the event.\n\n Events become active during an event_base_loop() call when either their\n condition has triggered, or when their timeout has elapsed.  You can\n also activate an event manually using event_active().  The even_base\n loop will run the callbacks of active events; after it has done so, it\n marks them as no longer active.\n\n You can make an event non-pending by passing it to event_del().  This\n also makes the event non-active.\n\n Events can be \"persistent\" or \"non-persistent\".  A non-persistent event\n becomes non-pending as soon as it is triggered: thus, it only runs at\n most once per call to event_add().  A persistent event remains pending\n even when it becomes active: you'll need to event_del() it manually in\n order to make it non-pending.  When a persistent event with a timeout\n becomes active, its timeout is reset: this means you can use persistent\n events to implement periodic timeouts.\n\n This should be treated as an opaque structure; you should never read or\n write any of its fields directly.  For backward compatibility with old\n code, it is defined in the event2/event_struct.h header; including this\n header may make your code incompatible with other versions of Libevent.\n\n @see event_new(), event_free(), event_assign(), event_get_assignment(),\n    event_add(), event_del(), event_active(), event_pending(),\n    event_get_fd(), event_get_base(), event_get_events(),\n    event_get_callback(), event_get_callback_arg(),\n    event_priority_set()"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct event {
    pub ev_evcallback: event_callback,
    pub ev_timeout_pos: event__bindgen_ty_1,
    pub ev_fd: ::std::os::raw::c_int,
    pub ev_base: *mut event_base,
    pub ev_: event__bindgen_ty_2,
    pub ev_events: ::std::os::raw::c_short,
    pub ev_res: ::std::os::raw::c_short,
    pub ev_timeout: timeval,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union event__bindgen_ty_1 {
    pub ev_next_with_common_timeout: event__bindgen_ty_1__bindgen_ty_1,
    pub min_heap_idx: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct event__bindgen_ty_1__bindgen_ty_1 {
    pub tqe_next: *mut event,
    pub tqe_prev: *mut *mut event,
}
#[test]
fn bindgen_test_layout_event__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<event__bindgen_ty_1__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<event__bindgen_ty_1__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(event__bindgen_ty_1__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<event__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(event__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tqe_next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(event__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(tqe_next)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tqe_prev) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(event__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(tqe_prev)
        )
    );
}
#[test]
fn bindgen_test_layout_event__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<event__bindgen_ty_1> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<event__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(event__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<event__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(event__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ev_next_with_common_timeout) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(event__bindgen_ty_1),
            "::",
            stringify!(ev_next_with_common_timeout)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).min_heap_idx) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(event__bindgen_ty_1),
            "::",
            stringify!(min_heap_idx)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union event__bindgen_ty_2 {
    pub ev_io: event__bindgen_ty_2__bindgen_ty_1,
    pub ev_signal: event__bindgen_ty_2__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct event__bindgen_ty_2__bindgen_ty_1 {
    pub ev_io_next: event__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1,
    pub ev_timeout: timeval,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct event__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1 {
    pub le_next: *mut event,
    pub le_prev: *mut *mut event,
}
#[test]
fn bindgen_test_layout_event__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<event__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<event__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(event__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<event__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(event__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).le_next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(event__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(le_next)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).le_prev) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(event__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(le_prev)
        )
    );
}
#[test]
fn bindgen_test_layout_event__bindgen_ty_2__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<event__bindgen_ty_2__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<event__bindgen_ty_2__bindgen_ty_1>(),
        32usize,
        concat!("Size of: ", stringify!(event__bindgen_ty_2__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<event__bindgen_ty_2__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(event__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ev_io_next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(event__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(ev_io_next)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ev_timeout) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(event__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(ev_timeout)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct event__bindgen_ty_2__bindgen_ty_2 {
    pub ev_signal_next: event__bindgen_ty_2__bindgen_ty_2__bindgen_ty_1,
    pub ev_ncalls: ::std::os::raw::c_short,
    pub ev_pncalls: *mut ::std::os::raw::c_short,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct event__bindgen_ty_2__bindgen_ty_2__bindgen_ty_1 {
    pub le_next: *mut event,
    pub le_prev: *mut *mut event,
}
#[test]
fn bindgen_test_layout_event__bindgen_ty_2__bindgen_ty_2__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<event__bindgen_ty_2__bindgen_ty_2__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<event__bindgen_ty_2__bindgen_ty_2__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(event__bindgen_ty_2__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<event__bindgen_ty_2__bindgen_ty_2__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(event__bindgen_ty_2__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).le_next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(event__bindgen_ty_2__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(le_next)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).le_prev) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(event__bindgen_ty_2__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(le_prev)
        )
    );
}
#[test]
fn bindgen_test_layout_event__bindgen_ty_2__bindgen_ty_2() {
    const UNINIT: ::std::mem::MaybeUninit<event__bindgen_ty_2__bindgen_ty_2> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<event__bindgen_ty_2__bindgen_ty_2>(),
        32usize,
        concat!("Size of: ", stringify!(event__bindgen_ty_2__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<event__bindgen_ty_2__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(event__bindgen_ty_2__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ev_signal_next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(event__bindgen_ty_2__bindgen_ty_2),
            "::",
            stringify!(ev_signal_next)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ev_ncalls) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(event__bindgen_ty_2__bindgen_ty_2),
            "::",
            stringify!(ev_ncalls)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ev_pncalls) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(event__bindgen_ty_2__bindgen_ty_2),
            "::",
            stringify!(ev_pncalls)
        )
    );
}
#[test]
fn bindgen_test_layout_event__bindgen_ty_2() {
    const UNINIT: ::std::mem::MaybeUninit<event__bindgen_ty_2> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<event__bindgen_ty_2>(),
        32usize,
        concat!("Size of: ", stringify!(event__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<event__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(event__bindgen_ty_2))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ev_io) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(event__bindgen_ty_2),
            "::",
            stringify!(ev_io)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ev_signal) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(event__bindgen_ty_2),
            "::",
            stringify!(ev_signal)
        )
    );
}
#[test]
fn bindgen_test_layout_event() {
    const UNINIT: ::std::mem::MaybeUninit<event> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<event>(),
        128usize,
        concat!("Size of: ", stringify!(event))
    );
    assert_eq!(
        ::std::mem::align_of::<event>(),
        8usize,
        concat!("Alignment of ", stringify!(event))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ev_evcallback) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(event),
            "::",
            stringify!(ev_evcallback)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ev_timeout_pos) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(event),
            "::",
            stringify!(ev_timeout_pos)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ev_fd) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(event),
            "::",
            stringify!(ev_fd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ev_base) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(event),
            "::",
            stringify!(ev_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ev_) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(event),
            "::",
            stringify!(ev_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ev_events) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(event),
            "::",
            stringify!(ev_events)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ev_res) as usize - ptr as usize },
        106usize,
        concat!(
            "Offset of field: ",
            stringify!(event),
            "::",
            stringify!(ev_res)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ev_timeout) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(event),
            "::",
            stringify!(ev_timeout)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct event_list {
    pub tqh_first: *mut event,
    pub tqh_last: *mut *mut event,
}
#[test]
fn bindgen_test_layout_event_list() {
    const UNINIT: ::std::mem::MaybeUninit<event_list> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<event_list>(),
        16usize,
        concat!("Size of: ", stringify!(event_list))
    );
    assert_eq!(
        ::std::mem::align_of::<event_list>(),
        8usize,
        concat!("Alignment of ", stringify!(event_list))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tqh_first) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(event_list),
            "::",
            stringify!(tqh_first)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tqh_last) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(event_list),
            "::",
            stringify!(tqh_last)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct event_dlist {
    pub lh_first: *mut event,
}
#[test]
fn bindgen_test_layout_event_dlist() {
    const UNINIT: ::std::mem::MaybeUninit<event_dlist> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<event_dlist>(),
        8usize,
        concat!("Size of: ", stringify!(event_dlist))
    );
    assert_eq!(
        ::std::mem::align_of::<event_dlist>(),
        8usize,
        concat!("Alignment of ", stringify!(event_dlist))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lh_first) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(event_dlist),
            "::",
            stringify!(lh_first)
        )
    );
}
extern "C" {
    pub fn renameat(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn renamex_np(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn renameatx_np(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: *const ::std::os::raw::c_char,
        arg5: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
pub type fpos_t = __darwin_off_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sbuf {
    pub _base: *mut ::std::os::raw::c_uchar,
    pub _size: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___sbuf() {
    const UNINIT: ::std::mem::MaybeUninit<__sbuf> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__sbuf>(),
        16usize,
        concat!("Size of: ", stringify!(__sbuf))
    );
    assert_eq!(
        ::std::mem::align_of::<__sbuf>(),
        8usize,
        concat!("Alignment of ", stringify!(__sbuf))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sbuf),
            "::",
            stringify!(_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__sbuf),
            "::",
            stringify!(_size)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sFILEX {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sFILE {
    pub _p: *mut ::std::os::raw::c_uchar,
    pub _r: ::std::os::raw::c_int,
    pub _w: ::std::os::raw::c_int,
    pub _flags: ::std::os::raw::c_short,
    pub _file: ::std::os::raw::c_short,
    pub _bf: __sbuf,
    pub _lbfsize: ::std::os::raw::c_int,
    pub _cookie: *mut ::std::os::raw::c_void,
    pub _close: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
    >,
    pub _read: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::std::os::raw::c_void,
            arg2: *mut ::std::os::raw::c_char,
            arg3: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub _seek: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::std::os::raw::c_void,
            arg2: fpos_t,
            arg3: ::std::os::raw::c_int,
        ) -> fpos_t,
    >,
    pub _write: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::std::os::raw::c_void,
            arg2: *const ::std::os::raw::c_char,
            arg3: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub _ub: __sbuf,
    pub _extra: *mut __sFILEX,
    pub _ur: ::std::os::raw::c_int,
    pub _ubuf: [::std::os::raw::c_uchar; 3usize],
    pub _nbuf: [::std::os::raw::c_uchar; 1usize],
    pub _lb: __sbuf,
    pub _blksize: ::std::os::raw::c_int,
    pub _offset: fpos_t,
}
#[test]
fn bindgen_test_layout___sFILE() {
    const UNINIT: ::std::mem::MaybeUninit<__sFILE> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__sFILE>(),
        152usize,
        concat!("Size of: ", stringify!(__sFILE))
    );
    assert_eq!(
        ::std::mem::align_of::<__sFILE>(),
        8usize,
        concat!("Alignment of ", stringify!(__sFILE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._p) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_p)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._r) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_r)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._w) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_w)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._flags) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._file) as usize - ptr as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_file)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._bf) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_bf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._lbfsize) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_lbfsize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._cookie) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_cookie)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._close) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_close)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._read) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_read)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._seek) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_seek)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._write) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_write)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._ub) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_ub)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._extra) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_extra)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._ur) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_ur)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._ubuf) as usize - ptr as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_ubuf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._nbuf) as usize - ptr as usize },
        119usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_nbuf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._lb) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_lb)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._blksize) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_blksize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._offset) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_offset)
        )
    );
}
pub type FILE = __sFILE;
extern "C" {
    pub static mut __stdinp: *mut FILE;
}
extern "C" {
    pub static mut __stdoutp: *mut FILE;
}
extern "C" {
    pub static mut __stderrp: *mut FILE;
}
extern "C" {
    pub fn clearerr(arg1: *mut FILE);
}
extern "C" {
    pub fn fclose(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn feof(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetpos(arg1: *mut FILE, arg2: *mut fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgets(
        arg1: *mut ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: *mut FILE,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fopen(
        __filename: *const ::std::os::raw::c_char,
        __mode: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fprintf(
        arg1: *mut FILE,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputs(arg1: *const ::std::os::raw::c_char, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fread(
        __ptr: *mut ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
        __nitems: ::std::os::raw::c_ulong,
        __stream: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn freopen(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fscanf(
        arg1: *mut FILE,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fseek(
        arg1: *mut FILE,
        arg2: ::std::os::raw::c_long,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fsetpos(arg1: *mut FILE, arg2: *const fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftell(arg1: *mut FILE) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn fwrite(
        __ptr: *const ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
        __nitems: ::std::os::raw::c_ulong,
        __stream: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn getc(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gets(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn perror(arg1: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn printf(arg1: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn puts(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn remove(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rename(
        __old: *const ::std::os::raw::c_char,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rewind(arg1: *mut FILE);
}
extern "C" {
    pub fn scanf(arg1: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setbuf(arg1: *mut FILE, arg2: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn setvbuf(
        arg1: *mut FILE,
        arg2: *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sprintf(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sscanf(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn tmpnam(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ungetc(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfprintf(
        arg1: *mut FILE,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vprintf(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsprintf(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ctermid(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fdopen(arg1: ::std::os::raw::c_int, arg2: *const ::std::os::raw::c_char) -> *mut FILE;
}
extern "C" {
    pub fn fileno(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pclose(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn popen(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn __srget(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __svfscanf(
        arg1: *mut FILE,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __swbuf(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn flockfile(arg1: *mut FILE);
}
extern "C" {
    pub fn ftrylockfile(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn funlockfile(arg1: *mut FILE);
}
extern "C" {
    pub fn getc_unlocked(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar_unlocked() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc_unlocked(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar_unlocked(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getw(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putw(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tempnam(
        __dir: *const ::std::os::raw::c_char,
        __prefix: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fseeko(
        __stream: *mut FILE,
        __offset: off_t,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftello(__stream: *mut FILE) -> off_t;
}
extern "C" {
    pub fn snprintf(
        __str: *mut ::std::os::raw::c_char,
        __size: ::std::os::raw::c_ulong,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfscanf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        arg1: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vscanf(
        __format: *const ::std::os::raw::c_char,
        arg1: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsnprintf(
        __str: *mut ::std::os::raw::c_char,
        __size: ::std::os::raw::c_ulong,
        __format: *const ::std::os::raw::c_char,
        arg1: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsscanf(
        __str: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        arg1: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dprintf(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vdprintf(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getdelim(
        __linep: *mut *mut ::std::os::raw::c_char,
        __linecapp: *mut usize,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> isize;
}
extern "C" {
    pub fn getline(
        __linep: *mut *mut ::std::os::raw::c_char,
        __linecapp: *mut usize,
        __stream: *mut FILE,
    ) -> isize;
}
extern "C" {
    pub fn fmemopen(
        __buf: *mut ::std::os::raw::c_void,
        __size: usize,
        __mode: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn open_memstream(
        __bufp: *mut *mut ::std::os::raw::c_char,
        __sizep: *mut usize,
    ) -> *mut FILE;
}
extern "C" {
    pub static sys_nerr: ::std::os::raw::c_int;
}
extern "C" {
    pub static sys_errlist: [*const ::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub fn asprintf(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ctermid_r(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fgetln(arg1: *mut FILE, arg2: *mut usize) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fmtcheck(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn fpurge(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setbuffer(
        arg1: *mut FILE,
        arg2: *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn setlinebuf(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vasprintf(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn funopen(
        arg1: *const ::std::os::raw::c_void,
        arg2: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *mut ::std::os::raw::c_char,
                arg3: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int,
        >,
        arg3: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_char,
                arg3: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int,
        >,
        arg4: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: fpos_t,
                arg3: ::std::os::raw::c_int,
            ) -> fpos_t,
        >,
        arg5: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
        >,
    ) -> *mut FILE;
}
extern "C" {
    pub fn __sprintf_chk(
        arg1: *mut ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: usize,
        arg4: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __snprintf_chk(
        arg1: *mut ::std::os::raw::c_char,
        arg2: usize,
        arg3: ::std::os::raw::c_int,
        arg4: usize,
        arg5: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __vsprintf_chk(
        arg1: *mut ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: usize,
        arg4: *const ::std::os::raw::c_char,
        arg5: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __vsnprintf_chk(
        arg1: *mut ::std::os::raw::c_char,
        arg2: usize,
        arg3: ::std::os::raw::c_int,
        arg4: usize,
        arg5: *const ::std::os::raw::c_char,
        arg6: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
#[doc = " Configuration for an event_base.\n\n There are many options that can be used to alter the behavior and\n implementation of an event_base.  To avoid having to pass them all in a\n complex many-argument constructor, we provide an abstract data type\n where you set up configuration information before passing it to\n event_base_new_with_config().\n\n @see event_config_new(), event_config_free(), event_base_new_with_config(),\n   event_config_avoid_method(), event_config_require_features(),\n   event_config_set_flag(), event_config_set_num_cpus_hint()"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct event_config {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Enable some relatively expensive debugging checks in Libevent that\n would normally be turned off.  Generally, these checks cause code that\n would otherwise crash mysteriously to fail earlier with an assertion\n failure.  Note that this method MUST be called before any events or\n event_bases have been created.\n\n Debug mode can currently catch the following errors:\n    An event is re-assigned while it is added\n    Any function is called on a non-assigned event\n\n Note that debugging mode uses memory to track every event that has been\n initialized (via event_assign, event_set, or event_new) but not yet\n released (via event_free or event_debug_unassign).  If you want to use\n debug mode, and you find yourself running out of memory, you will need\n to use event_debug_unassign to explicitly stop tracking events that\n are no longer considered set-up.\n\n @see event_debug_unassign()"]
    pub fn event_enable_debug_mode();
}
extern "C" {
    #[doc = " When debugging mode is enabled, informs Libevent that an event should no\n longer be considered as assigned. When debugging mode is not enabled, does\n nothing.\n\n This function must only be called on a non-added event.\n\n @see event_enable_debug_mode()"]
    pub fn event_debug_unassign(arg1: *mut event);
}
extern "C" {
    #[doc = " Create and return a new event_base to use with the rest of Libevent.\n\n @return a new event_base on success, or NULL on failure.\n\n @see event_base_free(), event_base_new_with_config()"]
    pub fn event_base_new() -> *mut event_base;
}
extern "C" {
    #[doc = "Reinitialize the event base after a fork\n\nSome event mechanisms do not survive across fork.   The event base needs\nto be reinitialized with the event_reinit() function.\n\n@param base the event base that needs to be re-initialized\n@return 0 if successful, or -1 if some events could not be re-added.\n@see event_base_new()"]
    pub fn event_reinit(base: *mut event_base) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Event dispatching loop\n\nThis loop will run the event base until either there are no more pending or\nactive, or until something calls event_base_loopbreak() or\nevent_base_loopexit().\n\n@param base the event_base structure returned by event_base_new() or\nevent_base_new_with_config()\n@return 0 if successful, -1 if an error occurred, or 1 if we exited because\nno events were pending or active.\n@see event_base_loop()"]
    pub fn event_base_dispatch(arg1: *mut event_base) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Get the kernel event notification mechanism used by Libevent.\n\n@param eb the event_base structure returned by event_base_new()\n@return a string identifying the kernel event mechanism (kqueue, epoll, etc.)"]
    pub fn event_base_get_method(arg1: *const event_base) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "Gets all event notification mechanisms supported by Libevent.\n\nThis functions returns the event mechanism in order preferred by\nLibevent.  Note that this list will include all backends that\nLibevent has compiled-in support for, and will not necessarily check\nyour OS to see whether it has the required resources.\n\n@return an array with pointers to the names of support methods.\nThe end of the array is indicated by a NULL pointer.  If an\nerror is encountered NULL is returned."]
    pub fn event_get_supported_methods() -> *mut *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Query the current monotonic time from a the timer for a struct\n event_base."]
    pub fn event_gettime_monotonic(
        base: *mut event_base,
        tp: *mut timeval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Gets the number of events in event_base, as specified in the flags.\n\nSince event base has some internal events added to make some of its\nfunctionalities work, EVENT_BASE_COUNT_ADDED may return more than the\nnumber of events you added using event_add().\n\nIf you pass EVENT_BASE_COUNT_ACTIVE and EVENT_BASE_COUNT_ADDED together, an\nactive event will be counted twice. However, this might not be the case in\nfuture libevent versions.  The return value is an indication of the work\nload, but the user shouldn't rely on the exact value as this may change in\nthe future.\n\n@param eb the event_base structure returned by event_base_new()\n@param flags a bitwise combination of the kinds of events to aggregate\ncounts for\n@return the number of events specified in the flags"]
    pub fn event_base_get_num_events(
        arg1: *mut event_base,
        arg2: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Get the maximum number of events in a given event_base as specified in the\nflags.\n\n@param eb the event_base structure returned by event_base_new()\n@param flags a bitwise combination of the kinds of events to aggregate\ncounts for\n@param clear option used to reset the maximum count.\n@return the number of events specified in the flags"]
    pub fn event_base_get_max_events(
        arg1: *mut event_base,
        arg2: ::std::os::raw::c_uint,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Allocates a new event configuration object.\n\nThe event configuration object can be used to change the behavior of\nan event base.\n\n@return an event_config object that can be used to store configuration, or\nNULL if an error is encountered.\n@see event_base_new_with_config(), event_config_free(), event_config"]
    pub fn event_config_new() -> *mut event_config;
}
extern "C" {
    #[doc = "Deallocates all memory associated with an event configuration object\n\n@param cfg the event configuration object to be freed."]
    pub fn event_config_free(cfg: *mut event_config);
}
extern "C" {
    #[doc = "Enters an event method that should be avoided into the configuration.\n\nThis can be used to avoid event mechanisms that do not support certain\nfile descriptor types, or for debugging to avoid certain event\nmechanisms.  An application can make use of multiple event bases to\naccommodate incompatible file descriptor types.\n\n@param cfg the event configuration object\n@param method the name of the event method to avoid\n@return 0 on success, -1 on failure."]
    pub fn event_config_avoid_method(
        cfg: *mut event_config,
        method: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
#[doc = " Require an event method that allows edge-triggered events with EV_ET."]
pub const event_method_feature_EV_FEATURE_ET: event_method_feature = 1;
#[doc = " Require an event method where having one event triggered among\n many is [approximately] an O(1) operation. This excludes (for\n example) select and poll, which are approximately O(N) for N\n equal to the total number of possible events."]
pub const event_method_feature_EV_FEATURE_O1: event_method_feature = 2;
#[doc = " Require an event method that allows file descriptors as well as\n sockets."]
pub const event_method_feature_EV_FEATURE_FDS: event_method_feature = 4;
#[doc = " Require an event method that allows you to use EV_CLOSED to detect\n connection close without the necessity of reading all the pending data.\n\n Methods that do support EV_CLOSED may not be able to provide support on\n all kernel versions."]
pub const event_method_feature_EV_FEATURE_EARLY_CLOSE: event_method_feature = 8;
#[doc = "A flag used to describe which features an event_base (must) provide.\n\nBecause of OS limitations, not every Libevent backend supports every\npossible feature.  You can use this type with\nevent_config_require_features() to tell Libevent to only proceed if your\nevent_base implements a given feature, and you can receive this type from\nevent_base_get_features() to see which features are available."]
pub type event_method_feature = ::std::os::raw::c_uint;
#[doc = " Do not allocate a lock for the event base, even if we have\nlocking set up.\n\nSetting this option will make it unsafe and nonfunctional to call\nfunctions on the base concurrently from multiple threads."]
pub const event_base_config_flag_EVENT_BASE_FLAG_NOLOCK: event_base_config_flag = 1;
#[doc = " Do not check the EVENT_* environment variables when configuring\nan event_base"]
pub const event_base_config_flag_EVENT_BASE_FLAG_IGNORE_ENV: event_base_config_flag = 2;
#[doc = " Windows only: enable the IOCP dispatcher at startup\n\nIf this flag is set then bufferevent_socket_new() and\nevconn_listener_new() will use IOCP-backed implementations\ninstead of the usual select-based one on Windows."]
pub const event_base_config_flag_EVENT_BASE_FLAG_STARTUP_IOCP: event_base_config_flag = 4;
#[doc = " Instead of checking the current time every time the event loop is\nready to run timeout callbacks, check after each timeout callback."]
pub const event_base_config_flag_EVENT_BASE_FLAG_NO_CACHE_TIME: event_base_config_flag = 8;
#[doc = " If we are using the epoll backend, this flag says that it is\nsafe to use Libevent's internal change-list code to batch up\nadds and deletes in order to try to do as few syscalls as\npossible.  Setting this flag can make your code run faster, but\nit may trigger a Linux bug: it is not safe to use this flag\nif you have any fds cloned by dup() or its variants.  Doing so\nwill produce strange and hard-to-diagnose bugs.\n\nThis flag can also be activated by setting the\nEVENT_EPOLL_USE_CHANGELIST environment variable.\n\nThis flag has no effect if you wind up using a backend other than\nepoll."]
pub const event_base_config_flag_EVENT_BASE_FLAG_EPOLL_USE_CHANGELIST: event_base_config_flag = 16;
#[doc = " Ordinarily, Libevent implements its time and timeout code using\nthe fastest monotonic timer that we have.  If this flag is set,\nhowever, we use less efficient more precise timer, assuming one is\npresent."]
pub const event_base_config_flag_EVENT_BASE_FLAG_PRECISE_TIMER: event_base_config_flag = 32;
#[doc = "A flag passed to event_config_set_flag().\n\nThese flags change the behavior of an allocated event_base.\n\n@see event_config_set_flag(), event_base_new_with_config(),\nevent_method_feature"]
pub type event_base_config_flag = ::std::os::raw::c_uint;
extern "C" {
    #[doc = "Return a bitmask of the features implemented by an event base.  This\nwill be a bitwise OR of one or more of the values of\nevent_method_feature\n\n@see event_method_feature"]
    pub fn event_base_get_features(base: *const event_base) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Enters a required event method feature that the application demands.\n\nNote that not every feature or combination of features is supported\non every platform.  Code that requests features should be prepared\nto handle the case where event_base_new_with_config() returns NULL, as in:\n<pre>\nevent_config_require_features(cfg, EV_FEATURE_ET);\nbase = event_base_new_with_config(cfg);\nif (base == NULL) {\n// We can't get edge-triggered behavior here.\nevent_config_require_features(cfg, 0);\nbase = event_base_new_with_config(cfg);\n}\n</pre>\n\n@param cfg the event configuration object\n@param feature a bitfield of one or more event_method_feature values.\nReplaces values from previous calls to this function.\n@return 0 on success, -1 on failure.\n@see event_method_feature, event_base_new_with_config()"]
    pub fn event_config_require_features(
        cfg: *mut event_config,
        feature: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Sets one or more flags to configure what parts of the eventual event_base\n will be initialized, and how they'll work.\n\n @see event_base_config_flags, event_base_new_with_config()"]
    pub fn event_config_set_flag(
        cfg: *mut event_config,
        flag: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Records a hint for the number of CPUs in the system. This is used for\n tuning thread pools, etc, for optimal performance.  In Libevent 2.0,\n it is only on Windows, and only when IOCP is in use.\n\n @param cfg the event configuration object\n @param cpus the number of cpus\n @return 0 on success, -1 on failure."]
    pub fn event_config_set_num_cpus_hint(
        cfg: *mut event_config,
        cpus: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Record an interval and/or a number of callbacks after which the event base\n should check for new events.  By default, the event base will run as many\n events are as activated at the highest activated priority before checking\n for new events.  If you configure it by setting max_interval, it will check\n the time after each callback, and not allow more than max_interval to\n elapse before checking for new events.  If you configure it by setting\n max_callbacks to a value >= 0, it will run no more than max_callbacks\n callbacks before checking for new events.\n\n This option can decrease the latency of high-priority events, and\n avoid priority inversions where multiple low-priority events keep us from\n polling for high-priority events, but at the expense of slightly decreasing\n the throughput.  Use it with caution!\n\n @param cfg The event_base configuration object.\n @param max_interval An interval after which Libevent should stop running\n     callbacks and check for more events, or NULL if there should be\n     no such interval.\n @param max_callbacks A number of callbacks after which Libevent should\n     stop running callbacks and check for more events, or -1 if there\n     should be no such limit.\n @param min_priority A priority below which max_interval and max_callbacks\n     should not be enforced.  If this is set to 0, they are enforced\n     for events of every priority; if it's set to 1, they're enforced\n     for events of priority 1 and above, and so on.\n @return 0 on success, -1 on failure."]
    pub fn event_config_set_max_dispatch_interval(
        cfg: *mut event_config,
        max_interval: *const timeval,
        max_callbacks: ::std::os::raw::c_int,
        min_priority: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Initialize the event API.\n\nUse event_base_new_with_config() to initialize a new event base, taking\nthe specified configuration under consideration.  The configuration object\ncan currently be used to avoid certain event notification mechanisms.\n\n@param cfg the event configuration object\n@return an initialized event_base that can be used to registering events,\nor NULL if no event base can be created with the requested event_config.\n@see event_base_new(), event_base_free(), event_init(), event_assign()"]
    pub fn event_base_new_with_config(arg1: *const event_config) -> *mut event_base;
}
extern "C" {
    #[doc = "Deallocate all memory associated with an event_base, and free the base.\n\nNote that this function will not close any fds or free any memory passed\nto event_new as the argument to callback.\n\nIf there are any pending finalizer callbacks, this function will invoke\nthem.\n\n@param eb an event_base to be freed"]
    pub fn event_base_free(arg1: *mut event_base);
}
extern "C" {
    #[doc = "As event_base_free, but do not run finalizers."]
    pub fn event_base_free_nofinalize(arg1: *mut event_base);
}
#[doc = "A callback function used to intercept Libevent's log messages.\n\n@see event_set_log_callback"]
pub type event_log_cb = ::std::option::Option<
    unsafe extern "C" fn(severity: ::std::os::raw::c_int, msg: *const ::std::os::raw::c_char),
>;
extern "C" {
    #[doc = "Redirect Libevent's log messages.\n\n@param cb a function taking two arguments: an integer severity between\nEVENT_LOG_DEBUG and EVENT_LOG_ERR, and a string.  If cb is NULL,\nthen the default log is used.\n\nNOTE: The function you provide *must not* call any other libevent\nfunctionality.  Doing so can produce undefined behavior."]
    pub fn event_set_log_callback(cb: event_log_cb);
}
#[doc = "A function to be called if Libevent encounters a fatal internal error.\n\n@see event_set_fatal_callback"]
pub type event_fatal_cb = ::std::option::Option<unsafe extern "C" fn(err: ::std::os::raw::c_int)>;
extern "C" {
    #[doc = "Override Libevent's behavior in the event of a fatal internal error.\n\nBy default, Libevent will call exit(1) if a programming error makes it\nimpossible to continue correct operation.  This function allows you to supply\nanother callback instead.  Note that if the function is ever invoked,\nsomething is wrong with your program, or with Libevent: any subsequent calls\nto Libevent may result in undefined behavior.\n\nLibevent will (almost) always log an EVENT_LOG_ERR message before calling\nthis function; look at the last log message to see why Libevent has died."]
    pub fn event_set_fatal_callback(cb: event_fatal_cb);
}
extern "C" {
    #[doc = "Turn on debugging logs and have them sent to the default log handler.\n\nThis is a global setting; if you are going to call it, you must call this\nbefore any calls that create an event-base.  You must call it before any\nmultithreaded use of Libevent.\n\nDebug logs are verbose.\n\n@param which Controls which debug messages are turned on.  This option is\nunused for now; for forward compatibility, you must pass in the constant\n\"EVENT_DBG_ALL\" to turn debugging logs on, or \"EVENT_DBG_NONE\" to turn\ndebugging logs off."]
    pub fn event_enable_debug_logging(which: u32);
}
extern "C" {
    #[doc = "Associate a different event base with an event.\n\nThe event to be associated must not be currently active or pending.\n\n@param eb the event base\n@param ev the event\n@return 0 on success, -1 on failure."]
    pub fn event_base_set(arg1: *mut event_base, arg2: *mut event) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Wait for events to become active, and run their callbacks.\n\nThis is a more flexible version of event_base_dispatch().\n\nBy default, this loop will run the event base until either there are no more\npending or active events, or until something calls event_base_loopbreak() or\nevent_base_loopexit().  You can override this behavior with the 'flags'\nargument.\n\n@param eb the event_base structure returned by event_base_new() or\nevent_base_new_with_config()\n@param flags any combination of EVLOOP_ONCE | EVLOOP_NONBLOCK\n@return 0 if successful, -1 if an error occurred, or 1 if we exited because\nno events were pending or active.\n@see event_base_loopexit(), event_base_dispatch(), EVLOOP_ONCE,\nEVLOOP_NONBLOCK"]
    pub fn event_base_loop(
        arg1: *mut event_base,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Exit the event loop after the specified time\n\nThe next event_base_loop() iteration after the given timer expires will\ncomplete normally (handling all queued events) then exit without\nblocking for events again.\n\nSubsequent invocations of event_base_loop() will proceed normally.\n\n@param eb the event_base structure returned by event_init()\n@param tv the amount of time after which the loop should terminate,\nor NULL to exit after running all currently active events.\n@return 0 if successful, or -1 if an error occurred\n@see event_base_loopbreak()"]
    pub fn event_base_loopexit(
        arg1: *mut event_base,
        arg2: *const timeval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Abort the active event_base_loop() immediately.\n\nevent_base_loop() will abort the loop after the next event is completed;\nevent_base_loopbreak() is typically invoked from this event's callback.\nThis behavior is analogous to the \"break;\" statement.\n\nSubsequent invocations of event_base_loop() will proceed normally.\n\n@param eb the event_base structure returned by event_init()\n@return 0 if successful, or -1 if an error occurred\n@see event_base_loopexit()"]
    pub fn event_base_loopbreak(arg1: *mut event_base) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Tell the active event_base_loop() to scan for new events immediately.\n\nCalling this function makes the currently active event_base_loop()\nstart the loop over again (scanning for new events) after the current\nevent callback finishes.  If the event loop is not running, this\nfunction has no effect.\n\nevent_base_loopbreak() is typically invoked from this event's callback.\nThis behavior is analogous to the \"continue;\" statement.\n\nSubsequent invocations of event loop will proceed normally.\n\n@param eb the event_base structure returned by event_init()\n@return 0 if successful, or -1 if an error occurred\n@see event_base_loopbreak()"]
    pub fn event_base_loopcontinue(arg1: *mut event_base) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Checks if the event loop was told to exit by event_base_loopexit().\n\nThis function will return true for an event_base at every point after\nevent_loopexit() is called, until the event loop is next entered.\n\n@param eb the event_base structure returned by event_init()\n@return true if event_base_loopexit() was called on this event base,\nor 0 otherwise\n@see event_base_loopexit()\n@see event_base_got_break()"]
    pub fn event_base_got_exit(arg1: *mut event_base) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Checks if the event loop was told to abort immediately by event_base_loopbreak().\n\nThis function will return true for an event_base at every point after\nevent_base_loopbreak() is called, until the event loop is next entered.\n\n@param eb the event_base structure returned by event_init()\n@return true if event_base_loopbreak() was called on this event base,\nor 0 otherwise\n@see event_base_loopbreak()\n@see event_base_got_exit()"]
    pub fn event_base_got_break(arg1: *mut event_base) -> ::std::os::raw::c_int;
}
#[doc = "A callback function for an event.\n\nIt receives three arguments:\n\n@param fd An fd or signal\n@param events One or more EV_* flags\n@param arg A user-supplied argument.\n\n@see event_new()"]
pub type event_callback_fn = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_short,
        arg3: *mut ::std::os::raw::c_void,
    ),
>;
extern "C" {
    #[doc = "Return a value used to specify that the event itself must be used as the callback argument.\n\nThe function event_new() takes a callback argument which is passed\nto the event's callback function. To specify that the argument to be\npassed to the callback function is the event that event_new() returns,\npass in the return value of event_self_cbarg() as the callback argument\nfor event_new().\n\nFor example:\n<pre>\nstruct event *ev = event_new(base, sock, events, callback, %event_self_cbarg());\n</pre>\n\nFor consistency with event_new(), it is possible to pass the return value\nof this function as the callback argument for event_assign() &ndash; this\nachieves the same result as passing the event in directly.\n\n@return a value to be passed as the callback argument to event_new() or\nevent_assign().\n@see event_new(), event_assign()"]
    pub fn event_self_cbarg() -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = "Allocate and assign a new event structure, ready to be added.\n\nThe function event_new() returns a new event that can be used in\nfuture calls to event_add() and event_del().  The fd and events\narguments determine which conditions will trigger the event; the\ncallback and callback_arg arguments tell Libevent what to do when the\nevent becomes active.\n\nIf events contains one of EV_READ, EV_WRITE, or EV_READ|EV_WRITE, then\nfd is a file descriptor or socket that should get monitored for\nreadiness to read, readiness to write, or readiness for either operation\n(respectively).  If events contains EV_SIGNAL, then fd is a signal\nnumber to wait for.  If events contains none of those flags, then the\nevent can be triggered only by a timeout or by manual activation with\nevent_active(): In this case, fd must be -1.\n\nThe EV_PERSIST flag can also be passed in the events argument: it makes\nevent_add() persistent until event_del() is called.\n\nThe EV_ET flag is compatible with EV_READ and EV_WRITE, and supported\nonly by certain backends.  It tells Libevent to use edge-triggered\nevents.\n\nThe EV_TIMEOUT flag has no effect here.\n\nIt is okay to have multiple events all listening on the same fds; but\nthey must either all be edge-triggered, or all not be edge triggered.\n\nWhen the event becomes active, the event loop will run the provided\ncallback function, with three arguments.  The first will be the provided\nfd value.  The second will be a bitfield of the events that triggered:\nEV_READ, EV_WRITE, or EV_SIGNAL.  Here the EV_TIMEOUT flag indicates\nthat a timeout occurred, and EV_ET indicates that an edge-triggered\nevent occurred.  The third event will be the callback_arg pointer that\nyou provide.\n\n@param base the event base to which the event should be attached.\n@param fd the file descriptor or signal to be monitored, or -1.\n@param events desired events to monitor: bitfield of EV_READ, EV_WRITE,\nEV_SIGNAL, EV_PERSIST, EV_ET.\n@param callback callback function to be invoked when the event occurs\n@param callback_arg an argument to be passed to the callback function\n\n@return a newly allocated struct event that must later be freed with\nevent_free() or NULL if an error occurred.\n@see event_free(), event_add(), event_del(), event_assign()"]
    pub fn event_new(
        arg1: *mut event_base,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_short,
        arg4: event_callback_fn,
        arg5: *mut ::std::os::raw::c_void,
    ) -> *mut event;
}
extern "C" {
    #[doc = "Prepare a new, already-allocated event structure to be added.\n\nThe function event_assign() prepares the event structure ev to be used\nin future calls to event_add() and event_del().  Unlike event_new(), it\ndoesn't allocate memory itself: it requires that you have already\nallocated a struct event, probably on the heap.  Doing this will\ntypically make your code depend on the size of the event structure, and\nthereby create incompatibility with future versions of Libevent.\n\nThe easiest way to avoid this problem is just to use event_new() and\nevent_free() instead.\n\nA slightly harder way to future-proof your code is to use\nevent_get_struct_event_size() to determine the required size of an event\nat runtime.\n\nNote that it is NOT safe to call this function on an event that is\nactive or pending.  Doing so WILL corrupt internal data structures in\nLibevent, and lead to strange, hard-to-diagnose bugs.  You _can_ use\nevent_assign to change an existing event, but only if it is not active\nor pending!\n\nThe arguments for this function, and the behavior of the events that it\nmakes, are as for event_new().\n\n@param ev an event struct to be modified\n@param base the event base to which ev should be attached.\n@param fd the file descriptor to be monitored\n@param events desired events to monitor; can be EV_READ and/or EV_WRITE\n@param callback callback function to be invoked when the event occurs\n@param callback_arg an argument to be passed to the callback function\n\n@return 0 if success, or -1 on invalid arguments.\n\n@see event_new(), event_add(), event_del(), event_base_once(),\nevent_get_struct_event_size()"]
    pub fn event_assign(
        arg1: *mut event,
        arg2: *mut event_base,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_short,
        arg5: event_callback_fn,
        arg6: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Deallocate a struct event * returned by event_new().\n\nIf the event is pending or active, this function makes it non-pending\nand non-active first."]
    pub fn event_free(arg1: *mut event);
}
#[doc = " Callback type for event_finalize and event_free_finalize()."]
pub type event_finalize_callback_fn = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut event, arg2: *mut ::std::os::raw::c_void),
>;
extern "C" {
    #[doc = "@name Finalization functions\n\nThese functions are used to safely tear down an event in a multithreaded\napplication.  If you construct your events with EV_FINALIZE to avoid\ndeadlocks, you will need a way to remove an event in the certainty that\nit will definitely not be running its callback when you deallocate it\nand its callback argument.\n\nTo do this, call one of event_finalize() or event_free_finalize with\n0 for its first argument, the event to tear down as its second argument,\nand a callback function as its third argument.  The callback will be\ninvoked as part of the event loop, with the event's priority.\n\nAfter you call a finalizer function, event_add() and event_active() will\nno longer work on the event, and event_del() will produce a no-op. You\nmust not try to change the event's fields with event_assign() or\nevent_set() while the finalize callback is in progress.  Once the\ncallback has been invoked, you should treat the event structure as\ncontaining uninitialized memory.\n\nThe event_free_finalize() function frees the event after it's finalized;\nevent_finalize() does not.\n\nA finalizer callback must not make events pending or active.  It must not\nadd events, activate events, or attempt to \"resuscitate\" the event being\nfinalized in any way.\n\n@return 0 on success, -1 on failure.\n/\n/**@{"]
    pub fn event_finalize(
        arg1: ::std::os::raw::c_uint,
        arg2: *mut event,
        arg3: event_finalize_callback_fn,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn event_free_finalize(
        arg1: ::std::os::raw::c_uint,
        arg2: *mut event,
        arg3: event_finalize_callback_fn,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Schedule a one-time event\n\nThe function event_base_once() is similar to event_new().  However, it\nschedules a callback to be called exactly once, and does not require the\ncaller to prepare an event structure.\n\nNote that in Libevent 2.0 and earlier, if the event is never triggered, the\ninternal memory used to hold it will never be freed.  In Libevent 2.1,\nthe internal memory will get freed by event_base_free() if the event\nis never triggered.  The 'arg' value, however, will not get freed in either\ncase--you'll need to free that on your own if you want it to go away.\n\n@param base an event_base\n@param fd a file descriptor to monitor, or -1 for no fd.\n@param events event(s) to monitor; can be any of EV_READ |\nEV_WRITE, or EV_TIMEOUT\n@param callback callback function to be invoked when the event occurs\n@param arg an argument to be passed to the callback function\n@param timeout the maximum amount of time to wait for the event. NULL\nmakes an EV_READ/EV_WRITE event make forever; NULL makes an\nEV_TIMEOUT event success immediately.\n@return 0 if successful, or -1 if an error occurred"]
    pub fn event_base_once(
        arg1: *mut event_base,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_short,
        arg4: event_callback_fn,
        arg5: *mut ::std::os::raw::c_void,
        arg6: *const timeval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Add an event to the set of pending events.\n\nThe function event_add() schedules the execution of the event 'ev' when the\ncondition specified by event_assign() or event_new() occurs, or when the time\nspecified in timeout has elapsed.  If a timeout is NULL, no timeout\noccurs and the function will only be\ncalled if a matching event occurs.  The event in the\nev argument must be already initialized by event_assign() or event_new()\nand may not be used\nin calls to event_assign() until it is no longer pending.\n\nIf the event in the ev argument already has a scheduled timeout, calling\nevent_add() replaces the old timeout with the new one if tv is non-NULL.\n\n@param ev an event struct initialized via event_assign() or event_new()\n@param timeout the maximum amount of time to wait for the event, or NULL\nto wait forever\n@return 0 if successful, or -1 if an error occurred\n@see event_del(), event_assign(), event_new()"]
    pub fn event_add(ev: *mut event, timeout: *const timeval) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Remove a timer from a pending event without removing the event itself.\n\nIf the event has a scheduled timeout, this function unschedules it but\nleaves the event otherwise pending.\n\n@param ev an event struct initialized via event_assign() or event_new()\n@return 0 on success, or -1 if an error occurred."]
    pub fn event_remove_timer(ev: *mut event) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Remove an event from the set of monitored events.\n\nThe function event_del() will cancel the event in the argument ev.  If the\nevent has already executed or has never been added the call will have no\neffect.\n\n@param ev an event struct to be removed from the working set\n@return 0 if successful, or -1 if an error occurred\n@see event_add()"]
    pub fn event_del(arg1: *mut event) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "As event_del(), but never blocks while the event's callback is running\nin another thread, even if the event was constructed without the\nEV_FINALIZE flag."]
    pub fn event_del_noblock(ev: *mut event) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "As event_del(), but always blocks while the event's callback is running\nin another thread, even if the event was constructed with the\nEV_FINALIZE flag."]
    pub fn event_del_block(ev: *mut event) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Make an event active.\n\nYou can use this function on a pending or a non-pending event to make it\nactive, so that its callback will be run by event_base_dispatch() or\nevent_base_loop().\n\nOne common use in multithreaded programs is to wake the thread running\nevent_base_loop() from another thread.\n\n@param ev an event to make active.\n@param res a set of flags to pass to the event's callback.\n@param ncalls an obsolete argument: this is ignored."]
    pub fn event_active(
        ev: *mut event,
        res: ::std::os::raw::c_int,
        ncalls: ::std::os::raw::c_short,
    );
}
extern "C" {
    #[doc = "Checks if a specific event is pending or scheduled.\n\n@param ev an event struct previously passed to event_add()\n@param events the requested event type; any of EV_TIMEOUT|EV_READ|\nEV_WRITE|EV_SIGNAL\n@param tv if this field is not NULL, and the event has a timeout,\nthis field is set to hold the time at which the timeout will\nexpire.\n\n@return true if the event is pending on any of the events in 'what', (that\nis to say, it has been added), or 0 if the event is not added."]
    pub fn event_pending(
        ev: *const event,
        events: ::std::os::raw::c_short,
        tv: *mut timeval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "If called from within the callback for an event, returns that event.\n\nThe behavior of this function is not defined when called from outside the\ncallback function for an event."]
    pub fn event_base_get_running_event(base: *mut event_base) -> *mut event;
}
extern "C" {
    #[doc = "Test if an event structure might be initialized.\n\nThe event_initialized() function can be used to check if an event has been\ninitialized.\n\nWarning: This function is only useful for distinguishing a zeroed-out\npiece of memory from an initialized event, it can easily be confused by\nuninitialized memory.  Thus, it should ONLY be used to distinguish an\ninitialized event from zero.\n\n@param ev an event structure to be tested\n@return 1 if the structure might be initialized, or 0 if it has not been\ninitialized"]
    pub fn event_initialized(ev: *const event) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Get the socket or signal assigned to an event, or -1 if the event has\nno socket."]
    pub fn event_get_fd(ev: *const event) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Get the event_base associated with an event."]
    pub fn event_get_base(ev: *const event) -> *mut event_base;
}
extern "C" {
    #[doc = "Return the events (EV_READ, EV_WRITE, etc) assigned to an event."]
    pub fn event_get_events(ev: *const event) -> ::std::os::raw::c_short;
}
extern "C" {
    #[doc = "Return the callback assigned to an event."]
    pub fn event_get_callback(ev: *const event) -> event_callback_fn;
}
extern "C" {
    #[doc = "Return the callback argument assigned to an event."]
    pub fn event_get_callback_arg(ev: *const event) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = "Return the priority of an event.\n@see event_priority_init(), event_get_priority()"]
    pub fn event_get_priority(ev: *const event) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Extract _all_ of arguments given to construct a given event.  The\nevent_base is copied into *base_out, the fd is copied into *fd_out, and so\non.\n\nIf any of the \"_out\" arguments is NULL, it will be ignored."]
    pub fn event_get_assignment(
        event: *const event,
        base_out: *mut *mut event_base,
        fd_out: *mut ::std::os::raw::c_int,
        events_out: *mut ::std::os::raw::c_short,
        callback_out: *mut event_callback_fn,
        arg_out: *mut *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = "Return the size of struct event that the Libevent library was compiled\nwith.\n\nThis will be NO GREATER than sizeof(struct event) if you're running with\nthe same version of Libevent that your application was built with, but\notherwise might not.\n\nNote that it might be SMALLER than sizeof(struct event) if some future\nversion of Libevent adds extra padding to the end of struct event.\nWe might do this to help ensure ABI-compatibility between different\nversions of Libevent."]
    pub fn event_get_struct_event_size() -> usize;
}
extern "C" {
    #[doc = "Get the Libevent version.\n\nNote that this will give you the version of the library that you're\ncurrently linked against, not the version of the headers that you've\ncompiled against.\n\n@return a string containing the version number of Libevent"]
    pub fn event_get_version() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "Return a numeric representation of Libevent's version.\n\nNote that this will give you the version of the library that you're\ncurrently linked against, not the version of the headers you've used to\ncompile.\n\nThe format uses one byte each for the major, minor, and patchlevel parts of\nthe version number.  The low-order byte is unused.  For example, version\n2.0.1-alpha has a numeric representation of 0x02000100"]
    pub fn event_get_version_number() -> u32;
}
extern "C" {
    #[doc = "Set the number of different event priorities\n\nBy default Libevent schedules all active events with the same priority.\nHowever, some time it is desirable to process some events with a higher\npriority than others.  For that reason, Libevent supports strict priority\nqueues.  Active events with a lower priority are always processed before\nevents with a higher priority.\n\nThe number of different priorities can be set initially with the\nevent_base_priority_init() function.  This function should be called\nbefore the first call to event_base_dispatch().  The\nevent_priority_set() function can be used to assign a priority to an\nevent.  By default, Libevent assigns the middle priority to all events\nunless their priority is explicitly set.\n\nNote that urgent-priority events can starve less-urgent events: after\nrunning all urgent-priority callbacks, Libevent checks for more urgent\nevents again, before running less-urgent events.  Less-urgent events\nwill not have their callbacks run until there are no events more urgent\nthan them that want to be active.\n\n@param eb the event_base structure returned by event_base_new()\n@param npriorities the maximum number of priorities\n@return 0 if successful, or -1 if an error occurred\n@see event_priority_set()"]
    pub fn event_base_priority_init(
        arg1: *mut event_base,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Get the number of different event priorities.\n\n@param eb the event_base structure returned by event_base_new()\n@return Number of different event priorities\n@see event_base_priority_init()"]
    pub fn event_base_get_npriorities(eb: *mut event_base) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Assign a priority to an event.\n\n@param ev an event struct\n@param priority the new priority to be assigned\n@return 0 if successful, or -1 if an error occurred\n@see event_priority_init(), event_get_priority()"]
    pub fn event_priority_set(
        arg1: *mut event,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Prepare an event_base to use a large number of timeouts with the same\nduration.\n\nLibevent's default scheduling algorithm is optimized for having a large\nnumber of timeouts with their durations more or less randomly\ndistributed.  But if you have a large number of timeouts that all have\nthe same duration (for example, if you have a large number of\nconnections that all have a 10-second timeout), then you can improve\nLibevent's performance by telling Libevent about it.\n\nTo do this, call this function with the common duration.  It will return a\npointer to a different, opaque timeout value.  (Don't depend on its actual\ncontents!)  When you use this timeout value in event_add(), Libevent will\nschedule the event more efficiently.\n\n(This optimization probably will not be worthwhile until you have thousands\nor tens of thousands of events with the same timeout.)"]
    pub fn event_base_init_common_timeout(
        base: *mut event_base,
        duration: *const timeval,
    ) -> *const timeval;
}
extern "C" {
    #[doc = "Override the functions that Libevent uses for memory management.\n\nUsually, Libevent uses the standard libc functions malloc, realloc, and\nfree to allocate memory.  Passing replacements for those functions to\nevent_set_mem_functions() overrides this behavior.\n\nNote that all memory returned from Libevent will be allocated by the\nreplacement functions rather than by malloc() and realloc().  Thus, if you\nhave replaced those functions, it will not be appropriate to free() memory\nthat you get from Libevent.  Instead, you must use the free_fn replacement\nthat you provided.\n\nNote also that if you are going to call this function, you should do so\nbefore any call to any Libevent function that does allocation.\nOtherwise, those functions will allocate their memory using malloc(), but\nthen later free it using your provided free_fn.\n\n@param malloc_fn A replacement for malloc.\n@param realloc_fn A replacement for realloc\n@param free_fn A replacement for free."]
    pub fn event_set_mem_functions(
        malloc_fn: ::std::option::Option<
            unsafe extern "C" fn(sz: usize) -> *mut ::std::os::raw::c_void,
        >,
        realloc_fn: ::std::option::Option<
            unsafe extern "C" fn(
                ptr: *mut ::std::os::raw::c_void,
                sz: usize,
            ) -> *mut ::std::os::raw::c_void,
        >,
        free_fn: ::std::option::Option<unsafe extern "C" fn(ptr: *mut ::std::os::raw::c_void)>,
    );
}
extern "C" {
    #[doc = "Writes a human-readable description of all inserted and/or active\nevents to a provided stdio stream.\n\nThis is intended for debugging; its format is not guaranteed to be the same\nbetween libevent versions.\n\n@param base An event_base on which to scan the events.\n@param output A stdio file to write on."]
    pub fn event_base_dump_events(arg1: *mut event_base, arg2: *mut FILE);
}
extern "C" {
    #[doc = "Activates all pending events for the given fd and event mask.\n\nThis function activates pending events only.  Events which have not been\nadded will not become active.\n\n@param base the event_base on which to activate the events.\n@param fd An fd to active events on.\n@param events One or more of EV_{READ,WRITE,TIMEOUT}."]
    pub fn event_base_active_by_fd(
        base: *mut event_base,
        fd: ::std::os::raw::c_int,
        events: ::std::os::raw::c_short,
    );
}
extern "C" {
    #[doc = "Activates all pending signals with a given signal number\n\nThis function activates pending events only.  Events which have not been\nadded will not become active.\n\n@param base the event_base on which to activate the events.\n@param fd The signal to active events on."]
    pub fn event_base_active_by_signal(base: *mut event_base, sig: ::std::os::raw::c_int);
}
#[doc = " Callback for iterating events in an event base via event_base_foreach_event"]
pub type event_base_foreach_event_cb = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const event_base,
        arg2: *const event,
        arg3: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    #[doc = "Iterate over all added or active events events in an event loop, and invoke\na given callback on each one.\n\nThe callback must not call any function that modifies the event base, that\nmodifies any event in the event base, or that adds or removes any event to\nthe event base.  Doing so is unsupported and will lead to undefined\nbehavior -- likely, to crashes.\n\nevent_base_foreach_event() holds a lock on the event_base() for the whole\ntime it's running: slow callbacks are not advisable.\n\nNote that Libevent adds some events of its own to make pieces of its\nfunctionality work.  You must not assume that the only events you'll\nencounter will be the ones you added yourself.\n\nThe callback function must return 0 to continue iteration, or some other\ninteger to stop iterating.\n\n@param base An event_base on which to scan the events.\n@param fn   A callback function to receive the events.\n@param arg  An argument passed to the callback function.\n@return 0 if we iterated over every event, or the value returned by the\ncallback function if the loop exited early."]
    pub fn event_base_foreach_event(
        base: *mut event_base,
        fn_: event_base_foreach_event_cb,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Sets 'tv' to the current time (as returned by gettimeofday()),\nlooking at the cached value in 'base' if possible, and calling\ngettimeofday() or clock_gettime() as appropriate if there is no\ncached time.\n\nGenerally, this value will only be cached while actually\nprocessing event callbacks, and may be very inaccurate if your\ncallbacks take a long time to execute.\n\nReturns 0 on success, negative on failure."]
    pub fn event_base_gettimeofday_cached(
        base: *mut event_base,
        tv: *mut timeval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Update cached_tv in the 'base' to the current time\n\n You can use this function is useful for selectively increasing\n the accuracy of the cached time value in 'base' during callbacks\n that take a long time to execute.\n\n This function has no effect if the base is currently not in its\n event loop, or if timeval caching is disabled via\n EVENT_BASE_FLAG_NO_CACHE_TIME.\n\n @return 0 on success, -1 on failure"]
    pub fn event_base_update_cache_time(base: *mut event_base) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Release up all globally-allocated resources allocated by Libevent.\n\nThis function does not free developer-controlled resources like\nevent_bases, events, bufferevents, listeners, and so on.  It only releases\nresources like global locks that there is no other way to free.\n\nIt is not actually necessary to call this function before exit: every\nresource that it frees would be released anyway on exit.  It mainly exists\nso that resource-leak debugging tools don't see Libevent as holding\nresources at exit.\n\nYou should only call this function when no other Libevent functions will\nbe invoked -- e.g., when cleanly exiting a program."]
    pub fn libevent_global_shutdown();
}
extern "C" {
    #[doc = "Initialize the event API.\n\nThe event API needs to be initialized with event_init() before it can be\nused.  Sets the global current base that gets used for events that have no\nbase associated with them.\n\n@deprecated This function is deprecated because it replaces the \"current\"\nevent_base, and is totally unsafe for multithreaded use.  The replacement\nis event_base_new().\n\n@see event_base_set(), event_base_new()"]
    pub fn event_init() -> *mut event_base;
}
extern "C" {
    #[doc = "Loop to process events.\n\nLike event_base_dispatch(), but uses the \"current\" base.\n\n@deprecated This function is deprecated because it is easily confused by\nmultiple calls to event_init(), and because it is not safe for\nmultithreaded use.  The replacement is event_base_dispatch().\n\n@see event_base_dispatch(), event_init()"]
    pub fn event_dispatch() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Handle events.\n\nThis function behaves like event_base_loop(), but uses the \"current\" base\n\n@deprecated This function is deprecated because it uses the event base from\nthe last call to event_init, and is therefore not safe for multithreaded\nuse.  The replacement is event_base_loop().\n\n@see event_base_loop(), event_init()"]
    pub fn event_loop(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Exit the event loop after the specified time.\n\nThis function behaves like event_base_loopexit(), except that it uses the\n\"current\" base.\n\n@deprecated This function is deprecated because it uses the event base from\nthe last call to event_init, and is therefore not safe for multithreaded\nuse.  The replacement is event_base_loopexit().\n\n@see event_init, event_base_loopexit()"]
    pub fn event_loopexit(arg1: *const timeval) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Abort the active event_loop() immediately.\n\nThis function behaves like event_base_loopbreakt(), except that it uses the\n\"current\" base.\n\n@deprecated This function is deprecated because it uses the event base from\nthe last call to event_init, and is therefore not safe for multithreaded\nuse.  The replacement is event_base_loopbreak().\n\n@see event_base_loopbreak(), event_init()"]
    pub fn event_loopbreak() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Schedule a one-time event to occur.\n\n@deprecated This function is obsolete, and has been replaced by\nevent_base_once(). Its use is deprecated because it relies on the\n\"current\" base configured by event_init().\n\n@see event_base_once()"]
    pub fn event_once(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_short,
        arg3: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: ::std::os::raw::c_int,
                arg2: ::std::os::raw::c_short,
                arg3: *mut ::std::os::raw::c_void,
            ),
        >,
        arg4: *mut ::std::os::raw::c_void,
        arg5: *const timeval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Get the kernel event notification mechanism used by Libevent.\n\n@deprecated This function is obsolete, and has been replaced by\nevent_base_get_method(). Its use is deprecated because it relies on the\n\"current\" base configured by event_init().\n\n@see event_base_get_method()"]
    pub fn event_get_method() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "Set the number of different event priorities.\n\n@deprecated This function is deprecated because it is easily confused by\nmultiple calls to event_init(), and because it is not safe for\nmultithreaded use.  The replacement is event_base_priority_init().\n\n@see event_base_priority_init()"]
    pub fn event_priority_init(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Prepare an event structure to be added.\n\n@deprecated event_set() is not recommended for new code, because it requires\na subsequent call to event_base_set() to be safe under most circumstances.\nUse event_assign() or event_new() instead."]
    pub fn event_set(
        arg1: *mut event,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_short,
        arg4: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: ::std::os::raw::c_int,
                arg2: ::std::os::raw::c_short,
                arg3: *mut ::std::os::raw::c_void,
            ),
        >,
        arg5: *mut ::std::os::raw::c_void,
    );
}
pub const uio_rw_UIO_READ: uio_rw = 0;
pub const uio_rw_UIO_WRITE: uio_rw = 1;
pub type uio_rw = ::std::os::raw::c_uint;
extern "C" {
    pub fn readv(
        arg1: ::std::os::raw::c_int,
        arg2: *const iovec,
        arg3: ::std::os::raw::c_int,
    ) -> isize;
}
extern "C" {
    pub fn writev(
        arg1: ::std::os::raw::c_int,
        arg2: *const iovec,
        arg3: ::std::os::raw::c_int,
    ) -> isize;
}
extern "C" {
    pub fn preadv(
        arg1: ::std::os::raw::c_int,
        arg2: *const iovec,
        arg3: ::std::os::raw::c_int,
        arg4: off_t,
    ) -> isize;
}
extern "C" {
    pub fn pwritev(
        arg1: ::std::os::raw::c_int,
        arg2: *const iovec,
        arg3: ::std::os::raw::c_int,
        arg4: off_t,
    ) -> isize;
}
#[doc = "An evbuffer is an opaque data type for efficiently buffering data to be\nsent or received on the network.\n\n@see event2/event.h for more information"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct evbuffer {
    _unused: [u8; 0],
}
#[doc = "Pointer to a position within an evbuffer.\n\nUsed when repeatedly searching through a buffer.  Calling any function\nthat modifies or re-packs the buffer contents may invalidate all\nevbuffer_ptrs for that buffer.  Do not modify or contruct these values\nexcept with evbuffer_ptr_set.\n\nAn evbuffer_ptr can represent any position from the start of a buffer up\nto a position immediately after the end of a buffer.\n\n@see evbuffer_ptr_set()"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct evbuffer_ptr {
    pub pos: isize,
    pub internal_: evbuffer_ptr__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct evbuffer_ptr__bindgen_ty_1 {
    pub chain: *mut ::std::os::raw::c_void,
    pub pos_in_chain: usize,
}
#[test]
fn bindgen_test_layout_evbuffer_ptr__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<evbuffer_ptr__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<evbuffer_ptr__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(evbuffer_ptr__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<evbuffer_ptr__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(evbuffer_ptr__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).chain) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(evbuffer_ptr__bindgen_ty_1),
            "::",
            stringify!(chain)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pos_in_chain) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(evbuffer_ptr__bindgen_ty_1),
            "::",
            stringify!(pos_in_chain)
        )
    );
}
#[test]
fn bindgen_test_layout_evbuffer_ptr() {
    const UNINIT: ::std::mem::MaybeUninit<evbuffer_ptr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<evbuffer_ptr>(),
        24usize,
        concat!("Size of: ", stringify!(evbuffer_ptr))
    );
    assert_eq!(
        ::std::mem::align_of::<evbuffer_ptr>(),
        8usize,
        concat!("Alignment of ", stringify!(evbuffer_ptr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pos) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(evbuffer_ptr),
            "::",
            stringify!(pos)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).internal_) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(evbuffer_ptr),
            "::",
            stringify!(internal_)
        )
    );
}
extern "C" {
    #[doc = "Allocate storage for a new evbuffer.\n\n@return a pointer to a newly allocated evbuffer struct, or NULL if an error\noccurred"]
    pub fn evbuffer_new() -> *mut evbuffer;
}
extern "C" {
    #[doc = "Deallocate storage for an evbuffer.\n\n@param buf pointer to the evbuffer to be freed"]
    pub fn evbuffer_free(buf: *mut evbuffer);
}
extern "C" {
    #[doc = "Enable locking on an evbuffer so that it can safely be used by multiple\nthreads at the same time.\n\nNOTE: when locking is enabled, the lock will be held when callbacks are\ninvoked.  This could result in deadlock if you aren't careful.  Plan\naccordingly!\n\n@param buf An evbuffer to make lockable.\n@param lock A lock object, or NULL if we should allocate our own.\n@return 0 on success, -1 on failure."]
    pub fn evbuffer_enable_locking(
        buf: *mut evbuffer,
        lock: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Acquire the lock on an evbuffer.  Has no effect if locking was not enabled\nwith evbuffer_enable_locking."]
    pub fn evbuffer_lock(buf: *mut evbuffer);
}
extern "C" {
    #[doc = "Release the lock on an evbuffer.  Has no effect if locking was not enabled\nwith evbuffer_enable_locking."]
    pub fn evbuffer_unlock(buf: *mut evbuffer);
}
extern "C" {
    #[doc = " Change the flags that are set for an evbuffer by adding more.\n\n @param buffer the evbuffer that the callback is watching.\n @param cb the callback whose status we want to change.\n @param flags One or more EVBUFFER_FLAG_* options\n @return 0 on success, -1 on failure."]
    pub fn evbuffer_set_flags(buf: *mut evbuffer, flags: u64) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Change the flags that are set for an evbuffer by removing some.\n\n @param buffer the evbuffer that the callback is watching.\n @param cb the callback whose status we want to change.\n @param flags One or more EVBUFFER_FLAG_* options\n @return 0 on success, -1 on failure."]
    pub fn evbuffer_clear_flags(buf: *mut evbuffer, flags: u64) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Returns the total number of bytes stored in the evbuffer\n\n@param buf pointer to the evbuffer\n@return the number of bytes stored in the evbuffer"]
    pub fn evbuffer_get_length(buf: *const evbuffer) -> usize;
}
extern "C" {
    #[doc = "Returns the number of contiguous available bytes in the first buffer chain.\n\nThis is useful when processing data that might be split into multiple\nchains, or that might all be in the first chain.  Calls to\nevbuffer_pullup() that cause reallocation and copying of data can thus be\navoided.\n\n@param buf pointer to the evbuffer\n@return 0 if no data is available, otherwise the number of available bytes\nin the first buffer chain."]
    pub fn evbuffer_get_contiguous_space(buf: *const evbuffer) -> usize;
}
extern "C" {
    #[doc = "Expands the available space in an evbuffer.\n\nExpands the available space in the evbuffer to at least datlen, so that\nappending datlen additional bytes will not require any new allocations.\n\n@param buf the evbuffer to be expanded\n@param datlen the new minimum length requirement\n@return 0 if successful, or -1 if an error occurred"]
    pub fn evbuffer_expand(buf: *mut evbuffer, datlen: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Reserves space in the last chain or chains of an evbuffer.\n\nMakes space available in the last chain or chains of an evbuffer that can\nbe arbitrarily written to by a user.  The space does not become\navailable for reading until it has been committed with\nevbuffer_commit_space().\n\nThe space is made available as one or more extents, represented by\nan initial pointer and a length.  You can force the memory to be\navailable as only one extent.  Allowing more extents, however, makes the\nfunction more efficient.\n\nMultiple subsequent calls to this function will make the same space\navailable until evbuffer_commit_space() has been called.\n\nIt is an error to do anything that moves around the buffer's internal\nmemory structures before committing the space.\n\nNOTE: The code currently does not ever use more than two extents.\nThis may change in future versions.\n\n@param buf the evbuffer in which to reserve space.\n@param size how much space to make available, at minimum.  The\ntotal length of the extents may be greater than the requested\nlength.\n@param vec an array of one or more evbuffer_iovec structures to\nhold pointers to the reserved extents of memory.\n@param n_vec The length of the vec array.  Must be at least 1;\n2 is more efficient.\n@return the number of provided extents, or -1 on error.\n@see evbuffer_commit_space()"]
    pub fn evbuffer_reserve_space(
        buf: *mut evbuffer,
        size: isize,
        vec: *mut iovec,
        n_vec: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Commits previously reserved space.\n\nCommits some of the space previously reserved with\nevbuffer_reserve_space().  It then becomes available for reading.\n\nThis function may return an error if the pointer in the extents do\nnot match those returned from evbuffer_reserve_space, or if data\nhas been added to the buffer since the space was reserved.\n\nIf you want to commit less data than you got reserved space for,\nmodify the iov_len pointer of the appropriate extent to a smaller\nvalue.  Note that you may have received more space than you\nrequested if it was available!\n\n@param buf the evbuffer in which to reserve space.\n@param vec one or two extents returned by evbuffer_reserve_space.\n@param n_vecs the number of extents.\n@return 0 on success, -1 on error\n@see evbuffer_reserve_space()"]
    pub fn evbuffer_commit_space(
        buf: *mut evbuffer,
        vec: *mut iovec,
        n_vecs: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Append data to the end of an evbuffer.\n\n@param buf the evbuffer to be appended to\n@param data pointer to the beginning of the data buffer\n@param datlen the number of bytes to be copied from the data buffer\n@return 0 on success, -1 on failure."]
    pub fn evbuffer_add(
        buf: *mut evbuffer,
        data: *const ::std::os::raw::c_void,
        datlen: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Read data from an evbuffer and drain the bytes read.\n\nIf more bytes are requested than are available in the evbuffer, we\nonly extract as many bytes as were available.\n\n@param buf the evbuffer to be read from\n@param data the destination buffer to store the result\n@param datlen the maximum size of the destination buffer\n@return the number of bytes read, or -1 if we can't drain the buffer."]
    pub fn evbuffer_remove(
        buf: *mut evbuffer,
        data: *mut ::std::os::raw::c_void,
        datlen: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Read data from an evbuffer, and leave the buffer unchanged.\n\nIf more bytes are requested than are available in the evbuffer, we\nonly extract as many bytes as were available.\n\n@param buf the evbuffer to be read from\n@param data_out the destination buffer to store the result\n@param datlen the maximum size of the destination buffer\n@return the number of bytes read, or -1 if we can't drain the buffer."]
    pub fn evbuffer_copyout(
        buf: *mut evbuffer,
        data_out: *mut ::std::os::raw::c_void,
        datlen: usize,
    ) -> isize;
}
extern "C" {
    #[doc = "Read data from the middle of an evbuffer, and leave the buffer unchanged.\n\nIf more bytes are requested than are available in the evbuffer, we\nonly extract as many bytes as were available.\n\n@param buf the evbuffer to be read from\n@param pos the position to start reading from\n@param data_out the destination buffer to store the result\n@param datlen the maximum size of the destination buffer\n@return the number of bytes read, or -1 if we can't drain the buffer."]
    pub fn evbuffer_copyout_from(
        buf: *mut evbuffer,
        pos: *const evbuffer_ptr,
        data_out: *mut ::std::os::raw::c_void,
        datlen: usize,
    ) -> isize;
}
extern "C" {
    #[doc = "Read data from an evbuffer into another evbuffer, draining\nthe bytes from the source buffer.  This function avoids copy\noperations to the extent possible.\n\nIf more bytes are requested than are available in src, the src\nbuffer is drained completely.\n\n@param src the evbuffer to be read from\n@param dst the destination evbuffer to store the result into\n@param datlen the maximum numbers of bytes to transfer\n@return the number of bytes read"]
    pub fn evbuffer_remove_buffer(
        src: *mut evbuffer,
        dst: *mut evbuffer,
        datlen: usize,
    ) -> ::std::os::raw::c_int;
}
#[doc = " Any sequence of CR and LF characters is acceptable as an\n EOL.\n\n Note that this style can produce ambiguous results: the\n sequence \"CRLF\" will be treated as a single EOL if it is\n all in the buffer at once, but if you first read a CR from\n the network and later read an LF from the network, it will\n be treated as two EOLs."]
pub const evbuffer_eol_style_EVBUFFER_EOL_ANY: evbuffer_eol_style = 0;
#[doc = " An EOL is an LF, optionally preceded by a CR.  This style is\n most useful for implementing text-based internet protocols."]
pub const evbuffer_eol_style_EVBUFFER_EOL_CRLF: evbuffer_eol_style = 1;
#[doc = " An EOL is a CR followed by an LF."]
pub const evbuffer_eol_style_EVBUFFER_EOL_CRLF_STRICT: evbuffer_eol_style = 2;
#[doc = " An EOL is a LF."]
pub const evbuffer_eol_style_EVBUFFER_EOL_LF: evbuffer_eol_style = 3;
#[doc = " An EOL is a NUL character (that is, a single byte with value 0)"]
pub const evbuffer_eol_style_EVBUFFER_EOL_NUL: evbuffer_eol_style = 4;
#[doc = " Used to tell evbuffer_readln what kind of line-ending to look for."]
pub type evbuffer_eol_style = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " Read a single line from an evbuffer.\n\n Reads a line terminated by an EOL as determined by the evbuffer_eol_style\n argument.  Returns a newly allocated nul-terminated string; the caller must\n free the returned value.  The EOL is not included in the returned string.\n\n @param buffer the evbuffer to read from\n @param n_read_out if non-NULL, points to a size_t that is set to the\n       number of characters in the returned string.  This is useful for\n       strings that can contain NUL characters.\n @param eol_style the style of line-ending to use.\n @return pointer to a single line, or NULL if an error occurred"]
    pub fn evbuffer_readln(
        buffer: *mut evbuffer,
        n_read_out: *mut usize,
        eol_style: evbuffer_eol_style,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "Move all data from one evbuffer into another evbuffer.\n\nThis is a destructive add.  The data from one buffer moves into\nthe other buffer.  However, no unnecessary memory copies occur.\n\n@param outbuf the output buffer\n@param inbuf the input buffer\n@return 0 if successful, or -1 if an error occurred\n\n@see evbuffer_remove_buffer()"]
    pub fn evbuffer_add_buffer(
        outbuf: *mut evbuffer,
        inbuf: *mut evbuffer,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Copy data from one evbuffer into another evbuffer.\n\nThis is a non-destructive add.  The data from one buffer is copied\ninto the other buffer.  However, no unnecessary memory copies occur.\n\nNote that buffers already containing buffer references can't be added\nto other buffers.\n\n@param outbuf the output buffer\n@param inbuf the input buffer\n@return 0 if successful, or -1 if an error occurred"]
    pub fn evbuffer_add_buffer_reference(
        outbuf: *mut evbuffer,
        inbuf: *mut evbuffer,
    ) -> ::std::os::raw::c_int;
}
#[doc = "A cleanup function for a piece of memory added to an evbuffer by\nreference.\n\n@see evbuffer_add_reference()"]
pub type evbuffer_ref_cleanup_cb = ::std::option::Option<
    unsafe extern "C" fn(
        data: *const ::std::os::raw::c_void,
        datalen: usize,
        extra: *mut ::std::os::raw::c_void,
    ),
>;
extern "C" {
    #[doc = "Reference memory into an evbuffer without copying.\n\nThe memory needs to remain valid until all the added data has been\nread.  This function keeps just a reference to the memory without\nactually incurring the overhead of a copy.\n\n@param outbuf the output buffer\n@param data the memory to reference\n@param datlen how memory to reference\n@param cleanupfn callback to be invoked when the memory is no longer\nreferenced by this evbuffer.\n@param cleanupfn_arg optional argument to the cleanup callback\n@return 0 if successful, or -1 if an error occurred"]
    pub fn evbuffer_add_reference(
        outbuf: *mut evbuffer,
        data: *const ::std::os::raw::c_void,
        datlen: usize,
        cleanupfn: evbuffer_ref_cleanup_cb,
        cleanupfn_arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Copy data from a file into the evbuffer for writing to a socket.\n\nThis function avoids unnecessary data copies between userland and\nkernel.  If sendfile is available and the EVBUFFER_FLAG_DRAINS_TO_FD\nflag is set, it uses those functions.  Otherwise, it tries to use\nmmap (or CreateFileMapping on Windows).\n\nThe function owns the resulting file descriptor and will close it\nwhen finished transferring data.\n\nThe results of using evbuffer_remove() or evbuffer_pullup() on\nevbuffers whose data was added using this function are undefined.\n\nFor more fine-grained control, use evbuffer_add_file_segment.\n\n@param outbuf the output buffer\n@param fd the file descriptor\n@param offset the offset from which to read data\n@param length how much data to read, or -1 to read as much as possible.\n(-1 requires that 'fd' support fstat.)\n@return 0 if successful, or -1 if an error occurred"]
    pub fn evbuffer_add_file(
        outbuf: *mut evbuffer,
        fd: ::std::os::raw::c_int,
        offset: i64,
        length: i64,
    ) -> ::std::os::raw::c_int;
}
#[doc = "An evbuffer_file_segment holds a reference to a range of a file --\npossibly the whole file! -- for use in writing from an evbuffer to a\nsocket.  It could be implemented with mmap, sendfile, splice, or (if all\nelse fails) by just pulling all the data into RAM.  A single\nevbuffer_file_segment can be added more than once, and to more than one\nevbuffer."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct evbuffer_file_segment {
    _unused: [u8; 0],
}
#[doc = "A cleanup function for a evbuffer_file_segment added to an evbuffer\nfor reference."]
pub type evbuffer_file_segment_cleanup_cb = ::std::option::Option<
    unsafe extern "C" fn(
        seg: *const evbuffer_file_segment,
        flags: ::std::os::raw::c_int,
        arg: *mut ::std::os::raw::c_void,
    ),
>;
extern "C" {
    #[doc = "Create and return a new evbuffer_file_segment for reading data from a\nfile and sending it out via an evbuffer.\n\nThis function avoids unnecessary data copies between userland and\nkernel.  Where available, it uses sendfile or splice.\n\nThe file descriptor must not be closed so long as any evbuffer is using\nthis segment.\n\nThe results of using evbuffer_remove() or evbuffer_pullup() or any other\nfunction that reads bytes from an evbuffer on any evbuffer containing\nthe newly returned segment are undefined, unless you pass the\nEVBUF_FS_DISABLE_SENDFILE flag to this function.\n\n@param fd an open file to read from.\n@param offset an index within the file at which to start reading\n@param length how much data to read, or -1 to read as much as possible.\n(-1 requires that 'fd' support fstat.)\n@param flags any number of the EVBUF_FS_* flags\n@return a new evbuffer_file_segment, or NULL on failure."]
    pub fn evbuffer_file_segment_new(
        fd: ::std::os::raw::c_int,
        offset: i64,
        length: i64,
        flags: ::std::os::raw::c_uint,
    ) -> *mut evbuffer_file_segment;
}
extern "C" {
    #[doc = "Free an evbuffer_file_segment\n\nIt is safe to call this function even if the segment has been added to\none or more evbuffers.  The evbuffer_file_segment will not be freed\nuntil no more references to it exist."]
    pub fn evbuffer_file_segment_free(seg: *mut evbuffer_file_segment);
}
extern "C" {
    #[doc = "Add cleanup callback and argument for the callback to an\nevbuffer_file_segment.\n\nThe cleanup callback will be invoked when no more references to the\nevbuffer_file_segment exist."]
    pub fn evbuffer_file_segment_add_cleanup_cb(
        seg: *mut evbuffer_file_segment,
        cb: evbuffer_file_segment_cleanup_cb,
        arg: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = "Insert some or all of an evbuffer_file_segment at the end of an evbuffer\n\nNote that the offset and length parameters of this function have a\ndifferent meaning from those provided to evbuffer_file_segment_new: When\nyou create the segment, the offset is the offset _within the file_, and\nthe length is the length _of the segment_, whereas when you add a\nsegment to an evbuffer, the offset is _within the segment_ and the\nlength is the length of the _part of the segment you want to use.\n\nIn other words, if you have a 10 KiB file, and you create an\nevbuffer_file_segment for it with offset 20 and length 1000, it will\nrefer to bytes 20..1019 inclusive.  If you then pass this segment to\nevbuffer_add_file_segment and specify an offset of 20 and a length of\n50, you will be adding bytes 40..99 inclusive.\n\n@param buf the evbuffer to append to\n@param seg the segment to add\n@param offset the offset within the segment to start from\n@param length the amount of data to add, or -1 to add it all.\n@return 0 on success, -1 on failure."]
    pub fn evbuffer_add_file_segment(
        buf: *mut evbuffer,
        seg: *mut evbuffer_file_segment,
        offset: i64,
        length: i64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Append a formatted string to the end of an evbuffer.\n\nThe string is formated as printf.\n\n@param buf the evbuffer that will be appended to\n@param fmt a format string\n@param ... arguments that will be passed to printf(3)\n@return The number of bytes added if successful, or -1 if an error occurred.\n\n@see evutil_printf(), evbuffer_add_vprintf()"]
    pub fn evbuffer_add_printf(
        buf: *mut evbuffer,
        fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Append a va_list formatted string to the end of an evbuffer.\n\n@param buf the evbuffer that will be appended to\n@param fmt a format string\n@param ap a varargs va_list argument array that will be passed to vprintf(3)\n@return The number of bytes added if successful, or -1 if an error occurred."]
    pub fn evbuffer_add_vprintf(
        buf: *mut evbuffer,
        fmt: *const ::std::os::raw::c_char,
        ap: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Remove a specified number of bytes data from the beginning of an evbuffer.\n\n@param buf the evbuffer to be drained\n@param len the number of bytes to drain from the beginning of the buffer\n@return 0 on success, -1 on failure."]
    pub fn evbuffer_drain(buf: *mut evbuffer, len: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Write the contents of an evbuffer to a file descriptor.\n\nThe evbuffer will be drained after the bytes have been successfully written.\n\n@param buffer the evbuffer to be written and drained\n@param fd the file descriptor to be written to\n@return the number of bytes written, or -1 if an error occurred\n@see evbuffer_read()"]
    pub fn evbuffer_write(
        buffer: *mut evbuffer,
        fd: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Write some of the contents of an evbuffer to a file descriptor.\n\nThe evbuffer will be drained after the bytes have been successfully written.\n\n@param buffer the evbuffer to be written and drained\n@param fd the file descriptor to be written to\n@param howmuch the largest allowable number of bytes to write, or -1\nto write as many bytes as we can.\n@return the number of bytes written, or -1 if an error occurred\n@see evbuffer_read()"]
    pub fn evbuffer_write_atmost(
        buffer: *mut evbuffer,
        fd: ::std::os::raw::c_int,
        howmuch: isize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Read from a file descriptor and store the result in an evbuffer.\n\n@param buffer the evbuffer to store the result\n@param fd the file descriptor to read from\n@param howmuch the number of bytes to be read. If the given number is negative\nor out of maximum bytes per one read, as many bytes as we can will be read.\n@return the number of bytes read, or -1 if an error occurred\n@see evbuffer_write()"]
    pub fn evbuffer_read(
        buffer: *mut evbuffer,
        fd: ::std::os::raw::c_int,
        howmuch: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Search for a string within an evbuffer.\n\n@param buffer the evbuffer to be searched\n@param what the string to be searched for\n@param len the length of the search string\n@param start NULL or a pointer to a valid struct evbuffer_ptr.\n@return a struct evbuffer_ptr whose 'pos' field has the offset of the\nfirst occurrence of the string in the buffer after 'start'.  The 'pos'\nfield of the result is -1 if the string was not found."]
    pub fn evbuffer_search(
        buffer: *mut evbuffer,
        what: *const ::std::os::raw::c_char,
        len: usize,
        start: *const evbuffer_ptr,
    ) -> evbuffer_ptr;
}
extern "C" {
    #[doc = "Search for a string within part of an evbuffer.\n\n@param buffer the evbuffer to be searched\n@param what the string to be searched for\n@param len the length of the search string\n@param start NULL or a pointer to a valid struct evbuffer_ptr that\nindicates where we should start searching.\n@param end NULL or a pointer to a valid struct evbuffer_ptr that\nindicates where we should stop searching.\n@return a struct evbuffer_ptr whose 'pos' field has the offset of the\nfirst occurrence of the string in the buffer after 'start'.  The 'pos'\nfield of the result is -1 if the string was not found."]
    pub fn evbuffer_search_range(
        buffer: *mut evbuffer,
        what: *const ::std::os::raw::c_char,
        len: usize,
        start: *const evbuffer_ptr,
        end: *const evbuffer_ptr,
    ) -> evbuffer_ptr;
}
#[doc = " Sets the pointer to the position; can be called on with an\nuninitialized evbuffer_ptr."]
pub const evbuffer_ptr_how_EVBUFFER_PTR_SET: evbuffer_ptr_how = 0;
#[doc = " Advances the pointer by adding to the current position."]
pub const evbuffer_ptr_how_EVBUFFER_PTR_ADD: evbuffer_ptr_how = 1;
#[doc = "Defines how to adjust an evbuffer_ptr by evbuffer_ptr_set()\n\n@see evbuffer_ptr_set()"]
pub type evbuffer_ptr_how = ::std::os::raw::c_uint;
extern "C" {
    #[doc = "Sets the search pointer in the buffer to position.\n\nThere are two ways to use this function: you can call\nevbuffer_ptr_set(buf, &pos, N, EVBUFFER_PTR_SET)\nto move 'pos' to a position 'N' bytes after the start of the buffer, or\nevbuffer_ptr_set(buf, &pos, N, EVBUFFER_PTR_ADD)\nto move 'pos' forward by 'N' bytes.\n\nIf evbuffer_ptr is not initialized, this function can only be called\nwith EVBUFFER_PTR_SET.\n\nAn evbuffer_ptr can represent any position from the start of the buffer to\na position immediately after the end of the buffer.\n\n@param buffer the evbuffer to be search\n@param ptr a pointer to a struct evbuffer_ptr\n@param position the position at which to start the next search\n@param how determines how the pointer should be manipulated.\n@returns 0 on success or -1 otherwise"]
    pub fn evbuffer_ptr_set(
        buffer: *mut evbuffer,
        ptr: *mut evbuffer_ptr,
        position: usize,
        how: evbuffer_ptr_how,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Search for an end-of-line string within an evbuffer.\n\n@param buffer the evbuffer to be searched\n@param start NULL or a pointer to a valid struct evbuffer_ptr to start\nsearching at.\n@param eol_len_out If non-NULL, the pointed-to value will be set to\nthe length of the end-of-line string.\n@param eol_style The kind of EOL to look for; see evbuffer_readln() for\nmore information\n@return a struct evbuffer_ptr whose 'pos' field has the offset of the\nfirst occurrence EOL in the buffer after 'start'.  The 'pos'\nfield of the result is -1 if the string was not found."]
    pub fn evbuffer_search_eol(
        buffer: *mut evbuffer,
        start: *mut evbuffer_ptr,
        eol_len_out: *mut usize,
        eol_style: evbuffer_eol_style,
    ) -> evbuffer_ptr;
}
extern "C" {
    #[doc = " Function to peek at data inside an evbuffer without removing it or\ncopying it out.\n\nPointers to the data are returned by filling the 'vec_out' array\nwith pointers to one or more extents of data inside the buffer.\n\nThe total data in the extents that you get back may be more than\nyou requested (if there is more data last extent than you asked\nfor), or less (if you do not provide enough evbuffer_iovecs, or if\nthe buffer does not have as much data as you asked to see).\n\n@param buffer the evbuffer to peek into,\n@param len the number of bytes to try to peek.  If len is negative, we\nwill try to fill as much of vec_out as we can.  If len is negative\nand vec_out is not provided, we return the number of evbuffer_iovecs\nthat would be needed to get all the data in the buffer.\n@param start_at an evbuffer_ptr indicating the point at which we\nshould start looking for data.  NULL means, \"At the start of the\nbuffer.\"\n@param vec_out an array of evbuffer_iovec\n@param n_vec the length of vec_out.  If 0, we only count how many\nextents would be necessary to point to the requested amount of\ndata.\n@return The number of extents needed.  This may be less than n_vec\nif we didn't need all the evbuffer_iovecs we were given, or more\nthan n_vec if we would need more to return all the data that was\nrequested."]
    pub fn evbuffer_peek(
        buffer: *mut evbuffer,
        len: isize,
        start_at: *mut evbuffer_ptr,
        vec_out: *mut iovec,
        n_vec: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[doc = " Structure passed to an evbuffer_cb_func evbuffer callback\n\n@see evbuffer_cb_func, evbuffer_add_cb()"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct evbuffer_cb_info {
    #[doc = " The number of bytes in this evbuffer when callbacks were last\n invoked."]
    pub orig_size: usize,
    #[doc = " The number of bytes added since callbacks were last invoked."]
    pub n_added: usize,
    #[doc = " The number of bytes removed since callbacks were last invoked."]
    pub n_deleted: usize,
}
#[test]
fn bindgen_test_layout_evbuffer_cb_info() {
    const UNINIT: ::std::mem::MaybeUninit<evbuffer_cb_info> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<evbuffer_cb_info>(),
        24usize,
        concat!("Size of: ", stringify!(evbuffer_cb_info))
    );
    assert_eq!(
        ::std::mem::align_of::<evbuffer_cb_info>(),
        8usize,
        concat!("Alignment of ", stringify!(evbuffer_cb_info))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).orig_size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(evbuffer_cb_info),
            "::",
            stringify!(orig_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).n_added) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(evbuffer_cb_info),
            "::",
            stringify!(n_added)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).n_deleted) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(evbuffer_cb_info),
            "::",
            stringify!(n_deleted)
        )
    );
}
#[doc = " Type definition for a callback that is invoked whenever data is added or\nremoved from an evbuffer.\n\nAn evbuffer may have one or more callbacks set at a time.  The order\nin which they are executed is undefined.\n\nA callback function may add more callbacks, or remove itself from the\nlist of callbacks, or add or remove data from the buffer.  It may not\nremove another callback from the list.\n\nIf a callback adds or removes data from the buffer or from another\nbuffer, this can cause a recursive invocation of your callback or\nother callbacks.  If you ask for an infinite loop, you might just get\none: watch out!\n\n@param buffer the buffer whose size has changed\n@param info a structure describing how the buffer changed.\n@param arg a pointer to user data"]
pub type evbuffer_cb_func = ::std::option::Option<
    unsafe extern "C" fn(
        buffer: *mut evbuffer,
        info: *const evbuffer_cb_info,
        arg: *mut ::std::os::raw::c_void,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct evbuffer_cb_entry {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Add a new callback to an evbuffer.\n\nSubsequent calls to evbuffer_add_cb() add new callbacks.  To remove this\ncallback, call evbuffer_remove_cb or evbuffer_remove_cb_entry.\n\n@param buffer the evbuffer to be monitored\n@param cb the callback function to invoke when the evbuffer is modified,\nor NULL to remove all callbacks.\n@param cbarg an argument to be provided to the callback function\n@return a handle to the callback on success, or NULL on failure."]
    pub fn evbuffer_add_cb(
        buffer: *mut evbuffer,
        cb: evbuffer_cb_func,
        cbarg: *mut ::std::os::raw::c_void,
    ) -> *mut evbuffer_cb_entry;
}
extern "C" {
    #[doc = " Remove a callback from an evbuffer, given a handle returned from\nevbuffer_add_cb.\n\nCalling this function invalidates the handle.\n\n@return 0 if a callback was removed, or -1 if no matching callback was\nfound."]
    pub fn evbuffer_remove_cb_entry(
        buffer: *mut evbuffer,
        ent: *mut evbuffer_cb_entry,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Remove a callback from an evbuffer, given the function and argument\nused to add it.\n\n@return 0 if a callback was removed, or -1 if no matching callback was\nfound."]
    pub fn evbuffer_remove_cb(
        buffer: *mut evbuffer,
        cb: evbuffer_cb_func,
        cbarg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Change the flags that are set for a callback on a buffer by adding more.\n\n@param buffer the evbuffer that the callback is watching.\n@param cb the callback whose status we want to change.\n@param flags EVBUFFER_CB_ENABLED to re-enable the callback.\n@return 0 on success, -1 on failure."]
    pub fn evbuffer_cb_set_flags(
        buffer: *mut evbuffer,
        cb: *mut evbuffer_cb_entry,
        flags: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Change the flags that are set for a callback on a buffer by removing some\n\n@param buffer the evbuffer that the callback is watching.\n@param cb the callback whose status we want to change.\n@param flags EVBUFFER_CB_ENABLED to disable the callback.\n@return 0 on success, -1 on failure."]
    pub fn evbuffer_cb_clear_flags(
        buffer: *mut evbuffer,
        cb: *mut evbuffer_cb_entry,
        flags: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Makes the data at the beginning of an evbuffer contiguous.\n\n@param buf the evbuffer to make contiguous\n@param size the number of bytes to make contiguous, or -1 to make the\nentire buffer contiguous.\n@return a pointer to the contiguous memory array, or NULL if param size\nrequested more data than is present in the buffer."]
    pub fn evbuffer_pullup(buf: *mut evbuffer, size: isize) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
    #[doc = "Prepends data to the beginning of the evbuffer\n\n@param buf the evbuffer to which to prepend data\n@param data a pointer to the memory to prepend\n@param size the number of bytes to prepend\n@return 0 if successful, or -1 otherwise"]
    pub fn evbuffer_prepend(
        buf: *mut evbuffer,
        data: *const ::std::os::raw::c_void,
        size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Prepends all data from the src evbuffer to the beginning of the dst\nevbuffer.\n\n@param dst the evbuffer to which to prepend data\n@param src the evbuffer to prepend; it will be emptied as a result\n@return 0 if successful, or -1 otherwise"]
    pub fn evbuffer_prepend_buffer(dst: *mut evbuffer, src: *mut evbuffer)
        -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Prevent calls that modify an evbuffer from succeeding. A buffer may\nfrozen at the front, at the back, or at both the front and the back.\n\nIf the front of a buffer is frozen, operations that drain data from\nthe front of the buffer, or that prepend data to the buffer, will\nfail until it is unfrozen.   If the back a buffer is frozen, operations\nthat append data from the buffer will fail until it is unfrozen.\n\n@param buf The buffer to freeze\n@param at_front If true, we freeze the front of the buffer.  If false,\nwe freeze the back.\n@return 0 on success, -1 on failure."]
    pub fn evbuffer_freeze(
        buf: *mut evbuffer,
        at_front: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Re-enable calls that modify an evbuffer.\n\n@param buf The buffer to un-freeze\n@param at_front If true, we unfreeze the front of the buffer.  If false,\nwe unfreeze the back.\n@return 0 on success, -1 on failure."]
    pub fn evbuffer_unfreeze(
        buf: *mut evbuffer,
        at_front: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Force all the callbacks on an evbuffer to be run, not immediately after\nthe evbuffer is altered, but instead from inside the event loop.\n\nThis can be used to serialize all the callbacks to a single thread\nof execution."]
    pub fn evbuffer_defer_callbacks(
        buffer: *mut evbuffer,
        base: *mut event_base,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Append data from 1 or more iovec's to an evbuffer\n\nCalculates the number of bytes needed for an iovec structure and guarantees\nall data will fit into a single chain. Can be used in lieu of functionality\nwhich calls evbuffer_add() constantly before being used to increase\nperformance.\n\n@param buffer the destination buffer\n@param vec the source iovec\n@param n_vec the number of iovec structures.\n@return the number of bytes successfully written to the output buffer."]
    pub fn evbuffer_add_iovec(
        buffer: *mut evbuffer,
        vec: *mut iovec,
        n_vec: ::std::os::raw::c_int,
    ) -> usize;
}
extern "C" {
    #[doc = "Obsolete alias for evbuffer_readln(buffer, NULL, EVBUFFER_EOL_ANY).\n\n@deprecated This function is deprecated because its behavior is not correct\nfor almost any protocol, and also because it's wholly subsumed by\nevbuffer_readln().\n\n@param buffer the evbuffer to read from\n@return pointer to a single line, or NULL if an error occurred"]
    pub fn evbuffer_readline(buffer: *mut evbuffer) -> *mut ::std::os::raw::c_char;
}
#[doc = " Type definition for a callback that is invoked whenever data is added or\nremoved from an evbuffer.\n\nAn evbuffer may have one or more callbacks set at a time.  The order\nin which they are executed is undefined.\n\nA callback function may add more callbacks, or remove itself from the\nlist of callbacks, or add or remove data from the buffer.  It may not\nremove another callback from the list.\n\nIf a callback adds or removes data from the buffer or from another\nbuffer, this can cause a recursive invocation of your callback or\nother callbacks.  If you ask for an infinite loop, you might just get\none: watch out!\n\n@param buffer the buffer whose size has changed\n@param old_len the previous length of the buffer\n@param new_len the current length of the buffer\n@param arg a pointer to user data"]
pub type evbuffer_cb = ::std::option::Option<
    unsafe extern "C" fn(
        buffer: *mut evbuffer,
        old_len: usize,
        new_len: usize,
        arg: *mut ::std::os::raw::c_void,
    ),
>;
extern "C" {
    #[doc = "Replace all callbacks on an evbuffer with a single new callback, or\nremove them.\n\nSubsequent calls to evbuffer_setcb() replace callbacks set by previous\ncalls.  Setting the callback to NULL removes any previously set callback.\n\n@deprecated This function is deprecated because it clears all previous\ncallbacks set on the evbuffer, which can cause confusing behavior if\nmultiple parts of the code all want to add their own callbacks on a\nbuffer.  Instead, use evbuffer_add(), evbuffer_del(), and\nevbuffer_setflags() to manage your own evbuffer callbacks without\ninterfering with callbacks set by others.\n\n@param buffer the evbuffer to be monitored\n@param cb the callback function to invoke when the evbuffer is modified,\nor NULL to remove all callbacks.\n@param cbarg an argument to be provided to the callback function\n@return 0 if successful, or -1 on error"]
    pub fn evbuffer_setcb(
        buffer: *mut evbuffer,
        cb: evbuffer_cb,
        cbarg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Find a string within an evbuffer.\n\n@param buffer the evbuffer to be searched\n@param what the string to be searched for\n@param len the length of the search string\n@return a pointer to the beginning of the search string, or NULL if the search failed."]
    pub fn evbuffer_find(
        buffer: *mut evbuffer,
        what: *const ::std::os::raw::c_uchar,
        len: usize,
    ) -> *mut ::std::os::raw::c_uchar;
}
#[doc = "A read or write callback for a bufferevent.\n\nThe read callback is triggered when new data arrives in the input\nbuffer and the amount of readable data exceed the low watermark\nwhich is 0 by default.\n\nThe write callback is triggered if the write buffer has been\nexhausted or fell below its low watermark.\n\n@param bev the bufferevent that triggered the callback\n@param ctx the user-specified context for this bufferevent"]
pub type bufferevent_data_cb = ::std::option::Option<
    unsafe extern "C" fn(bev: *mut bufferevent, ctx: *mut ::std::os::raw::c_void),
>;
#[doc = "An event/error callback for a bufferevent.\n\nThe event callback is triggered if either an EOF condition or another\nunrecoverable error was encountered.\n\nFor bufferevents with deferred callbacks, this is a bitwise OR of all errors\nthat have happened on the bufferevent since the last callback invocation.\n\n@param bev the bufferevent for which the error condition was reached\n@param what a conjunction of flags: BEV_EVENT_READING or BEV_EVENT_WRITING\nto indicate if the error was encountered on the read or write path,\nand one of the following flags: BEV_EVENT_EOF, BEV_EVENT_ERROR,\nBEV_EVENT_TIMEOUT, BEV_EVENT_CONNECTED.\n\n@param ctx the user-specified context for this bufferevent"]
pub type bufferevent_event_cb = ::std::option::Option<
    unsafe extern "C" fn(
        bev: *mut bufferevent,
        what: ::std::os::raw::c_short,
        ctx: *mut ::std::os::raw::c_void,
    ),
>;
#[doc = " If set, we close the underlying file\n descriptor/bufferevent/whatever when this bufferevent is freed."]
pub const bufferevent_options_BEV_OPT_CLOSE_ON_FREE: bufferevent_options = 1;
#[doc = " If set, and threading is enabled, operations on this bufferevent\n are protected by a lock"]
pub const bufferevent_options_BEV_OPT_THREADSAFE: bufferevent_options = 2;
#[doc = " If set, callbacks are run deferred in the event loop."]
pub const bufferevent_options_BEV_OPT_DEFER_CALLBACKS: bufferevent_options = 4;
#[doc = " If set, callbacks are executed without locks being held on the\n bufferevent.  This option currently requires that\n BEV_OPT_DEFER_CALLBACKS also be set; a future version of Libevent\n might remove the requirement."]
pub const bufferevent_options_BEV_OPT_UNLOCK_CALLBACKS: bufferevent_options = 8;
#[doc = " Options that can be specified when creating a bufferevent"]
pub type bufferevent_options = ::std::os::raw::c_uint;
extern "C" {
    #[doc = "Create a new socket bufferevent over an existing socket.\n\n@param base the event base to associate with the new bufferevent.\n@param fd the file descriptor from which data is read and written to.\nThis file descriptor is not allowed to be a pipe(2).\nIt is safe to set the fd to -1, so long as you later\nset it with bufferevent_setfd or bufferevent_socket_connect().\n@param options Zero or more BEV_OPT_* flags\n@return a pointer to a newly allocated bufferevent struct, or NULL if an\nerror occurred\n@see bufferevent_free()"]
    pub fn bufferevent_socket_new(
        base: *mut event_base,
        fd: ::std::os::raw::c_int,
        options: ::std::os::raw::c_int,
    ) -> *mut bufferevent;
}
extern "C" {
    #[doc = "Launch a connect() attempt with a socket-based bufferevent.\n\nWhen the connect succeeds, the eventcb will be invoked with\nBEV_EVENT_CONNECTED set.\n\nIf the bufferevent does not already have a socket set, we allocate a new\nsocket here and make it nonblocking before we begin.\n\nIf no address is provided, we assume that the socket is already connecting,\nand configure the bufferevent so that a BEV_EVENT_CONNECTED event will be\nyielded when it is done connecting.\n\n@param bufev an existing bufferevent allocated with\nbufferevent_socket_new().\n@param addr the address we should connect to\n@param socklen The length of the address\n@return 0 on success, -1 on failure."]
    pub fn bufferevent_socket_connect(
        arg1: *mut bufferevent,
        arg2: *const sockaddr,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct evdns_base {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = "Resolve the hostname 'hostname' and connect to it as with\nbufferevent_socket_connect().\n\n@param bufev An existing bufferevent allocated with bufferevent_socket_new()\n@param evdns_base Optionally, an evdns_base to use for resolving hostnames\nasynchronously. May be set to NULL for a blocking resolve.\n@param family A preferred address family to resolve addresses to, or\nAF_UNSPEC for no preference.  Only AF_INET, AF_INET6, and AF_UNSPEC are\nsupported.\n@param hostname The hostname to resolve; see below for notes on recognized\nformats\n@param port The port to connect to on the resolved address.\n@return 0 if successful, -1 on failure.\n\nRecognized hostname formats are:\n\nwww.example.com\t(hostname)\n1.2.3.4\t\t(ipv4address)\n::1\t\t(ipv6address)\n[::1]\t\t([ipv6address])\n\nPerformance note: If you do not provide an evdns_base, this function\nmay block while it waits for a DNS response.\t This is probably not\nwhat you want."]
    pub fn bufferevent_socket_connect_hostname(
        arg1: *mut bufferevent,
        arg2: *mut evdns_base,
        arg3: ::std::os::raw::c_int,
        arg4: *const ::std::os::raw::c_char,
        arg5: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Return the error code for the last failed DNS lookup attempt made by\nbufferevent_socket_connect_hostname().\n\n@param bev The bufferevent object.\n@return DNS error code.\n@see evutil_gai_strerror()"]
    pub fn bufferevent_socket_get_dns_error(bev: *mut bufferevent) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Assign a bufferevent to a specific event_base.\n\nNOTE that only socket bufferevents support this function.\n\n@param base an event_base returned by event_init()\n@param bufev a bufferevent struct returned by bufferevent_new()\nor bufferevent_socket_new()\n@return 0 if successful, or -1 if an error occurred\n@see bufferevent_new()"]
    pub fn bufferevent_base_set(
        base: *mut event_base,
        bufev: *mut bufferevent,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Return the event_base used by a bufferevent"]
    pub fn bufferevent_get_base(bev: *mut bufferevent) -> *mut event_base;
}
extern "C" {
    #[doc = "Assign a priority to a bufferevent.\n\nOnly supported for socket bufferevents.\n\n@param bufev a bufferevent struct\n@param pri the priority to be assigned\n@return 0 if successful, or -1 if an error occurred"]
    pub fn bufferevent_priority_set(
        bufev: *mut bufferevent,
        pri: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Return the priority of a bufferevent.\n\nOnly supported for socket bufferevents"]
    pub fn bufferevent_get_priority(bufev: *const bufferevent) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Deallocate the storage associated with a bufferevent structure.\n\nIf there is pending data to write on the bufferevent, it probably won't be\nflushed before the bufferevent is freed.\n\n@param bufev the bufferevent structure to be freed."]
    pub fn bufferevent_free(bufev: *mut bufferevent);
}
extern "C" {
    #[doc = "Changes the callbacks for a bufferevent.\n\n@param bufev the bufferevent object for which to change callbacks\n@param readcb callback to invoke when there is data to be read, or NULL if\nno callback is desired\n@param writecb callback to invoke when the file descriptor is ready for\nwriting, or NULL if no callback is desired\n@param eventcb callback to invoke when there is an event on the file\ndescriptor\n@param cbarg an argument that will be supplied to each of the callbacks\n(readcb, writecb, and errorcb)\n@see bufferevent_new()"]
    pub fn bufferevent_setcb(
        bufev: *mut bufferevent,
        readcb: bufferevent_data_cb,
        writecb: bufferevent_data_cb,
        eventcb: bufferevent_event_cb,
        cbarg: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = "Retrieves the callbacks for a bufferevent.\n\n@param bufev the bufferevent to examine.\n@param readcb_ptr if readcb_ptr is nonnull, *readcb_ptr is set to the current\nread callback for the bufferevent.\n@param writecb_ptr if writecb_ptr is nonnull, *writecb_ptr is set to the\ncurrent write callback for the bufferevent.\n@param eventcb_ptr if eventcb_ptr is nonnull, *eventcb_ptr is set to the\ncurrent event callback for the bufferevent.\n@param cbarg_ptr if cbarg_ptr is nonnull, *cbarg_ptr is set to the current\ncallback argument for the bufferevent.\n@see buffervent_setcb()"]
    pub fn bufferevent_getcb(
        bufev: *mut bufferevent,
        readcb_ptr: *mut bufferevent_data_cb,
        writecb_ptr: *mut bufferevent_data_cb,
        eventcb_ptr: *mut bufferevent_event_cb,
        cbarg_ptr: *mut *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = "Changes the file descriptor on which the bufferevent operates.\nNot supported for all bufferevent types.\n\n@param bufev the bufferevent object for which to change the file descriptor\n@param fd the file descriptor to operate on"]
    pub fn bufferevent_setfd(
        bufev: *mut bufferevent,
        fd: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Returns the file descriptor associated with a bufferevent, or -1 if\nno file descriptor is associated with the bufferevent."]
    pub fn bufferevent_getfd(bufev: *mut bufferevent) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Returns the underlying bufferevent associated with a bufferevent (if\nthe bufferevent is a wrapper), or NULL if there is no underlying bufferevent."]
    pub fn bufferevent_get_underlying(bufev: *mut bufferevent) -> *mut bufferevent;
}
extern "C" {
    #[doc = "Write data to a bufferevent buffer.\n\nThe bufferevent_write() function can be used to write data to the file\ndescriptor.  The data is appended to the output buffer and written to the\ndescriptor automatically as it becomes available for writing.\n\n@param bufev the bufferevent to be written to\n@param data a pointer to the data to be written\n@param size the length of the data, in bytes\n@return 0 if successful, or -1 if an error occurred\n@see bufferevent_write_buffer()"]
    pub fn bufferevent_write(
        bufev: *mut bufferevent,
        data: *const ::std::os::raw::c_void,
        size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Write data from an evbuffer to a bufferevent buffer.\tThe evbuffer is\nbeing drained as a result.\n\n@param bufev the bufferevent to be written to\n@param buf the evbuffer to be written\n@return 0 if successful, or -1 if an error occurred\n@see bufferevent_write()"]
    pub fn bufferevent_write_buffer(
        bufev: *mut bufferevent,
        buf: *mut evbuffer,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Read data from a bufferevent buffer.\n\nThe bufferevent_read() function is used to read data from the input buffer.\n\n@param bufev the bufferevent to be read from\n@param data pointer to a buffer that will store the data\n@param size the size of the data buffer, in bytes\n@return the amount of data read, in bytes."]
    pub fn bufferevent_read(
        bufev: *mut bufferevent,
        data: *mut ::std::os::raw::c_void,
        size: usize,
    ) -> usize;
}
extern "C" {
    #[doc = "Read data from a bufferevent buffer into an evbuffer.\t This avoids\nmemory copies.\n\n@param bufev the bufferevent to be read from\n@param buf the evbuffer to which to add data\n@return 0 if successful, or -1 if an error occurred."]
    pub fn bufferevent_read_buffer(
        bufev: *mut bufferevent,
        buf: *mut evbuffer,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Returns the input buffer.\n\nThe user MUST NOT set the callback on this buffer.\n\n@param bufev the bufferevent from which to get the evbuffer\n@return the evbuffer object for the input buffer"]
    pub fn bufferevent_get_input(bufev: *mut bufferevent) -> *mut evbuffer;
}
extern "C" {
    #[doc = "Returns the output buffer.\n\nThe user MUST NOT set the callback on this buffer.\n\nWhen filters are being used, the filters need to be manually\ntriggered if the output buffer was manipulated.\n\n@param bufev the bufferevent from which to get the evbuffer\n@return the evbuffer object for the output buffer"]
    pub fn bufferevent_get_output(bufev: *mut bufferevent) -> *mut evbuffer;
}
extern "C" {
    #[doc = "Enable a bufferevent.\n\n@param bufev the bufferevent to be enabled\n@param event any combination of EV_READ | EV_WRITE.\n@return 0 if successful, or -1 if an error occurred\n@see bufferevent_disable()"]
    pub fn bufferevent_enable(
        bufev: *mut bufferevent,
        event: ::std::os::raw::c_short,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Disable a bufferevent.\n\n@param bufev the bufferevent to be disabled\n@param event any combination of EV_READ | EV_WRITE.\n@return 0 if successful, or -1 if an error occurred\n@see bufferevent_enable()"]
    pub fn bufferevent_disable(
        bufev: *mut bufferevent,
        event: ::std::os::raw::c_short,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Return the events that are enabled on a given bufferevent.\n\n@param bufev the bufferevent to inspect\n@return A combination of EV_READ | EV_WRITE"]
    pub fn bufferevent_get_enabled(bufev: *mut bufferevent) -> ::std::os::raw::c_short;
}
extern "C" {
    #[doc = "Set the read and write timeout for a bufferevent.\n\nA bufferevent's timeout will fire the first time that the indicated\namount of time has elapsed since a successful read or write operation,\nduring which the bufferevent was trying to read or write.\n\n(In other words, if reading or writing is disabled, or if the\nbufferevent's read or write operation has been suspended because\nthere's no data to write, or not enough bandwidth, or so on, the\ntimeout isn't active.  The timeout only becomes active when we we're\nwilling to actually read or write.)\n\nCalling bufferevent_enable or setting a timeout for a bufferevent\nwhose timeout is already pending resets its timeout.\n\nIf the timeout elapses, the corresponding operation (EV_READ or\nEV_WRITE) becomes disabled until you re-enable it again.  The\nbufferevent's event callback is called with the\nBEV_EVENT_TIMEOUT|BEV_EVENT_READING or\nBEV_EVENT_TIMEOUT|BEV_EVENT_WRITING.\n\n@param bufev the bufferevent to be modified\n@param timeout_read the read timeout, or NULL\n@param timeout_write the write timeout, or NULL"]
    pub fn bufferevent_set_timeouts(
        bufev: *mut bufferevent,
        timeout_read: *const timeval,
        timeout_write: *const timeval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Sets the watermarks for read and write events.\n\nOn input, a bufferevent does not invoke the user read callback unless\nthere is at least low watermark data in the buffer.\tIf the read buffer\nis beyond the high watermark, the bufferevent stops reading from the network.\nBut be aware that bufferevent input/read buffer can overrun high watermark\nlimit (typical example is openssl bufferevent), so you should not relay in\nthis.\n\nOn output, the user write callback is invoked whenever the buffered data\nfalls below the low watermark.  Filters that write to this bufev will try\nnot to write more bytes to this buffer than the high watermark would allow,\nexcept when flushing.\n\n@param bufev the bufferevent to be modified\n@param events EV_READ, EV_WRITE or both\n@param lowmark the lower watermark to set\n@param highmark the high watermark to set"]
    pub fn bufferevent_setwatermark(
        bufev: *mut bufferevent,
        events: ::std::os::raw::c_short,
        lowmark: usize,
        highmark: usize,
    );
}
extern "C" {
    #[doc = "Retrieves the watermarks for read or write events.\nReturns non-zero if events contains not only EV_READ or EV_WRITE.\nReturns zero if events equal EV_READ or EV_WRITE\n\n@param bufev the bufferevent to be examined\n@param events EV_READ or EV_WRITE\n@param lowmark receives the lower watermark if not NULL\n@param highmark receives the high watermark if not NULL"]
    pub fn bufferevent_getwatermark(
        bufev: *mut bufferevent,
        events: ::std::os::raw::c_short,
        lowmark: *mut usize,
        highmark: *mut usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Acquire the lock on a bufferevent.  Has no effect if locking was not\nenabled with BEV_OPT_THREADSAFE."]
    pub fn bufferevent_lock(bufev: *mut bufferevent);
}
extern "C" {
    #[doc = "Release the lock on a bufferevent.  Has no effect if locking was not\nenabled with BEV_OPT_THREADSAFE."]
    pub fn bufferevent_unlock(bufev: *mut bufferevent);
}
extern "C" {
    #[doc = " Public interface to manually increase the reference count of a bufferevent\n this is useful in situations where a user may reference the bufferevent\n somewhere else (unknown to libevent)\n\n @param bufev the bufferevent to increase the refcount on\n"]
    pub fn bufferevent_incref(bufev: *mut bufferevent);
}
extern "C" {
    #[doc = " Public interface to manually decrement the reference count of a bufferevent\n\n Warning: make sure you know what you're doing. This is mainly used in\n conjunction with bufferevent_incref(). This will free up all data associated\n with a bufferevent if the reference count hits 0.\n\n @param bufev the bufferevent to decrement the refcount on\n\n @return 1 if the bufferevent was freed, otherwise 0 (still referenced)"]
    pub fn bufferevent_decref(bufev: *mut bufferevent) -> ::std::os::raw::c_int;
}
#[doc = " usually set when processing data"]
pub const bufferevent_flush_mode_BEV_NORMAL: bufferevent_flush_mode = 0;
#[doc = " want to checkpoint all data sent."]
pub const bufferevent_flush_mode_BEV_FLUSH: bufferevent_flush_mode = 1;
#[doc = " encountered EOF on read or done sending data"]
pub const bufferevent_flush_mode_BEV_FINISHED: bufferevent_flush_mode = 2;
#[doc = "Flags that can be passed into filters to let them know how to\ndeal with the incoming data."]
pub type bufferevent_flush_mode = ::std::os::raw::c_uint;
extern "C" {
    #[doc = "Triggers the bufferevent to produce more data if possible.\n\n@param bufev the bufferevent object\n@param iotype either EV_READ or EV_WRITE or both.\n@param mode either BEV_NORMAL or BEV_FLUSH or BEV_FINISHED\n@return -1 on failure, 0 if no data was produces, 1 if data was produced"]
    pub fn bufferevent_flush(
        bufev: *mut bufferevent,
        iotype: ::std::os::raw::c_short,
        mode: bufferevent_flush_mode,
    ) -> ::std::os::raw::c_int;
}
#[doc = " trigger the callback regardless of the watermarks"]
pub const bufferevent_trigger_options_BEV_TRIG_IGNORE_WATERMARKS: bufferevent_trigger_options =
    65536;
#[doc = " defer even if the callbacks are not"]
pub const bufferevent_trigger_options_BEV_TRIG_DEFER_CALLBACKS: bufferevent_trigger_options = 4;
#[doc = "Flags for bufferevent_trigger(_event) that modify when and how to trigger\nthe callback."]
pub type bufferevent_trigger_options = ::std::os::raw::c_uint;
extern "C" {
    #[doc = "Triggers bufferevent data callbacks.\n\nThe function will honor watermarks unless options contain\nBEV_TRIG_IGNORE_WATERMARKS. If the options contain BEV_OPT_DEFER_CALLBACKS,\nthe callbacks are deferred.\n\n@param bufev the bufferevent object\n@param iotype either EV_READ or EV_WRITE or both.\n@param options"]
    pub fn bufferevent_trigger(
        bufev: *mut bufferevent,
        iotype: ::std::os::raw::c_short,
        options: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = "Triggers the bufferevent event callback.\n\nIf the options contain BEV_OPT_DEFER_CALLBACKS, the callbacks are deferred.\n\n@param bufev the bufferevent object\n@param what the flags to pass onto the event callback\n@param options"]
    pub fn bufferevent_trigger_event(
        bufev: *mut bufferevent,
        what: ::std::os::raw::c_short,
        options: ::std::os::raw::c_int,
    );
}
#[doc = " everything is okay"]
pub const bufferevent_filter_result_BEV_OK: bufferevent_filter_result = 0;
#[doc = " the filter needs to read more data before output"]
pub const bufferevent_filter_result_BEV_NEED_MORE: bufferevent_filter_result = 1;
#[doc = " the filter encountered a critical error, no further data\ncan be processed."]
pub const bufferevent_filter_result_BEV_ERROR: bufferevent_filter_result = 2;
#[doc = "@name Filtering support\n\n@{\n/\n/**\nValues that filters can return."]
pub type bufferevent_filter_result = ::std::os::raw::c_uint;
#[doc = " A callback function to implement a filter for a bufferevent.\n\n@param src An evbuffer to drain data from.\n@param dst An evbuffer to add data to.\n@param limit A suggested upper bound of bytes to write to dst.\nThe filter may ignore this value, but doing so means that\nit will overflow the high-water mark associated with dst.\n-1 means \"no limit\".\n@param mode Whether we should write data as may be convenient\n(BEV_NORMAL), or flush as much data as we can (BEV_FLUSH),\nor flush as much as we can, possibly including an end-of-stream\nmarker (BEV_FINISH).\n@param ctx A user-supplied pointer.\n\n@return BEV_OK if we wrote some data; BEV_NEED_MORE if we can't\nproduce any more output until we get some input; and BEV_ERROR\non an error."]
pub type bufferevent_filter_cb = ::std::option::Option<
    unsafe extern "C" fn(
        src: *mut evbuffer,
        dst: *mut evbuffer,
        dst_limit: isize,
        mode: bufferevent_flush_mode,
        ctx: *mut ::std::os::raw::c_void,
    ) -> bufferevent_filter_result,
>;
extern "C" {
    #[doc = "Allocate a new filtering bufferevent on top of an existing bufferevent.\n\n@param underlying the underlying bufferevent.\n@param input_filter The filter to apply to data we read from the underlying\nbufferevent\n@param output_filter The filer to apply to data we write to the underlying\nbufferevent\n@param options A bitfield of bufferevent options.\n@param free_context A function to use to free the filter context when\nthis bufferevent is freed.\n@param ctx A context pointer to pass to the filter functions."]
    pub fn bufferevent_filter_new(
        underlying: *mut bufferevent,
        input_filter: bufferevent_filter_cb,
        output_filter: bufferevent_filter_cb,
        options: ::std::os::raw::c_int,
        free_context: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void),
        >,
        ctx: *mut ::std::os::raw::c_void,
    ) -> *mut bufferevent;
}
extern "C" {
    #[doc = "Allocate a pair of linked bufferevents.  The bufferevents behave as would\ntwo bufferevent_sock instances connected to opposite ends of a\nsocketpair(), except that no internal socketpair is allocated.\n\n@param base The event base to associate with the socketpair.\n@param options A set of options for this bufferevent\n@param pair A pointer to an array to hold the two new bufferevent objects.\n@return 0 on success, -1 on failure."]
    pub fn bufferevent_pair_new(
        base: *mut event_base,
        options: ::std::os::raw::c_int,
        pair: *mut *mut bufferevent,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Given one bufferevent returned by bufferevent_pair_new(), returns the\nother one if it still exists.  Otherwise returns NULL."]
    pub fn bufferevent_pair_get_partner(bev: *mut bufferevent) -> *mut bufferevent;
}
#[doc = "Abstract type used to configure rate-limiting on a bufferevent or a group\nof bufferevents."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ev_token_bucket_cfg {
    _unused: [u8; 0],
}
#[doc = "A group of bufferevents which are configured to respect the same rate\nlimit."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bufferevent_rate_limit_group {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = "Initialize and return a new object to configure the rate-limiting behavior\nof bufferevents.\n\n@param read_rate The maximum number of bytes to read per tick on\naverage.\n@param read_burst The maximum number of bytes to read in any single tick.\n@param write_rate The maximum number of bytes to write per tick on\naverage.\n@param write_burst The maximum number of bytes to write in any single tick.\n@param tick_len The length of a single tick.\t Defaults to one second.\nAny fractions of a millisecond are ignored.\n\nNote that all rate-limits hare are currently best-effort: future versions\nof Libevent may implement them more tightly."]
    pub fn ev_token_bucket_cfg_new(
        read_rate: usize,
        read_burst: usize,
        write_rate: usize,
        write_burst: usize,
        tick_len: *const timeval,
    ) -> *mut ev_token_bucket_cfg;
}
extern "C" {
    #[doc = " Free all storage held in 'cfg'.\n\nNote: 'cfg' is not currently reference-counted; it is not safe to free it\nuntil no bufferevent is using it."]
    pub fn ev_token_bucket_cfg_free(cfg: *mut ev_token_bucket_cfg);
}
extern "C" {
    #[doc = "Set the rate-limit of a the bufferevent 'bev' to the one specified in\n'cfg'.  If 'cfg' is NULL, disable any per-bufferevent rate-limiting on\n'bev'.\n\nNote that only some bufferevent types currently respect rate-limiting.\nThey are: socket-based bufferevents (normal and IOCP-based), and SSL-based\nbufferevents.\n\nReturn 0 on success, -1 on failure."]
    pub fn bufferevent_set_rate_limit(
        bev: *mut bufferevent,
        cfg: *mut ev_token_bucket_cfg,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Create a new rate-limit group for bufferevents.  A rate-limit group\nconstrains the maximum number of bytes sent and received, in toto,\nby all of its bufferevents.\n\n@param base An event_base to run any necessary timeouts for the group.\nNote that all bufferevents in the group do not necessarily need to share\nthis event_base.\n@param cfg The rate-limit for this group.\n\nNote that all rate-limits hare are currently best-effort: future versions\nof Libevent may implement them more tightly.\n\nNote also that only some bufferevent types currently respect rate-limiting.\nThey are: socket-based bufferevents (normal and IOCP-based), and SSL-based\nbufferevents."]
    pub fn bufferevent_rate_limit_group_new(
        base: *mut event_base,
        cfg: *const ev_token_bucket_cfg,
    ) -> *mut bufferevent_rate_limit_group;
}
extern "C" {
    #[doc = "Change the rate-limiting settings for a given rate-limiting group.\n\nReturn 0 on success, -1 on failure."]
    pub fn bufferevent_rate_limit_group_set_cfg(
        arg1: *mut bufferevent_rate_limit_group,
        arg2: *const ev_token_bucket_cfg,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Change the smallest quantum we're willing to allocate to any single\nbufferevent in a group for reading or writing at a time.\n\nThe rationale is that, because of TCP/IP protocol overheads and kernel\nbehavior, if a rate-limiting group is so tight on bandwidth that you're\nonly willing to send 1 byte per tick per bufferevent, you might instead\nwant to batch up the reads and writes so that you send N bytes per\n1/N of the bufferevents (chosen at random) each tick, so you still wind\nup send 1 byte per tick per bufferevent on average, but you don't send\nso many tiny packets.\n\nThe default min-share is currently 64 bytes.\n\nReturns 0 on success, -1 on failure."]
    pub fn bufferevent_rate_limit_group_set_min_share(
        arg1: *mut bufferevent_rate_limit_group,
        arg2: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Free a rate-limiting group.  The group must have no members when\nthis function is called."]
    pub fn bufferevent_rate_limit_group_free(arg1: *mut bufferevent_rate_limit_group);
}
extern "C" {
    #[doc = "Add 'bev' to the list of bufferevents whose aggregate reading and writing\nis restricted by 'g'.  If 'g' is NULL, remove 'bev' from its current group.\n\nA bufferevent may belong to no more than one rate-limit group at a time.\nIf 'bev' is already a member of a group, it will be removed from its old\ngroup before being added to 'g'.\n\nReturn 0 on success and -1 on failure."]
    pub fn bufferevent_add_to_rate_limit_group(
        bev: *mut bufferevent,
        g: *mut bufferevent_rate_limit_group,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Remove 'bev' from its current rate-limit group (if any)."]
    pub fn bufferevent_remove_from_rate_limit_group(bev: *mut bufferevent)
        -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Set the size limit for single read operation.\n\nSet to 0 for a reasonable default.\n\nReturn 0 on success and -1 on failure."]
    pub fn bufferevent_set_max_single_read(
        bev: *mut bufferevent,
        size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Set the size limit for single write operation.\n\nSet to 0 for a reasonable default.\n\nReturn 0 on success and -1 on failure."]
    pub fn bufferevent_set_max_single_write(
        bev: *mut bufferevent,
        size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the current size limit for single read operation."]
    pub fn bufferevent_get_max_single_read(bev: *mut bufferevent) -> isize;
}
extern "C" {
    #[doc = " Get the current size limit for single write operation."]
    pub fn bufferevent_get_max_single_write(bev: *mut bufferevent) -> isize;
}
extern "C" {
    #[doc = "@name Rate limit inspection\n\nReturn the current read or write bucket size for a bufferevent.\nIf it is not configured with a per-bufferevent ratelimit, return\nEV_SSIZE_MAX.  This function does not inspect the group limit, if any.\nNote that it can return a negative value if the bufferevent has been\nmade to read or write more than its limit.\n\n@{"]
    pub fn bufferevent_get_read_limit(bev: *mut bufferevent) -> isize;
}
extern "C" {
    pub fn bufferevent_get_write_limit(bev: *mut bufferevent) -> isize;
}
extern "C" {
    pub fn bufferevent_get_max_to_read(bev: *mut bufferevent) -> isize;
}
extern "C" {
    pub fn bufferevent_get_max_to_write(bev: *mut bufferevent) -> isize;
}
extern "C" {
    pub fn bufferevent_get_token_bucket_cfg(bev: *const bufferevent) -> *const ev_token_bucket_cfg;
}
extern "C" {
    #[doc = "@name Group Rate limit inspection\n\nReturn the read or write bucket size for a bufferevent rate limit\ngroup.  Note that it can return a negative value if bufferevents in\nthe group have been made to read or write more than their limits.\n\n@{"]
    pub fn bufferevent_rate_limit_group_get_read_limit(
        arg1: *mut bufferevent_rate_limit_group,
    ) -> isize;
}
extern "C" {
    pub fn bufferevent_rate_limit_group_get_write_limit(
        arg1: *mut bufferevent_rate_limit_group,
    ) -> isize;
}
extern "C" {
    #[doc = "@name Rate limit manipulation\n\nSubtract a number of bytes from a bufferevent's read or write bucket.\nThe decrement value can be negative, if you want to manually refill\nthe bucket.\tIf the change puts the bucket above or below zero, the\nbufferevent will resume or suspend reading writing as appropriate.\nThese functions make no change in the buckets for the bufferevent's\ngroup, if any.\n\nReturns 0 on success, -1 on internal error.\n\n@{"]
    pub fn bufferevent_decrement_read_limit(
        bev: *mut bufferevent,
        decr: isize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bufferevent_decrement_write_limit(
        bev: *mut bufferevent,
        decr: isize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "@name Group rate limit manipulation\n\nSubtract a number of bytes from a bufferevent rate-limiting group's\nread or write bucket.  The decrement value can be negative, if you\nwant to manually refill the bucket.\tIf the change puts the bucket\nabove or below zero, the bufferevents in the group will resume or\nsuspend reading writing as appropriate.\n\nReturns 0 on success, -1 on internal error.\n\n@{"]
    pub fn bufferevent_rate_limit_group_decrement_read(
        arg1: *mut bufferevent_rate_limit_group,
        arg2: isize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bufferevent_rate_limit_group_decrement_write(
        arg1: *mut bufferevent_rate_limit_group,
        arg2: isize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Inspect the total bytes read/written on a group.\n\n Set the variable pointed to by total_read_out to the total number of bytes\n ever read on grp, and the variable pointed to by total_written_out to the\n total number of bytes ever written on grp."]
    pub fn bufferevent_rate_limit_group_get_totals(
        grp: *mut bufferevent_rate_limit_group,
        total_read_out: *mut u64,
        total_written_out: *mut u64,
    );
}
extern "C" {
    #[doc = " Reset the total bytes read/written on a group.\n\n Reset the number of bytes read or written on grp as given by\n bufferevent_rate_limit_group_reset_totals()."]
    pub fn bufferevent_rate_limit_group_reset_totals(grp: *mut bufferevent_rate_limit_group);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct event_watermark {
    pub low: usize,
    pub high: usize,
}
#[test]
fn bindgen_test_layout_event_watermark() {
    const UNINIT: ::std::mem::MaybeUninit<event_watermark> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<event_watermark>(),
        16usize,
        concat!("Size of: ", stringify!(event_watermark))
    );
    assert_eq!(
        ::std::mem::align_of::<event_watermark>(),
        8usize,
        concat!("Alignment of ", stringify!(event_watermark))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).low) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(event_watermark),
            "::",
            stringify!(low)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).high) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(event_watermark),
            "::",
            stringify!(high)
        )
    );
}
#[doc = "An opaque type for handling buffered IO\n\n@see event2/bufferevent.h"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bufferevent {
    #[doc = " Event base for which this bufferevent was created."]
    pub ev_base: *mut event_base,
    #[doc = " Pointer to a table of function pointers to set up how this\nbufferevent behaves."]
    pub be_ops: *mut bufferevent_ops,
    #[doc = " A read event that triggers when a timeout has happened or a socket\nis ready to read data.  Only used by some subtypes of\nbufferevent."]
    pub ev_read: event,
    #[doc = " A write event that triggers when a timeout has happened or a socket\nis ready to write data.  Only used by some subtypes of\nbufferevent."]
    pub ev_write: event,
    #[doc = " An input buffer. Only the bufferevent is allowed to add data to\nthis buffer, though the user is allowed to drain it."]
    pub input: *mut evbuffer,
    #[doc = " An input buffer. Only the bufferevent is allowed to drain data\nfrom this buffer, though the user is allowed to add it."]
    pub output: *mut evbuffer,
    pub wm_read: event_watermark,
    pub wm_write: event_watermark,
    pub readcb: bufferevent_data_cb,
    pub writecb: bufferevent_data_cb,
    pub errorcb: bufferevent_event_cb,
    pub cbarg: *mut ::std::os::raw::c_void,
    pub timeout_read: timeval,
    pub timeout_write: timeval,
    #[doc = " Events that are currently enabled: currently EV_READ and EV_WRITE\nare supported."]
    pub enabled: ::std::os::raw::c_short,
}
#[test]
fn bindgen_test_layout_bufferevent() {
    const UNINIT: ::std::mem::MaybeUninit<bufferevent> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<bufferevent>(),
        392usize,
        concat!("Size of: ", stringify!(bufferevent))
    );
    assert_eq!(
        ::std::mem::align_of::<bufferevent>(),
        8usize,
        concat!("Alignment of ", stringify!(bufferevent))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ev_base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bufferevent),
            "::",
            stringify!(ev_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).be_ops) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(bufferevent),
            "::",
            stringify!(be_ops)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ev_read) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(bufferevent),
            "::",
            stringify!(ev_read)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ev_write) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(bufferevent),
            "::",
            stringify!(ev_write)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).input) as usize - ptr as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(bufferevent),
            "::",
            stringify!(input)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).output) as usize - ptr as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(bufferevent),
            "::",
            stringify!(output)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).wm_read) as usize - ptr as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(bufferevent),
            "::",
            stringify!(wm_read)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).wm_write) as usize - ptr as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(bufferevent),
            "::",
            stringify!(wm_write)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).readcb) as usize - ptr as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(bufferevent),
            "::",
            stringify!(readcb)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).writecb) as usize - ptr as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(bufferevent),
            "::",
            stringify!(writecb)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).errorcb) as usize - ptr as usize },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(bufferevent),
            "::",
            stringify!(errorcb)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cbarg) as usize - ptr as usize },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(bufferevent),
            "::",
            stringify!(cbarg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timeout_read) as usize - ptr as usize },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(bufferevent),
            "::",
            stringify!(timeout_read)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timeout_write) as usize - ptr as usize },
        368usize,
        concat!(
            "Offset of field: ",
            stringify!(bufferevent),
            "::",
            stringify!(timeout_write)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).enabled) as usize - ptr as usize },
        384usize,
        concat!(
            "Offset of field: ",
            stringify!(bufferevent),
            "::",
            stringify!(enabled)
        )
    );
}
extern "C" {
    #[doc = "Create a new bufferevent for an fd.\n\nThis function is deprecated.  Use bufferevent_socket_new and\nbufferevent_set_callbacks instead.\n\nLibevent provides an abstraction on top of the regular event callbacks.\nThis abstraction is called a buffered event.  A buffered event provides\ninput and output buffers that get filled and drained automatically.  The\nuser of a buffered event no longer deals directly with the I/O, but\ninstead is reading from input and writing to output buffers.\n\nOnce initialized, the bufferevent structure can be used repeatedly with\nbufferevent_enable() and bufferevent_disable().\n\nWhen read enabled the bufferevent will try to read from the file descriptor\nand call the read callback.  The write callback is executed whenever the\noutput buffer is drained below the write low watermark, which is 0 by\ndefault.\n\nIf multiple bases are in use, bufferevent_base_set() must be called before\nenabling the bufferevent for the first time.\n\n@deprecated This function is deprecated because it uses the current\nevent base, and as such can be error prone for multithreaded programs.\nUse bufferevent_socket_new() instead.\n\n@param fd the file descriptor from which data is read and written to.\nThis file descriptor is not allowed to be a pipe(2).\n@param readcb callback to invoke when there is data to be read, or NULL if\nno callback is desired\n@param writecb callback to invoke when the file descriptor is ready for\nwriting, or NULL if no callback is desired\n@param errorcb callback to invoke when there is an error on the file\ndescriptor\n@param cbarg an argument that will be supplied to each of the callbacks\n(readcb, writecb, and errorcb)\n@return a pointer to a newly allocated bufferevent struct, or NULL if an\nerror occurred\n@see bufferevent_base_set(), bufferevent_free()"]
    pub fn bufferevent_new(
        fd: ::std::os::raw::c_int,
        readcb: bufferevent_data_cb,
        writecb: bufferevent_data_cb,
        errorcb: bufferevent_event_cb,
        cbarg: *mut ::std::os::raw::c_void,
    ) -> *mut bufferevent;
}
extern "C" {
    #[doc = "Set the read and write timeout for a buffered event.\n\n@param bufev the bufferevent to be modified\n@param timeout_read the read timeout\n@param timeout_write the write timeout"]
    pub fn bufferevent_settimeout(
        bufev: *mut bufferevent,
        timeout_read: ::std::os::raw::c_int,
        timeout_write: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn evtag_init();
}
extern "C" {
    #[doc = "Unmarshals the header and returns the length of the payload\n\n@param evbuf the buffer from which to unmarshal data\n@param ptag a pointer in which the tag id is being stored\n@returns -1 on failure or the number of bytes in the remaining payload."]
    pub fn evtag_unmarshal_header(evbuf: *mut evbuffer, ptag: *mut u32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn evtag_marshal(
        evbuf: *mut evbuffer,
        tag: u32,
        data: *const ::std::os::raw::c_void,
        len: u32,
    );
}
extern "C" {
    pub fn evtag_marshal_buffer(evbuf: *mut evbuffer, tag: u32, data: *mut evbuffer);
}
extern "C" {
    #[doc = "Encode an integer and store it in an evbuffer.\n\nWe encode integers by nybbles; the first nibble contains the number\nof significant nibbles - 1;  this allows us to encode up to 64-bit\nintegers.  This function is byte-order independent.\n\n@param evbuf evbuffer to store the encoded number\n@param number a 32-bit integer"]
    pub fn evtag_encode_int(evbuf: *mut evbuffer, number: u32);
}
extern "C" {
    pub fn evtag_encode_int64(evbuf: *mut evbuffer, number: u64);
}
extern "C" {
    pub fn evtag_marshal_int(evbuf: *mut evbuffer, tag: u32, integer: u32);
}
extern "C" {
    pub fn evtag_marshal_int64(evbuf: *mut evbuffer, tag: u32, integer: u64);
}
extern "C" {
    pub fn evtag_marshal_string(
        buf: *mut evbuffer,
        tag: u32,
        string: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn evtag_marshal_timeval(evbuf: *mut evbuffer, tag: u32, tv: *mut timeval);
}
extern "C" {
    pub fn evtag_unmarshal(
        src: *mut evbuffer,
        ptag: *mut u32,
        dst: *mut evbuffer,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn evtag_peek(evbuf: *mut evbuffer, ptag: *mut u32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn evtag_peek_length(evbuf: *mut evbuffer, plength: *mut u32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn evtag_payload_length(evbuf: *mut evbuffer, plength: *mut u32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn evtag_consume(evbuf: *mut evbuffer) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn evtag_unmarshal_int(
        evbuf: *mut evbuffer,
        need_tag: u32,
        pinteger: *mut u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn evtag_unmarshal_int64(
        evbuf: *mut evbuffer,
        need_tag: u32,
        pinteger: *mut u64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn evtag_unmarshal_fixed(
        src: *mut evbuffer,
        need_tag: u32,
        data: *mut ::std::os::raw::c_void,
        len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn evtag_unmarshal_string(
        evbuf: *mut evbuffer,
        need_tag: u32,
        pstring: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn evtag_unmarshal_timeval(
        evbuf: *mut evbuffer,
        need_tag: u32,
        ptv: *mut timeval,
    ) -> ::std::os::raw::c_int;
}
#[doc = " The callback that contains the results from a lookup.\n - result is one of the DNS_ERR_* values (DNS_ERR_NONE for success)\n - type is either DNS_IPv4_A or DNS_PTR or DNS_IPv6_AAAA\n - count contains the number of addresses of form type\n - ttl is the number of seconds the resolution may be cached for.\n - addresses needs to be cast according to type.  It will be an array of\n   4-byte sequences for ipv4, or an array of 16-byte sequences for ipv6,\n   or a nul-terminated string for PTR."]
pub type evdns_callback_type = ::std::option::Option<
    unsafe extern "C" fn(
        result: ::std::os::raw::c_int,
        type_: ::std::os::raw::c_char,
        count: ::std::os::raw::c_int,
        ttl: ::std::os::raw::c_int,
        addresses: *mut ::std::os::raw::c_void,
        arg: *mut ::std::os::raw::c_void,
    ),
>;
extern "C" {
    #[doc = "Initialize the asynchronous DNS library.\n\nThis function initializes support for non-blocking name resolution by\ncalling evdns_resolv_conf_parse() on UNIX and\nevdns_config_windows_nameservers() on Windows.\n\n@param event_base the event base to associate the dns client with\n@param flags any of EVDNS_BASE_INITIALIZE_NAMESERVERS|\nEVDNS_BASE_DISABLE_WHEN_INACTIVE|EVDNS_BASE_NAMESERVERS_NO_DEFAULT\n@return evdns_base object if successful, or NULL if an error occurred.\n@see evdns_base_free()"]
    pub fn evdns_base_new(
        event_base: *mut event_base,
        initialize_nameservers: ::std::os::raw::c_int,
    ) -> *mut evdns_base;
}
extern "C" {
    #[doc = "Shut down the asynchronous DNS resolver and terminate all active requests.\n\nIf the 'fail_requests' option is enabled, all active requests will return\nan empty result with the error flag set to DNS_ERR_SHUTDOWN. Otherwise,\nthe requests will be silently discarded.\n\n@param evdns_base the evdns base to free\n@param fail_requests if zero, active requests will be aborted; if non-zero,\nactive requests will return DNS_ERR_SHUTDOWN.\n@see evdns_base_new()"]
    pub fn evdns_base_free(base: *mut evdns_base, fail_requests: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = "Remove all hosts entries that have been loaded into the event_base via\nevdns_base_load_hosts or via event_base_resolv_conf_parse.\n\n@param evdns_base the evdns base to remove outdated host addresses from"]
    pub fn evdns_base_clear_host_addresses(base: *mut evdns_base);
}
extern "C" {
    #[doc = "Convert a DNS error code to a string.\n\n@param err the DNS error code\n@return a string containing an explanation of the error code"]
    pub fn evdns_err_to_string(err: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "Add a nameserver.\n\nThe address should be an IPv4 address in network byte order.\nThe type of address is chosen so that it matches in_addr.s_addr.\n\n@param base the evdns_base to which to add the name server\n@param address an IP address in network byte order\n@return 0 if successful, or -1 if an error occurred\n@see evdns_base_nameserver_ip_add()"]
    pub fn evdns_base_nameserver_add(
        base: *mut evdns_base,
        address: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Get the number of configured nameservers.\n\nThis returns the number of configured nameservers (not necessarily the\nnumber of running nameservers).  This is useful for double-checking\nwhether our calls to the various nameserver configuration functions\nhave been successful.\n\n@param base the evdns_base to which to apply this operation\n@return the number of configured nameservers\n@see evdns_base_nameserver_add()"]
    pub fn evdns_base_count_nameservers(base: *mut evdns_base) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Remove all configured nameservers, and suspend all pending resolves.\n\nResolves will not necessarily be re-attempted until evdns_base_resume() is called.\n\n@param base the evdns_base to which to apply this operation\n@return 0 if successful, or -1 if an error occurred\n@see evdns_base_resume()"]
    pub fn evdns_base_clear_nameservers_and_suspend(base: *mut evdns_base)
        -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Resume normal operation and continue any suspended resolve requests.\n\nRe-attempt resolves left in limbo after an earlier call to\nevdns_base_clear_nameservers_and_suspend().\n\n@param base the evdns_base to which to apply this operation\n@return 0 if successful, or -1 if an error occurred\n@see evdns_base_clear_nameservers_and_suspend()"]
    pub fn evdns_base_resume(base: *mut evdns_base) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Add a nameserver by string address.\n\nThis function parses a n IPv4 or IPv6 address from a string and adds it as a\nnameserver.  It supports the following formats:\n- [IPv6Address]:port\n- [IPv6Address]\n- IPv6Address\n- IPv4Address:port\n- IPv4Address\n\nIf no port is specified, it defaults to 53.\n\n@param base the evdns_base to which to apply this operation\n@return 0 if successful, or -1 if an error occurred\n@see evdns_base_nameserver_add()"]
    pub fn evdns_base_nameserver_ip_add(
        base: *mut evdns_base,
        ip_as_string: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Add a nameserver by sockaddr."]
    pub fn evdns_base_nameserver_sockaddr_add(
        base: *mut evdns_base,
        sa: *const sockaddr,
        len: socklen_t,
        flags: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct evdns_request {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = "Lookup an A record for a given name.\n\n@param base the evdns_base to which to apply this operation\n@param name a DNS hostname\n@param flags either 0, or DNS_QUERY_NO_SEARCH to disable searching for this query.\n@param callback a callback function to invoke when the request is completed\n@param ptr an argument to pass to the callback function\n@return an evdns_request object if successful, or NULL if an error occurred.\n@see evdns_resolve_ipv6(), evdns_resolve_reverse(), evdns_resolve_reverse_ipv6(), evdns_cancel_request()"]
    pub fn evdns_base_resolve_ipv4(
        base: *mut evdns_base,
        name: *const ::std::os::raw::c_char,
        flags: ::std::os::raw::c_int,
        callback: evdns_callback_type,
        ptr: *mut ::std::os::raw::c_void,
    ) -> *mut evdns_request;
}
extern "C" {
    #[doc = "Lookup an AAAA record for a given name.\n\n@param base the evdns_base to which to apply this operation\n@param name a DNS hostname\n@param flags either 0, or DNS_QUERY_NO_SEARCH to disable searching for this query.\n@param callback a callback function to invoke when the request is completed\n@param ptr an argument to pass to the callback function\n@return an evdns_request object if successful, or NULL if an error occurred.\n@see evdns_resolve_ipv4(), evdns_resolve_reverse(), evdns_resolve_reverse_ipv6(), evdns_cancel_request()"]
    pub fn evdns_base_resolve_ipv6(
        base: *mut evdns_base,
        name: *const ::std::os::raw::c_char,
        flags: ::std::os::raw::c_int,
        callback: evdns_callback_type,
        ptr: *mut ::std::os::raw::c_void,
    ) -> *mut evdns_request;
}
extern "C" {
    #[doc = "Lookup a PTR record for a given IP address.\n\n@param base the evdns_base to which to apply this operation\n@param in an IPv4 address\n@param flags either 0, or DNS_QUERY_NO_SEARCH to disable searching for this query.\n@param callback a callback function to invoke when the request is completed\n@param ptr an argument to pass to the callback function\n@return an evdns_request object if successful, or NULL if an error occurred.\n@see evdns_resolve_reverse_ipv6(), evdns_cancel_request()"]
    pub fn evdns_base_resolve_reverse(
        base: *mut evdns_base,
        in_: *const in_addr,
        flags: ::std::os::raw::c_int,
        callback: evdns_callback_type,
        ptr: *mut ::std::os::raw::c_void,
    ) -> *mut evdns_request;
}
extern "C" {
    #[doc = "Lookup a PTR record for a given IPv6 address.\n\n@param base the evdns_base to which to apply this operation\n@param in an IPv6 address\n@param flags either 0, or DNS_QUERY_NO_SEARCH to disable searching for this query.\n@param callback a callback function to invoke when the request is completed\n@param ptr an argument to pass to the callback function\n@return an evdns_request object if successful, or NULL if an error occurred.\n@see evdns_resolve_reverse_ipv6(), evdns_cancel_request()"]
    pub fn evdns_base_resolve_reverse_ipv6(
        base: *mut evdns_base,
        in_: *const in6_addr,
        flags: ::std::os::raw::c_int,
        callback: evdns_callback_type,
        ptr: *mut ::std::os::raw::c_void,
    ) -> *mut evdns_request;
}
extern "C" {
    #[doc = "Cancels a pending DNS resolution request.\n\n@param base the evdns_base that was used to make the request\n@param req the evdns_request that was returned by calling a resolve function\n@see evdns_base_resolve_ipv4(), evdns_base_resolve_ipv6, evdns_base_resolve_reverse"]
    pub fn evdns_cancel_request(base: *mut evdns_base, req: *mut evdns_request);
}
extern "C" {
    #[doc = "Set the value of a configuration option.\n\nThe currently available configuration options are:\n\nndots, timeout, max-timeouts, max-inflight, attempts, randomize-case,\nbind-to, initial-probe-timeout, getaddrinfo-allow-skew,\nso-rcvbuf, so-sndbuf.\n\nIn versions before Libevent 2.0.3-alpha, the option name needed to end with\na colon.\n\n@param base the evdns_base to which to apply this operation\n@param option the name of the configuration option to be modified\n@param val the value to be set\n@return 0 if successful, or -1 if an error occurred"]
    pub fn evdns_base_set_option(
        base: *mut evdns_base,
        option: *const ::std::os::raw::c_char,
        val: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Parse a resolv.conf file.\n\nThe 'flags' parameter determines what information is parsed from the\nresolv.conf file. See the man page for resolv.conf for the format of this\nfile.\n\nThe following directives are not parsed from the file: sortlist, rotate,\nno-check-names, inet6, debug.\n\nIf this function encounters an error, the possible return values are: 1 =\nfailed to open file, 2 = failed to stat file, 3 = file too large, 4 = out of\nmemory, 5 = short read from file, 6 = no nameservers listed in the file\n\n@param base the evdns_base to which to apply this operation\n@param flags any of DNS_OPTION_NAMESERVERS|DNS_OPTION_SEARCH|DNS_OPTION_MISC|\nDNS_OPTION_HOSTSFILE|DNS_OPTIONS_ALL|DNS_OPTION_NAMESERVERS_NO_DEFAULT\n@param filename the path to the resolv.conf file\n@return 0 if successful, or various positive error codes if an error\noccurred (see above)\n@see resolv.conf(3), evdns_config_windows_nameservers()"]
    pub fn evdns_base_resolv_conf_parse(
        base: *mut evdns_base,
        flags: ::std::os::raw::c_int,
        filename: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Load an /etc/hosts-style file from 'hosts_fname' into 'base'.\n\nIf hosts_fname is NULL, add minimal entries for localhost, and nothing\nelse.\n\nNote that only evdns_getaddrinfo uses the /etc/hosts entries.\n\nThis function does not replace previously loaded hosts entries; to do that,\ncall evdns_base_clear_host_addresses first.\n\nReturn 0 on success, negative on failure."]
    pub fn evdns_base_load_hosts(
        base: *mut evdns_base,
        hosts_fname: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Clear the list of search domains."]
    pub fn evdns_base_search_clear(base: *mut evdns_base);
}
extern "C" {
    #[doc = "Add a domain to the list of search domains\n\n@param domain the domain to be added to the search list"]
    pub fn evdns_base_search_add(base: *mut evdns_base, domain: *const ::std::os::raw::c_char);
}
extern "C" {
    #[doc = "Set the 'ndots' parameter for searches.\n\nSets the number of dots which, when found in a name, causes\nthe first query to be without any search domain.\n\n@param ndots the new ndots parameter"]
    pub fn evdns_base_search_ndots_set(base: *mut evdns_base, ndots: ::std::os::raw::c_int);
}
#[doc = "A callback that is invoked when a log message is generated\n\n@param is_warning indicates if the log message is a 'warning'\n@param msg the content of the log message"]
pub type evdns_debug_log_fn_type = ::std::option::Option<
    unsafe extern "C" fn(is_warning: ::std::os::raw::c_int, msg: *const ::std::os::raw::c_char),
>;
extern "C" {
    #[doc = "Set the callback function to handle DNS log messages.  If this\ncallback is not set, evdns log messages are handled with the regular\nLibevent logging system.\n\n@param fn the callback to be invoked when a log message is generated"]
    pub fn evdns_set_log_fn(fn_: evdns_debug_log_fn_type);
}
extern "C" {
    #[doc = "Set a callback that will be invoked to generate transaction IDs.  By\ndefault, we pick transaction IDs based on the current clock time, which\nis bad for security.\n\n@param fn the new callback, or NULL to use the default.\n\nNOTE: This function has no effect in Libevent 2.0.4-alpha and later,\nsince Libevent now provides its own secure RNG."]
    pub fn evdns_set_transaction_id_fn(fn_: ::std::option::Option<unsafe extern "C" fn() -> u16>);
}
extern "C" {
    #[doc = "Set a callback used to generate random bytes.  By default, we use\nthe same function as passed to evdns_set_transaction_id_fn to generate\nbytes two at a time.  If a function is provided here, it's also used\nto generate transaction IDs.\n\nNOTE: This function has no effect in Libevent 2.0.4-alpha and later,\nsince Libevent now provides its own secure RNG."]
    pub fn evdns_set_random_bytes_fn(
        fn_: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_char, arg2: usize),
        >,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct evdns_server_request {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct evdns_server_question {
    _unused: [u8; 0],
}
#[doc = "A callback to implement a DNS server.  The callback function receives a DNS\nrequest.  It should then optionally add a number of answers to the reply\nusing the evdns_server_request_add_*_reply functions, before calling either\nevdns_server_request_respond to send the reply back, or\nevdns_server_request_drop to decline to answer the request.\n\n@param req A newly received request\n@param user_data A pointer that was passed to\nevdns_add_server_port_with_base()."]
pub type evdns_request_callback_fn_type = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut evdns_server_request, arg2: *mut ::std::os::raw::c_void),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct evdns_server_port {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Create a new DNS server port.\n\n@param base The event base to handle events for the server port.\n@param socket A UDP socket to accept DNS requests.\n@param flags Always 0 for now.\n@param callback A function to invoke whenever we get a DNS request\non the socket.\n@param user_data Data to pass to the callback.\n@return an evdns_server_port structure for this server port or NULL if\nan error occurred."]
    pub fn evdns_add_server_port_with_base(
        base: *mut event_base,
        socket: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_int,
        callback: evdns_request_callback_fn_type,
        user_data: *mut ::std::os::raw::c_void,
    ) -> *mut evdns_server_port;
}
extern "C" {
    #[doc = " Close down a DNS server port, and free associated structures."]
    pub fn evdns_close_server_port(port: *mut evdns_server_port);
}
extern "C" {
    #[doc = " Sets some flags in a reply we're building.\nAllows setting of the AA or RD flags"]
    pub fn evdns_server_request_set_flags(
        req: *mut evdns_server_request,
        flags: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn evdns_server_request_add_reply(
        req: *mut evdns_server_request,
        section: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        type_: ::std::os::raw::c_int,
        dns_class: ::std::os::raw::c_int,
        ttl: ::std::os::raw::c_int,
        datalen: ::std::os::raw::c_int,
        is_name: ::std::os::raw::c_int,
        data: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn evdns_server_request_add_a_reply(
        req: *mut evdns_server_request,
        name: *const ::std::os::raw::c_char,
        n: ::std::os::raw::c_int,
        addrs: *const ::std::os::raw::c_void,
        ttl: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn evdns_server_request_add_aaaa_reply(
        req: *mut evdns_server_request,
        name: *const ::std::os::raw::c_char,
        n: ::std::os::raw::c_int,
        addrs: *const ::std::os::raw::c_void,
        ttl: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn evdns_server_request_add_ptr_reply(
        req: *mut evdns_server_request,
        in_: *mut in_addr,
        inaddr_name: *const ::std::os::raw::c_char,
        hostname: *const ::std::os::raw::c_char,
        ttl: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn evdns_server_request_add_cname_reply(
        req: *mut evdns_server_request,
        name: *const ::std::os::raw::c_char,
        cname: *const ::std::os::raw::c_char,
        ttl: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Send back a response to a DNS request, and free the request structure."]
    pub fn evdns_server_request_respond(
        req: *mut evdns_server_request,
        err: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Free a DNS request without sending back a reply."]
    pub fn evdns_server_request_drop(req: *mut evdns_server_request) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Get the address that made a DNS request."]
    pub fn evdns_server_request_get_requesting_addr(
        req: *mut evdns_server_request,
        sa: *mut sockaddr,
        addr_len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[doc = " Callback for evdns_getaddrinfo."]
pub type evdns_getaddrinfo_cb = ::std::option::Option<
    unsafe extern "C" fn(
        result: ::std::os::raw::c_int,
        res: *mut addrinfo,
        arg: *mut ::std::os::raw::c_void,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct evdns_getaddrinfo_request {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Make a non-blocking getaddrinfo request using the dns_base in 'dns_base'.\n\n If we can answer the request immediately (with an error or not!), then we\n invoke cb immediately and return NULL.  Otherwise we return\n an evdns_getaddrinfo_request and invoke cb later.\n\n When the callback is invoked, we pass as its first argument the error code\n that getaddrinfo would return (or 0 for no error).  As its second argument,\n we pass the evutil_addrinfo structures we found (or NULL on error).  We\n pass 'arg' as the third argument.\n\n Limitations:\n\n - The AI_V4MAPPED and AI_ALL flags are not currently implemented.\n - For ai_socktype, we only handle SOCKTYPE_STREAM, SOCKTYPE_UDP, and 0.\n - For ai_protocol, we only handle IPPROTO_TCP, IPPROTO_UDP, and 0."]
    pub fn evdns_getaddrinfo(
        dns_base: *mut evdns_base,
        nodename: *const ::std::os::raw::c_char,
        servname: *const ::std::os::raw::c_char,
        hints_in: *const addrinfo,
        cb: evdns_getaddrinfo_cb,
        arg: *mut ::std::os::raw::c_void,
    ) -> *mut evdns_getaddrinfo_request;
}
extern "C" {
    pub fn evdns_getaddrinfo_cancel(req: *mut evdns_getaddrinfo_request);
}
extern "C" {
    #[doc = "Retrieve the address of the 'idx'th configured nameserver.\n\n@param base The evdns_base to examine.\n@param idx The index of the nameserver to get the address of.\n@param sa A location to receive the server's address.\n@param len The number of bytes available at sa.\n\n@return the number of bytes written into sa on success.  On failure, returns\n-1 if idx is greater than the number of configured nameservers, or a\nvalue greater than 'len' if len was not high enough."]
    pub fn evdns_base_get_nameserver_addr(
        base: *mut evdns_base,
        idx: ::std::os::raw::c_int,
        sa: *mut sockaddr,
        len: socklen_t,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct evhttp_connection {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct evhttp {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct evhttp_request {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct evhttp_bound_socket {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct evconnlistener {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Create a new HTTP server.\n\n @param base (optional) the event base to receive the HTTP events\n @return a pointer to a newly initialized evhttp server structure or NULL\n   on error\n @see evhttp_free()"]
    pub fn evhttp_new(base: *mut event_base) -> *mut evhttp;
}
extern "C" {
    #[doc = " Binds an HTTP server on the specified address and port.\n\n Can be called multiple times to bind the same http server\n to multiple different ports.\n\n @param http a pointer to an evhttp object\n @param address a string containing the IP address to listen(2) on\n @param port the port number to listen on\n @return 0 on success, -1 on failure.\n @see evhttp_accept_socket()"]
    pub fn evhttp_bind_socket(
        http: *mut evhttp,
        address: *const ::std::os::raw::c_char,
        port: u16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Like evhttp_bind_socket(), but returns a handle for referencing the socket.\n\n The returned pointer is not valid after \\a http is freed.\n\n @param http a pointer to an evhttp object\n @param address a string containing the IP address to listen(2) on\n @param port the port number to listen on\n @return Handle for the socket on success, NULL on failure.\n @see evhttp_bind_socket(), evhttp_del_accept_socket()"]
    pub fn evhttp_bind_socket_with_handle(
        http: *mut evhttp,
        address: *const ::std::os::raw::c_char,
        port: u16,
    ) -> *mut evhttp_bound_socket;
}
extern "C" {
    #[doc = " Makes an HTTP server accept connections on the specified socket.\n\n This may be useful to create a socket and then fork multiple instances\n of an http server, or when a socket has been communicated via file\n descriptor passing in situations where an http servers does not have\n permissions to bind to a low-numbered port.\n\n Can be called multiple times to have the http server listen to\n multiple different sockets.\n\n @param http a pointer to an evhttp object\n @param fd a socket fd that is ready for accepting connections\n @return 0 on success, -1 on failure.\n @see evhttp_bind_socket()"]
    pub fn evhttp_accept_socket(
        http: *mut evhttp,
        fd: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Like evhttp_accept_socket(), but returns a handle for referencing the socket.\n\n The returned pointer is not valid after \\a http is freed.\n\n @param http a pointer to an evhttp object\n @param fd a socket fd that is ready for accepting connections\n @return Handle for the socket on success, NULL on failure.\n @see evhttp_accept_socket(), evhttp_del_accept_socket()"]
    pub fn evhttp_accept_socket_with_handle(
        http: *mut evhttp,
        fd: ::std::os::raw::c_int,
    ) -> *mut evhttp_bound_socket;
}
extern "C" {
    #[doc = " The most low-level evhttp_bind/accept method: takes an evconnlistener, and\n returns an evhttp_bound_socket.  The listener will be freed when the bound\n socket is freed."]
    pub fn evhttp_bind_listener(
        http: *mut evhttp,
        listener: *mut evconnlistener,
    ) -> *mut evhttp_bound_socket;
}
extern "C" {
    #[doc = " Return the listener used to implement a bound socket."]
    pub fn evhttp_bound_socket_get_listener(bound: *mut evhttp_bound_socket)
        -> *mut evconnlistener;
}
pub type evhttp_bound_socket_foreach_fn = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut evhttp_bound_socket, arg2: *mut ::std::os::raw::c_void),
>;
extern "C" {
    #[doc = " Applies the function specified in the first argument to all\n evhttp_bound_sockets associated with \"http\". The user must not\n attempt to free or remove any connections, sockets or listeners\n in the callback \"function\".\n\n @param http pointer to an evhttp object\n @param function function to apply to every bound socket\n @param argument pointer value passed to function for every socket iterated"]
    pub fn evhttp_foreach_bound_socket(
        http: *mut evhttp,
        function: evhttp_bound_socket_foreach_fn,
        argument: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Makes an HTTP server stop accepting connections on the specified socket\n\n This may be useful when a socket has been sent via file descriptor passing\n and is no longer needed by the current process.\n\n If you created this bound socket with evhttp_bind_socket_with_handle or\n evhttp_accept_socket_with_handle, this function closes the fd you provided.\n If you created this bound socket with evhttp_bind_listener, this function\n frees the listener you provided.\n\n \\a bound_socket is an invalid pointer after this call returns.\n\n @param http a pointer to an evhttp object\n @param bound_socket a handle returned by evhttp_{bind,accept}_socket_with_handle\n @see evhttp_bind_socket_with_handle(), evhttp_accept_socket_with_handle()"]
    pub fn evhttp_del_accept_socket(http: *mut evhttp, bound_socket: *mut evhttp_bound_socket);
}
extern "C" {
    #[doc = " Get the raw file descriptor referenced by an evhttp_bound_socket.\n\n @param bound_socket a handle returned by evhttp_{bind,accept}_socket_with_handle\n @return the file descriptor used by the bound socket\n @see evhttp_bind_socket_with_handle(), evhttp_accept_socket_with_handle()"]
    pub fn evhttp_bound_socket_get_fd(
        bound_socket: *mut evhttp_bound_socket,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Free the previously created HTTP server.\n\n Works only if no requests are currently being served.\n\n @param http the evhttp server object to be freed\n @see evhttp_start()"]
    pub fn evhttp_free(http: *mut evhttp);
}
extern "C" {
    #[doc = " XXX Document."]
    pub fn evhttp_set_max_headers_size(http: *mut evhttp, max_headers_size: isize);
}
extern "C" {
    #[doc = " XXX Document."]
    pub fn evhttp_set_max_body_size(http: *mut evhttp, max_body_size: isize);
}
extern "C" {
    #[doc = "Set the value to use for the Content-Type header when none was provided. If\nthe content type string is NULL, the Content-Type header will not be\nautomatically added.\n\n@param http the http server on which to set the default content type\n@param content_type the value for the Content-Type header"]
    pub fn evhttp_set_default_content_type(
        http: *mut evhttp,
        content_type: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = "Sets the what HTTP methods are supported in requests accepted by this\nserver, and passed to user callbacks.\n\nIf not supported they will generate a \"405 Method not allowed\" response.\n\nBy default this includes the following methods: GET, POST, HEAD, PUT, DELETE\n\n@param http the http server on which to set the methods\n@param methods bit mask constructed from evhttp_cmd_type values"]
    pub fn evhttp_set_allowed_methods(http: *mut evhttp, methods: u16);
}
extern "C" {
    #[doc = "Set a callback for a specified URI\n\n@param http the http sever on which to set the callback\n@param path the path for which to invoke the callback\n@param cb the callback function that gets invoked on requesting path\n@param cb_arg an additional context argument for the callback\n@return 0 on success, -1 if the callback existed already, -2 on failure"]
    pub fn evhttp_set_cb(
        http: *mut evhttp,
        path: *const ::std::os::raw::c_char,
        cb: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut evhttp_request, arg2: *mut ::std::os::raw::c_void),
        >,
        cb_arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Removes the callback for a specified URI"]
    pub fn evhttp_del_cb(
        arg1: *mut evhttp,
        arg2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Set a callback for all requests that are not caught by specific callbacks\n\nInvokes the specified callback for all requests that do not match any of\nthe previously specified request paths.  This is catchall for requests not\nspecifically configured with evhttp_set_cb().\n\n@param http the evhttp server object for which to set the callback\n@param cb the callback to invoke for any unmatched requests\n@param arg an context argument for the callback"]
    pub fn evhttp_set_gencb(
        http: *mut evhttp,
        cb: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut evhttp_request, arg2: *mut ::std::os::raw::c_void),
        >,
        arg: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = "Set a callback used to create new bufferevents for connections\nto a given evhttp object.\n\nYou can use this to override the default bufferevent type -- for example,\nto make this evhttp object use SSL bufferevents rather than unencrypted\nones.\n\nNew bufferevents must be allocated with no fd set on them.\n\n@param http the evhttp server object for which to set the callback\n@param cb the callback to invoke for incoming connections\n@param arg an context argument for the callback"]
    pub fn evhttp_set_bevcb(
        http: *mut evhttp,
        cb: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut event_base,
                arg2: *mut ::std::os::raw::c_void,
            ) -> *mut bufferevent,
        >,
        arg: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = "Adds a virtual host to the http server.\n\nA virtual host is a newly initialized evhttp object that has request\ncallbacks set on it via evhttp_set_cb() or evhttp_set_gencb().  It\nmost not have any listing sockets associated with it.\n\nIf the virtual host has not been removed by the time that evhttp_free()\nis called on the main http server, it will be automatically freed, too.\n\nIt is possible to have hierarchical vhosts.  For example: A vhost\nwith the pattern *.example.com may have other vhosts with patterns\nfoo.example.com and bar.example.com associated with it.\n\n@param http the evhttp object to which to add a virtual host\n@param pattern the glob pattern against which the hostname is matched.\nThe match is case insensitive and follows otherwise regular shell\nmatching.\n@param vhost the virtual host to add the regular http server.\n@return 0 on success, -1 on failure\n@see evhttp_remove_virtual_host()"]
    pub fn evhttp_add_virtual_host(
        http: *mut evhttp,
        pattern: *const ::std::os::raw::c_char,
        vhost: *mut evhttp,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Removes a virtual host from the http server.\n\n@param http the evhttp object from which to remove the virtual host\n@param vhost the virtual host to remove from the regular http server.\n@return 0 on success, -1 on failure\n@see evhttp_add_virtual_host()"]
    pub fn evhttp_remove_virtual_host(
        http: *mut evhttp,
        vhost: *mut evhttp,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Add a server alias to an http object. The http object can be a virtual\nhost or the main server.\n\n@param http the evhttp object\n@param alias the alias to add\n@see evhttp_add_remove_alias()"]
    pub fn evhttp_add_server_alias(
        http: *mut evhttp,
        alias: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Remove a server alias from an http object.\n\n@param http the evhttp object\n@param alias the alias to remove\n@see evhttp_add_server_alias()"]
    pub fn evhttp_remove_server_alias(
        http: *mut evhttp,
        alias: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set the timeout for an HTTP request.\n\n @param http an evhttp object\n @param timeout_in_secs the timeout, in seconds"]
    pub fn evhttp_set_timeout(http: *mut evhttp, timeout_in_secs: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Set the timeout for an HTTP request.\n\n @param http an evhttp object\n @param tv the timeout, or NULL"]
    pub fn evhttp_set_timeout_tv(http: *mut evhttp, tv: *const timeval);
}
extern "C" {
    #[doc = " Set connection flags for HTTP server.\n\n @see EVHTTP_SERVER_*\n @return 0 on success, otherwise non zero (for example if flag doesn't\n supported)."]
    pub fn evhttp_set_flags(
        http: *mut evhttp,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Send an HTML error message to the client.\n\n @param req a request object\n @param error the HTTP error code\n @param reason a brief explanation of the error.  If this is NULL, we'll\n    just use the standard meaning of the error code."]
    pub fn evhttp_send_error(
        req: *mut evhttp_request,
        error: ::std::os::raw::c_int,
        reason: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " Send an HTML reply to the client.\n\n The body of the reply consists of the data in databuf.  After calling\n evhttp_send_reply() databuf will be empty, but the buffer is still\n owned by the caller and needs to be deallocated by the caller if\n necessary.\n\n @param req a request object\n @param code the HTTP response code to send\n @param reason a brief message to send with the response code\n @param databuf the body of the response"]
    pub fn evhttp_send_reply(
        req: *mut evhttp_request,
        code: ::std::os::raw::c_int,
        reason: *const ::std::os::raw::c_char,
        databuf: *mut evbuffer,
    );
}
extern "C" {
    #[doc = "Initiate a reply that uses Transfer-Encoding chunked.\n\nThis allows the caller to stream the reply back to the client and is\nuseful when either not all of the reply data is immediately available\nor when sending very large replies.\n\nThe caller needs to supply data chunks with evhttp_send_reply_chunk()\nand complete the reply by calling evhttp_send_reply_end().\n\n@param req a request object\n@param code the HTTP response code to send\n@param reason a brief message to send with the response code"]
    pub fn evhttp_send_reply_start(
        req: *mut evhttp_request,
        code: ::std::os::raw::c_int,
        reason: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = "Send another data chunk as part of an ongoing chunked reply.\n\nThe reply chunk consists of the data in databuf.  After calling\nevhttp_send_reply_chunk() databuf will be empty, but the buffer is\nstill owned by the caller and needs to be deallocated by the caller\nif necessary.\n\n@param req a request object\n@param databuf the data chunk to send as part of the reply."]
    pub fn evhttp_send_reply_chunk(req: *mut evhttp_request, databuf: *mut evbuffer);
}
extern "C" {
    #[doc = "Send another data chunk as part of an ongoing chunked reply.\n\nThe reply chunk consists of the data in databuf.  After calling\nevhttp_send_reply_chunk() databuf will be empty, but the buffer is\nstill owned by the caller and needs to be deallocated by the caller\nif necessary.\n\n@param req a request object\n@param databuf the data chunk to send as part of the reply.\n@param cb callback funcion\n@param call back's argument."]
    pub fn evhttp_send_reply_chunk_with_cb(
        arg1: *mut evhttp_request,
        arg2: *mut evbuffer,
        cb: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut evhttp_connection, arg2: *mut ::std::os::raw::c_void),
        >,
        arg: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = "Complete a chunked reply, freeing the request as appropriate.\n\n@param req a request object"]
    pub fn evhttp_send_reply_end(req: *mut evhttp_request);
}
pub const evhttp_cmd_type_EVHTTP_REQ_GET: evhttp_cmd_type = 1;
pub const evhttp_cmd_type_EVHTTP_REQ_POST: evhttp_cmd_type = 2;
pub const evhttp_cmd_type_EVHTTP_REQ_HEAD: evhttp_cmd_type = 4;
pub const evhttp_cmd_type_EVHTTP_REQ_PUT: evhttp_cmd_type = 8;
pub const evhttp_cmd_type_EVHTTP_REQ_DELETE: evhttp_cmd_type = 16;
pub const evhttp_cmd_type_EVHTTP_REQ_OPTIONS: evhttp_cmd_type = 32;
pub const evhttp_cmd_type_EVHTTP_REQ_TRACE: evhttp_cmd_type = 64;
pub const evhttp_cmd_type_EVHTTP_REQ_CONNECT: evhttp_cmd_type = 128;
pub const evhttp_cmd_type_EVHTTP_REQ_PATCH: evhttp_cmd_type = 256;
#[doc = " The different request types supported by evhttp.  These are as specified\n in RFC2616, except for PATCH which is specified by RFC5789.\n\n By default, only some of these methods are accepted and passed to user\n callbacks; use evhttp_set_allowed_methods() to change which methods\n are allowed."]
pub type evhttp_cmd_type = ::std::os::raw::c_uint;
pub const evhttp_request_kind_EVHTTP_REQUEST: evhttp_request_kind = 0;
pub const evhttp_request_kind_EVHTTP_RESPONSE: evhttp_request_kind = 1;
#[doc = " a request object can represent either a request or a reply"]
pub type evhttp_request_kind = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " Create and return a connection object that can be used to for making HTTP\n requests.  The connection object tries to resolve address and establish the\n connection when it is given an http request object.\n\n @param base the event_base to use for handling the connection\n @param dnsbase the dns_base to use for resolving host names; if not\n     specified host name resolution will block.\n @param bev a bufferevent to use for connecting to the server; if NULL, a\n     socket-based bufferevent will be created.  This buffrevent will be freed\n     when the connection closes.  It must have no fd set on it.\n @param address the address to which to connect\n @param port the port to connect to\n @return an evhttp_connection object that can be used for making requests or\n   NULL on error"]
    pub fn evhttp_connection_base_bufferevent_new(
        base: *mut event_base,
        dnsbase: *mut evdns_base,
        bev: *mut bufferevent,
        address: *const ::std::os::raw::c_char,
        port: u16,
    ) -> *mut evhttp_connection;
}
extern "C" {
    #[doc = " Return the bufferevent that an evhttp_connection is using."]
    pub fn evhttp_connection_get_bufferevent(evcon: *mut evhttp_connection) -> *mut bufferevent;
}
extern "C" {
    #[doc = " Return the HTTP server associated with this connection, or NULL."]
    pub fn evhttp_connection_get_server(evcon: *mut evhttp_connection) -> *mut evhttp;
}
extern "C" {
    #[doc = " Creates a new request object that needs to be filled in with the request\n parameters.  The callback is executed when the request completed or an\n error occurred."]
    pub fn evhttp_request_new(
        cb: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut evhttp_request, arg2: *mut ::std::os::raw::c_void),
        >,
        arg: *mut ::std::os::raw::c_void,
    ) -> *mut evhttp_request;
}
extern "C" {
    #[doc = " Enable delivery of chunks to requestor.\n @param cb will be called after every read of data with the same argument\n           as the completion callback. Will never be called on an empty\n           response. May drain the input buffer; it will be drained\n           automatically on return."]
    pub fn evhttp_request_set_chunked_cb(
        arg1: *mut evhttp_request,
        cb: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut evhttp_request, arg2: *mut ::std::os::raw::c_void),
        >,
    );
}
extern "C" {
    #[doc = " Register callback for additional parsing of request headers.\n @param cb will be called after receiving and parsing the full header.\n It allows analyzing the header and possibly closing the connection\n by returning a value < 0."]
    pub fn evhttp_request_set_header_cb(
        arg1: *mut evhttp_request,
        cb: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut evhttp_request,
                arg2: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
#[doc = " Timeout reached, also @see evhttp_connection_set_timeout()"]
pub const evhttp_request_error_EVREQ_HTTP_TIMEOUT: evhttp_request_error = 0;
#[doc = " EOF reached"]
pub const evhttp_request_error_EVREQ_HTTP_EOF: evhttp_request_error = 1;
#[doc = " Error while reading header, or invalid header"]
pub const evhttp_request_error_EVREQ_HTTP_INVALID_HEADER: evhttp_request_error = 2;
#[doc = " Error encountered while reading or writing"]
pub const evhttp_request_error_EVREQ_HTTP_BUFFER_ERROR: evhttp_request_error = 3;
#[doc = " The evhttp_cancel_request() called on this request."]
pub const evhttp_request_error_EVREQ_HTTP_REQUEST_CANCEL: evhttp_request_error = 4;
#[doc = " Body is greater then evhttp_connection_set_max_body_size()"]
pub const evhttp_request_error_EVREQ_HTTP_DATA_TOO_LONG: evhttp_request_error = 5;
#[doc = " The different error types supported by evhttp\n\n @see evhttp_request_set_error_cb()"]
pub type evhttp_request_error = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " Set a callback for errors\n @see evhttp_request_error for error types.\n\n On error, both the error callback and the regular callback will be called,\n error callback is called before the regular callback."]
    pub fn evhttp_request_set_error_cb(
        arg1: *mut evhttp_request,
        arg2: ::std::option::Option<
            unsafe extern "C" fn(arg1: evhttp_request_error, arg2: *mut ::std::os::raw::c_void),
        >,
    );
}
extern "C" {
    #[doc = " Set a callback to be called on request completion of evhttp_send_* function.\n\n The callback function will be called on the completion of the request after\n the output data has been written and before the evhttp_request object\n is destroyed. This can be useful for tracking resources associated with a\n request (ex: timing metrics).\n\n @param req a request object\n @param cb callback function that will be called on request completion\n @param cb_arg an additional context argument for the callback"]
    pub fn evhttp_request_set_on_complete_cb(
        req: *mut evhttp_request,
        cb: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut evhttp_request, arg2: *mut ::std::os::raw::c_void),
        >,
        cb_arg: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Frees the request object and removes associated events."]
    pub fn evhttp_request_free(req: *mut evhttp_request);
}
extern "C" {
    #[doc = " Create and return a connection object that can be used to for making HTTP\n requests.  The connection object tries to resolve address and establish the\n connection when it is given an http request object.\n\n @param base the event_base to use for handling the connection\n @param dnsbase the dns_base to use for resolving host names; if not\n     specified host name resolution will block.\n @param address the address to which to connect\n @param port the port to connect to\n @return an evhttp_connection object that can be used for making requests or\n   NULL on error"]
    pub fn evhttp_connection_base_new(
        base: *mut event_base,
        dnsbase: *mut evdns_base,
        address: *const ::std::os::raw::c_char,
        port: u16,
    ) -> *mut evhttp_connection;
}
extern "C" {
    #[doc = " Set family hint for DNS requests."]
    pub fn evhttp_connection_set_family(
        evcon: *mut evhttp_connection,
        family: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Set connection flags.\n\n @see EVHTTP_CON_*\n @return 0 on success, otherwise non zero (for example if flag doesn't\n supported)."]
    pub fn evhttp_connection_set_flags(
        evcon: *mut evhttp_connection,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Takes ownership of the request object\n\n Can be used in a request callback to keep onto the request until\n evhttp_request_free() is explicitly called by the user."]
    pub fn evhttp_request_own(req: *mut evhttp_request);
}
extern "C" {
    #[doc = " Returns 1 if the request is owned by the user"]
    pub fn evhttp_request_is_owned(req: *mut evhttp_request) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns the connection object associated with the request or NULL\n\n The user needs to either free the request explicitly or call\n evhttp_send_reply_end()."]
    pub fn evhttp_request_get_connection(req: *mut evhttp_request) -> *mut evhttp_connection;
}
extern "C" {
    #[doc = " Returns the underlying event_base for this connection"]
    pub fn evhttp_connection_get_base(req: *mut evhttp_connection) -> *mut event_base;
}
extern "C" {
    pub fn evhttp_connection_set_max_headers_size(
        evcon: *mut evhttp_connection,
        new_max_headers_size: isize,
    );
}
extern "C" {
    pub fn evhttp_connection_set_max_body_size(
        evcon: *mut evhttp_connection,
        new_max_body_size: isize,
    );
}
extern "C" {
    #[doc = " Frees an http connection"]
    pub fn evhttp_connection_free(evcon: *mut evhttp_connection);
}
extern "C" {
    #[doc = " Disowns a given connection object\n\n Can be used to tell libevent to free the connection object after\n the last request has completed or failed."]
    pub fn evhttp_connection_free_on_completion(evcon: *mut evhttp_connection);
}
extern "C" {
    #[doc = " sets the ip address from which http connections are made"]
    pub fn evhttp_connection_set_local_address(
        evcon: *mut evhttp_connection,
        address: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " sets the local port from which http connections are made"]
    pub fn evhttp_connection_set_local_port(evcon: *mut evhttp_connection, port: u16);
}
extern "C" {
    #[doc = " Sets the timeout in seconds for events related to this connection"]
    pub fn evhttp_connection_set_timeout(
        evcon: *mut evhttp_connection,
        timeout_in_secs: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Sets the timeout for events related to this connection.  Takes a struct\n timeval."]
    pub fn evhttp_connection_set_timeout_tv(evcon: *mut evhttp_connection, tv: *const timeval);
}
extern "C" {
    #[doc = " Sets the delay before retrying requests on this connection. This is only\n used if evhttp_connection_set_retries is used to make the number of retries\n at least one. Each retry after the first is twice as long as the one before\n it."]
    pub fn evhttp_connection_set_initial_retry_tv(
        evcon: *mut evhttp_connection,
        tv: *const timeval,
    );
}
extern "C" {
    #[doc = " Sets the retry limit for this connection - -1 repeats indefinitely"]
    pub fn evhttp_connection_set_retries(
        evcon: *mut evhttp_connection,
        retry_max: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Set a callback for connection close."]
    pub fn evhttp_connection_set_closecb(
        evcon: *mut evhttp_connection,
        arg1: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut evhttp_connection, arg2: *mut ::std::os::raw::c_void),
        >,
        arg2: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Get the remote address and port associated with this connection."]
    pub fn evhttp_connection_get_peer(
        evcon: *mut evhttp_connection,
        address: *mut *mut ::std::os::raw::c_char,
        port: *mut u16,
    );
}
extern "C" {
    #[doc = " Get the remote address associated with this connection.\n extracted from getpeername() OR from nameserver.\n\n @return NULL if getpeername() return non success,\n or connection is not connected,\n otherwise it return pointer to struct sockaddr_storage"]
    pub fn evhttp_connection_get_addr(evcon: *mut evhttp_connection) -> *const sockaddr;
}
extern "C" {
    #[doc = "Make an HTTP request over the specified connection.\n\nThe connection gets ownership of the request.  On failure, the\nrequest object is no longer valid as it has been freed.\n\n@param evcon the evhttp_connection object over which to send the request\n@param req the previously created and configured request object\n@param type the request type EVHTTP_REQ_GET, EVHTTP_REQ_POST, etc.\n@param uri the URI associated with the request\n@return 0 on success, -1 on failure\n@see evhttp_cancel_request()"]
    pub fn evhttp_make_request(
        evcon: *mut evhttp_connection,
        req: *mut evhttp_request,
        type_: evhttp_cmd_type,
        uri: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Cancels a pending HTTP request.\n\nCancels an ongoing HTTP request.  The callback associated with this request\nis not executed and the request object is freed.  If the request is\ncurrently being processed, e.g. it is ongoing, the corresponding\nevhttp_connection object is going to get reset.\n\nA request cannot be canceled if its callback has executed already. A request\nmay be canceled reentrantly from its chunked callback.\n\n@param req the evhttp_request to cancel; req becomes invalid after this call."]
    pub fn evhttp_cancel_request(req: *mut evhttp_request);
}
#[doc = " A structure to hold a parsed URI or Relative-Ref conforming to RFC3986."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct evhttp_uri {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Returns the request URI"]
    pub fn evhttp_request_get_uri(req: *const evhttp_request) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Returns the request URI (parsed)"]
    pub fn evhttp_request_get_evhttp_uri(req: *const evhttp_request) -> *const evhttp_uri;
}
extern "C" {
    #[doc = " Returns the request command"]
    pub fn evhttp_request_get_command(req: *const evhttp_request) -> evhttp_cmd_type;
}
extern "C" {
    pub fn evhttp_request_get_response_code(req: *const evhttp_request) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn evhttp_request_get_response_code_line(
        req: *const evhttp_request,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Returns the input headers"]
    pub fn evhttp_request_get_input_headers(req: *mut evhttp_request) -> *mut evkeyvalq;
}
extern "C" {
    #[doc = " Returns the output headers"]
    pub fn evhttp_request_get_output_headers(req: *mut evhttp_request) -> *mut evkeyvalq;
}
extern "C" {
    #[doc = " Returns the input buffer"]
    pub fn evhttp_request_get_input_buffer(req: *mut evhttp_request) -> *mut evbuffer;
}
extern "C" {
    #[doc = " Returns the output buffer"]
    pub fn evhttp_request_get_output_buffer(req: *mut evhttp_request) -> *mut evbuffer;
}
extern "C" {
    #[doc = " Returns the host associated with the request. If a client sends an absolute\nURI, the host part of that is preferred. Otherwise, the input headers are\nsearched for a Host: header. NULL is returned if no absolute URI or Host:\nheader is provided."]
    pub fn evhttp_request_get_host(req: *mut evhttp_request) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "Finds the value belonging to a header.\n\n@param headers the evkeyvalq object in which to find the header\n@param key the name of the header to find\n@returns a pointer to the value for the header or NULL if the header\ncould not be found.\n@see evhttp_add_header(), evhttp_remove_header()"]
    pub fn evhttp_find_header(
        headers: *const evkeyvalq,
        key: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "Removes a header from a list of existing headers.\n\n@param headers the evkeyvalq object from which to remove a header\n@param key the name of the header to remove\n@returns 0 if the header was removed, -1  otherwise.\n@see evhttp_find_header(), evhttp_add_header()"]
    pub fn evhttp_remove_header(
        headers: *mut evkeyvalq,
        key: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Adds a header to a list of existing headers.\n\n@param headers the evkeyvalq object to which to add a header\n@param key the name of the header\n@param value the value belonging to the header\n@returns 0 on success, -1  otherwise.\n@see evhttp_find_header(), evhttp_clear_headers()"]
    pub fn evhttp_add_header(
        headers: *mut evkeyvalq,
        key: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Removes all headers from the header list.\n\n@param headers the evkeyvalq object from which to remove all headers"]
    pub fn evhttp_clear_headers(headers: *mut evkeyvalq);
}
extern "C" {
    #[doc = "Helper function to encode a string for inclusion in a URI.  All\ncharacters are replaced by their hex-escaped (%22) equivalents,\nexcept for characters explicitly unreserved by RFC3986 -- that is,\nASCII alphanumeric characters, hyphen, dot, underscore, and tilde.\n\nThe returned string must be freed by the caller.\n\n@param str an unencoded string\n@return a newly allocated URI-encoded string or NULL on failure"]
    pub fn evhttp_encode_uri(str_: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "As evhttp_encode_uri, but if 'size' is nonnegative, treat the string\nas being 'size' bytes long.  This allows you to encode strings that\nmay contain 0-valued bytes.\n\nThe returned string must be freed by the caller.\n\n@param str an unencoded string\n@param size the length of the string to encode, or -1 if the string\nis NUL-terminated\n@param space_to_plus if true, space characters in 'str' are encoded\nas +, not %20.\n@return a newly allocate URI-encoded string, or NULL on failure."]
    pub fn evhttp_uriencode(
        str_: *const ::std::os::raw::c_char,
        size: isize,
        space_to_plus: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "Helper function to sort of decode a URI-encoded string.  Unlike\nevhttp_uridecode, it decodes all plus characters that appear\n_after_ the first question mark character, but no plusses that occur\nbefore.  This is not a good way to decode URIs in whole or in part.\n\nThe returned string must be freed by the caller\n\n@deprecated  This function is deprecated; you probably want to use\nevhttp_uridecode instead.\n\n@param uri an encoded URI\n@return a newly allocated unencoded URI or NULL on failure"]
    pub fn evhttp_decode_uri(uri: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "Helper function to decode a URI-escaped string or HTTP parameter.\n\nIf 'decode_plus' is 1, then we decode the string as an HTTP parameter\nvalue, and convert all plus ('+') characters to spaces.  If\n'decode_plus' is 0, we leave all plus characters unchanged.\n\nThe returned string must be freed by the caller.\n\n@param uri a URI-encode encoded URI\n@param decode_plus determines whether we convert '+' to space.\n@param size_out if size_out is not NULL, *size_out is set to the size of the\nreturned string\n@return a newly allocated unencoded URI or NULL on failure"]
    pub fn evhttp_uridecode(
        uri: *const ::std::os::raw::c_char,
        decode_plus: ::std::os::raw::c_int,
        size_out: *mut usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "Helper function to parse out arguments in a query.\n\nParsing a URI like\n\nhttp://foo.com/?q=test&s=some+thing\n\nwill result in two entries in the key value queue.\n\nThe first entry is: key=\"q\", value=\"test\"\nThe second entry is: key=\"s\", value=\"some thing\"\n\n@deprecated This function is deprecated as of Libevent 2.0.9.  Use\nevhttp_uri_parse and evhttp_parse_query_str instead.\n\n@param uri the request URI\n@param headers the head of the evkeyval queue\n@return 0 on success, -1 on failure"]
    pub fn evhttp_parse_query(
        uri: *const ::std::os::raw::c_char,
        headers: *mut evkeyvalq,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Helper function to parse out arguments from the query portion of an\nHTTP URI.\n\nParsing a query string like\n\nq=test&s=some+thing\n\nwill result in two entries in the key value queue.\n\nThe first entry is: key=\"q\", value=\"test\"\nThe second entry is: key=\"s\", value=\"some thing\"\n\n@param query_parse the query portion of the URI\n@param headers the head of the evkeyval queue\n@return 0 on success, -1 on failure"]
    pub fn evhttp_parse_query_str(
        uri: *const ::std::os::raw::c_char,
        headers: *mut evkeyvalq,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Escape HTML character entities in a string.\n\n Replaces <, >, \", ' and & with &lt;, &gt;, &quot;,\n &#039; and &amp; correspondingly.\n\n The returned string needs to be freed by the caller.\n\n @param html an unescaped HTML string\n @return an escaped HTML string or NULL on error"]
    pub fn evhttp_htmlescape(html: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Return a new empty evhttp_uri with no fields set."]
    pub fn evhttp_uri_new() -> *mut evhttp_uri;
}
extern "C" {
    #[doc = " Changes the flags set on a given URI.  See EVHTTP_URI_* for\n a list of flags."]
    pub fn evhttp_uri_set_flags(uri: *mut evhttp_uri, flags: ::std::os::raw::c_uint);
}
extern "C" {
    #[doc = " Return the scheme of an evhttp_uri, or NULL if there is no scheme has\n been set and the evhttp_uri contains a Relative-Ref."]
    pub fn evhttp_uri_get_scheme(uri: *const evhttp_uri) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Return the userinfo part of an evhttp_uri, or NULL if it has no userinfo\n set."]
    pub fn evhttp_uri_get_userinfo(uri: *const evhttp_uri) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Return the host part of an evhttp_uri, or NULL if it has no host set.\n The host may either be a regular hostname (conforming to the RFC 3986\n \"regname\" production), or an IPv4 address, or the empty string, or a\n bracketed IPv6 address, or a bracketed 'IP-Future' address.\n\n Note that having a NULL host means that the URI has no authority\n section, but having an empty-string host means that the URI has an\n authority section with no host part.  For example,\n \"mailto:user@example.com\" has a host of NULL, but \"file:///etc/motd\"\n has a host of \"\"."]
    pub fn evhttp_uri_get_host(uri: *const evhttp_uri) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Return the port part of an evhttp_uri, or -1 if there is no port set."]
    pub fn evhttp_uri_get_port(uri: *const evhttp_uri) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return the path part of an evhttp_uri, or NULL if it has no path set"]
    pub fn evhttp_uri_get_path(uri: *const evhttp_uri) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Return the query part of an evhttp_uri (excluding the leading \"?\"), or\n NULL if it has no query set"]
    pub fn evhttp_uri_get_query(uri: *const evhttp_uri) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Return the fragment part of an evhttp_uri (excluding the leading \"#\"),\n or NULL if it has no fragment set"]
    pub fn evhttp_uri_get_fragment(uri: *const evhttp_uri) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Set the scheme of an evhttp_uri, or clear the scheme if scheme==NULL.\n Returns 0 on success, -1 if scheme is not well-formed."]
    pub fn evhttp_uri_set_scheme(
        uri: *mut evhttp_uri,
        scheme: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set the userinfo of an evhttp_uri, or clear the userinfo if userinfo==NULL.\n Returns 0 on success, -1 if userinfo is not well-formed."]
    pub fn evhttp_uri_set_userinfo(
        uri: *mut evhttp_uri,
        userinfo: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set the host of an evhttp_uri, or clear the host if host==NULL.\n Returns 0 on success, -1 if host is not well-formed."]
    pub fn evhttp_uri_set_host(
        uri: *mut evhttp_uri,
        host: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set the port of an evhttp_uri, or clear the port if port==-1.\n Returns 0 on success, -1 if port is not well-formed."]
    pub fn evhttp_uri_set_port(
        uri: *mut evhttp_uri,
        port: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set the path of an evhttp_uri, or clear the path if path==NULL.\n Returns 0 on success, -1 if path is not well-formed."]
    pub fn evhttp_uri_set_path(
        uri: *mut evhttp_uri,
        path: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set the query of an evhttp_uri, or clear the query if query==NULL.\n The query should not include a leading \"?\".\n Returns 0 on success, -1 if query is not well-formed."]
    pub fn evhttp_uri_set_query(
        uri: *mut evhttp_uri,
        query: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set the fragment of an evhttp_uri, or clear the fragment if fragment==NULL.\n The fragment should not include a leading \"#\".\n Returns 0 on success, -1 if fragment is not well-formed."]
    pub fn evhttp_uri_set_fragment(
        uri: *mut evhttp_uri,
        fragment: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Helper function to parse a URI-Reference as specified by RFC3986.\n\n This function matches the URI-Reference production from RFC3986,\n which includes both URIs like\n\n    scheme://[[userinfo]@]foo.com[:port]]/[path][?query][#fragment]\n\n  and relative-refs like\n\n    [path][?query][#fragment]\n\n Any optional elements portions not present in the original URI are\n left set to NULL in the resulting evhttp_uri.  If no port is\n specified, the port is set to -1.\n\n Note that no decoding is performed on percent-escaped characters in\n the string; if you want to parse them, use evhttp_uridecode or\n evhttp_parse_query_str as appropriate.\n\n Note also that most URI schemes will have additional constraints that\n this function does not know about, and cannot check.  For example,\n mailto://www.example.com/cgi-bin/fortune.pl is not a reasonable\n mailto url, http://www.example.com:99999/ is not a reasonable HTTP\n URL, and ftp:username@example.com is not a reasonable FTP URL.\n Nevertheless, all of these URLs conform to RFC3986, and this function\n accepts all of them as valid.\n\n @param source_uri the request URI\n @param flags Zero or more EVHTTP_URI_* flags to affect the behavior\n              of the parser.\n @return uri container to hold parsed data, or NULL if there is error\n @see evhttp_uri_free()"]
    pub fn evhttp_uri_parse_with_flags(
        source_uri: *const ::std::os::raw::c_char,
        flags: ::std::os::raw::c_uint,
    ) -> *mut evhttp_uri;
}
extern "C" {
    #[doc = " Alias for evhttp_uri_parse_with_flags(source_uri, 0)"]
    pub fn evhttp_uri_parse(source_uri: *const ::std::os::raw::c_char) -> *mut evhttp_uri;
}
extern "C" {
    #[doc = " Free all memory allocated for a parsed uri.  Only use this for URIs\n generated by evhttp_uri_parse.\n\n @param uri container with parsed data\n @see evhttp_uri_parse()"]
    pub fn evhttp_uri_free(uri: *mut evhttp_uri);
}
extern "C" {
    #[doc = " Join together the uri parts from parsed data to form a URI-Reference.\n\n Note that no escaping of reserved characters is done on the members\n of the evhttp_uri, so the generated string might not be a valid URI\n unless the members of evhttp_uri are themselves valid.\n\n @param uri container with parsed data\n @param buf destination buffer\n @param limit destination buffer size\n @return an joined uri as string or NULL on error\n @see evhttp_uri_parse()"]
    pub fn evhttp_uri_join(
        uri: *mut evhttp_uri,
        buf: *mut ::std::os::raw::c_char,
        limit: usize,
    ) -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct evrpc_req_generic {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct evrpc_request_wrapper {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct evrpc {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct evrpc_status {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct evrpc_hook_meta {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct evrpc_pool {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " use EVRPC_GENERATE instead"]
    pub fn evrpc_make_request_ctx(
        pool: *mut evrpc_pool,
        request: *mut ::std::os::raw::c_void,
        reply: *mut ::std::os::raw::c_void,
        rpcname: *const ::std::os::raw::c_char,
        req_marshal: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut evbuffer, arg2: *mut ::std::os::raw::c_void),
        >,
        rpl_clear: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
        rpl_unmarshal: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *mut evbuffer,
            ) -> ::std::os::raw::c_int,
        >,
        cb: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut evrpc_status,
                arg2: *mut ::std::os::raw::c_void,
                arg3: *mut ::std::os::raw::c_void,
                arg4: *mut ::std::os::raw::c_void,
            ),
        >,
        cbarg: *mut ::std::os::raw::c_void,
    ) -> *mut evrpc_request_wrapper;
}
extern "C" {
    #[doc = " completes the server response to an rpc request"]
    pub fn evrpc_request_done(req: *mut evrpc_req_generic);
}
extern "C" {
    #[doc = " accessors for request and reply"]
    pub fn evrpc_get_request(req: *mut evrpc_req_generic) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn evrpc_get_reply(req: *mut evrpc_req_generic) -> *mut ::std::os::raw::c_void;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct evrpc_base {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Creates a new rpc base from which RPC requests can be received\n\n @param server a pointer to an existing HTTP server\n @return a newly allocated evrpc_base struct or NULL if an error occurred\n @see evrpc_free()"]
    pub fn evrpc_init(server: *mut evhttp) -> *mut evrpc_base;
}
extern "C" {
    #[doc = " Frees the evrpc base\n\n For now, you are responsible for making sure that no rpcs are ongoing.\n\n @param base the evrpc_base object to be freed\n @see evrpc_init"]
    pub fn evrpc_free(base: *mut evrpc_base);
}
extern "C" {
    #[doc = "Low level function for registering an RPC with a server.\n\nUse EVRPC_REGISTER() instead.\n\n@see EVRPC_REGISTER()"]
    pub fn evrpc_register_rpc(
        arg1: *mut evrpc_base,
        arg2: *mut evrpc,
        arg3: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut evrpc_req_generic, arg2: *mut ::std::os::raw::c_void),
        >,
        arg4: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn evrpc_unregister_rpc(
        base: *mut evrpc_base,
        name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Makes an RPC request based on the provided context.\n\nThis is a low-level function and should not be used directly\nunless a custom context object is provided.  Use EVRPC_MAKE_REQUEST()\ninstead.\n\n@param ctx a context from EVRPC_MAKE_CTX()\n@returns 0 on success, -1 otherwise.\n@see EVRPC_MAKE_REQUEST(), EVRPC_MAKE_CTX()"]
    pub fn evrpc_make_request(ctx: *mut evrpc_request_wrapper) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " creates an rpc connection pool\n\n a pool has a number of connections associated with it.\n rpc requests are always made via a pool.\n\n @param base a pointer to an struct event_based object; can be left NULL\n   in singled-threaded applications\n @return a newly allocated struct evrpc_pool object or NULL if an error\n   occurred\n @see evrpc_pool_free()"]
    pub fn evrpc_pool_new(base: *mut event_base) -> *mut evrpc_pool;
}
extern "C" {
    #[doc = " frees an rpc connection pool\n\n @param pool a pointer to an evrpc_pool allocated via evrpc_pool_new()\n @see evrpc_pool_new()"]
    pub fn evrpc_pool_free(pool: *mut evrpc_pool);
}
extern "C" {
    #[doc = " Adds a connection over which rpc can be dispatched to the pool.\n\n The connection object must have been newly created.\n\n @param pool the pool to which to add the connection\n @param evcon the connection to add to the pool."]
    pub fn evrpc_pool_add_connection(pool: *mut evrpc_pool, evcon: *mut evhttp_connection);
}
extern "C" {
    #[doc = " Removes a connection from the pool.\n\n The connection object must have been newly created.\n\n @param pool the pool from which to remove the connection\n @param evcon the connection to remove from the pool."]
    pub fn evrpc_pool_remove_connection(pool: *mut evrpc_pool, evcon: *mut evhttp_connection);
}
extern "C" {
    #[doc = " Sets the timeout in secs after which a request has to complete.  The\n RPC is completely aborted if it does not complete by then.  Setting\n the timeout to 0 means that it never timeouts and can be used to\n implement callback type RPCs.\n\n Any connection already in the pool will be updated with the new\n timeout.  Connections added to the pool after set_timeout has be\n called receive the pool timeout only if no timeout has been set\n for the connection itself.\n\n @param pool a pointer to a struct evrpc_pool object\n @param timeout_in_secs the number of seconds after which a request should\n   timeout and a failure be returned to the callback."]
    pub fn evrpc_pool_set_timeout(pool: *mut evrpc_pool, timeout_in_secs: ::std::os::raw::c_int);
}
#[doc = "< apply the function to an input hook"]
pub const EVRPC_HOOK_TYPE_EVRPC_INPUT: EVRPC_HOOK_TYPE = 0;
#[doc = "< apply the function to an output hook"]
pub const EVRPC_HOOK_TYPE_EVRPC_OUTPUT: EVRPC_HOOK_TYPE = 1;
#[doc = " Hooks for changing the input and output of RPCs; this can be used to\n implement compression, authentication, encryption, ..."]
pub type EVRPC_HOOK_TYPE = ::std::os::raw::c_uint;
#[doc = "< indicates the rpc should be terminated"]
pub const EVRPC_HOOK_RESULT_EVRPC_TERMINATE: EVRPC_HOOK_RESULT = -1;
#[doc = "< continue processing the rpc"]
pub const EVRPC_HOOK_RESULT_EVRPC_CONTINUE: EVRPC_HOOK_RESULT = 0;
#[doc = "< pause processing request until resumed"]
pub const EVRPC_HOOK_RESULT_EVRPC_PAUSE: EVRPC_HOOK_RESULT = 1;
#[doc = " Return value from hook processing functions"]
pub type EVRPC_HOOK_RESULT = ::std::os::raw::c_int;
extern "C" {
    #[doc = " adds a processing hook to either an rpc base or rpc pool\n\n If a hook returns TERMINATE, the processing is aborted. On CONTINUE,\n the request is immediately processed after the hook returns.  If the\n hook returns PAUSE, request processing stops until evrpc_resume_request()\n has been called.\n\n The add functions return handles that can be used for removing hooks.\n\n @param vbase a pointer to either struct evrpc_base or struct evrpc_pool\n @param hook_type either INPUT or OUTPUT\n @param cb the callback to call when the hook is activated\n @param cb_arg an additional argument for the callback\n @return a handle to the hook so it can be removed later\n @see evrpc_remove_hook()"]
    pub fn evrpc_add_hook(
        vbase: *mut ::std::os::raw::c_void,
        hook_type: EVRPC_HOOK_TYPE,
        cb: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *mut evhttp_request,
                arg3: *mut evbuffer,
                arg4: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
        cb_arg: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " removes a previously added hook\n\n @param vbase a pointer to either struct evrpc_base or struct evrpc_pool\n @param hook_type either INPUT or OUTPUT\n @param handle a handle returned by evrpc_add_hook()\n @return 1 on success or 0 on failure\n @see evrpc_add_hook()"]
    pub fn evrpc_remove_hook(
        vbase: *mut ::std::os::raw::c_void,
        hook_type: EVRPC_HOOK_TYPE,
        handle: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " resume a paused request\n\n @param vbase a pointer to either struct evrpc_base or struct evrpc_pool\n @param ctx the context pointer provided to the original hook call"]
    pub fn evrpc_resume_request(
        vbase: *mut ::std::os::raw::c_void,
        ctx: *mut ::std::os::raw::c_void,
        res: EVRPC_HOOK_RESULT,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " adds meta data to request\n\n evrpc_hook_add_meta() allows hooks to add meta data to a request. for\n a client request, the meta data can be inserted by an outgoing request hook\n and retrieved by the incoming request hook.\n\n @param ctx the context provided to the hook call\n @param key a NUL-terminated c-string\n @param data the data to be associated with the key\n @param data_size the size of the data"]
    pub fn evrpc_hook_add_meta(
        ctx: *mut ::std::os::raw::c_void,
        key: *const ::std::os::raw::c_char,
        data: *const ::std::os::raw::c_void,
        data_size: usize,
    );
}
extern "C" {
    #[doc = " retrieves meta data previously associated\n\n evrpc_hook_find_meta() can be used to retrieve meta data associated to a\n request by a previous hook.\n @param ctx the context provided to the hook call\n @param key a NUL-terminated c-string\n @param data pointer to a data pointer that will contain the retrieved data\n @param data_size pointer to the size of the data\n @return 0 on success or -1 on failure"]
    pub fn evrpc_hook_find_meta(
        ctx: *mut ::std::os::raw::c_void,
        key: *const ::std::os::raw::c_char,
        data: *mut *mut ::std::os::raw::c_void,
        data_size: *mut usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " returns the connection object associated with the request\n\n @param ctx the context provided to the hook call\n @return a pointer to the evhttp_connection object or NULL if an error\n   occurred"]
    pub fn evrpc_hook_get_connection(ctx: *mut ::std::os::raw::c_void) -> *mut evhttp_connection;
}
extern "C" {
    #[doc = "Function for sending a generic RPC request.\n\nDo not call this function directly, use EVRPC_MAKE_REQUEST() instead.\n\n@see EVRPC_MAKE_REQUEST()"]
    pub fn evrpc_send_request_generic(
        pool: *mut evrpc_pool,
        request: *mut ::std::os::raw::c_void,
        reply: *mut ::std::os::raw::c_void,
        cb: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut evrpc_status,
                arg2: *mut ::std::os::raw::c_void,
                arg3: *mut ::std::os::raw::c_void,
                arg4: *mut ::std::os::raw::c_void,
            ),
        >,
        cb_arg: *mut ::std::os::raw::c_void,
        rpcname: *const ::std::os::raw::c_char,
        req_marshal: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut evbuffer, arg2: *mut ::std::os::raw::c_void),
        >,
        rpl_clear: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
        rpl_unmarshal: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *mut evbuffer,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Function for registering a generic RPC with the RPC base.\n\nDo not call this function directly, use EVRPC_REGISTER() instead.\n\n@see EVRPC_REGISTER()"]
    pub fn evrpc_register_generic(
        base: *mut evrpc_base,
        name: *const ::std::os::raw::c_char,
        callback: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut evrpc_req_generic, arg2: *mut ::std::os::raw::c_void),
        >,
        cbarg: *mut ::std::os::raw::c_void,
        req_new: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void,
        >,
        req_new_arg: *mut ::std::os::raw::c_void,
        req_free: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
        req_unmarshal: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *mut evbuffer,
            ) -> ::std::os::raw::c_int,
        >,
        rpl_new: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void,
        >,
        rpl_new_arg: *mut ::std::os::raw::c_void,
        rpl_free: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
        rpl_complete: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
        >,
        rpl_marshal: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut evbuffer, arg2: *mut ::std::os::raw::c_void),
        >,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " accessors for obscure and undocumented functionality"]
    pub fn evrpc_request_get_pool(ctx: *mut evrpc_request_wrapper) -> *mut evrpc_pool;
}
extern "C" {
    pub fn evrpc_request_set_pool(ctx: *mut evrpc_request_wrapper, pool: *mut evrpc_pool);
}
extern "C" {
    pub fn evrpc_request_set_cb(
        ctx: *mut evrpc_request_wrapper,
        cb: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut evrpc_status,
                request: *mut ::std::os::raw::c_void,
                reply: *mut ::std::os::raw::c_void,
                arg: *mut ::std::os::raw::c_void,
            ),
        >,
        cb_arg: *mut ::std::os::raw::c_void,
    );
}
#[doc = " This structure describes the interface a threading library uses for\n locking.   It's used to tell evthread_set_lock_callbacks() how to use\n locking on this platform."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct evthread_lock_callbacks {
    #[doc = " The current version of the locking API.  Set this to\n EVTHREAD_LOCK_API_VERSION"]
    pub lock_api_version: ::std::os::raw::c_int,
    #[doc = " Which kinds of locks does this version of the locking API\n support?  A bitfield of EVTHREAD_LOCKTYPE_RECURSIVE and\n EVTHREAD_LOCKTYPE_READWRITE.\n\n (Note that RECURSIVE locks are currently mandatory, and\n READWRITE locks are not currently used.)"]
    pub supported_locktypes: ::std::os::raw::c_uint,
    #[doc = " Function to allocate and initialize new lock of type 'locktype'.\n Returns NULL on failure."]
    pub alloc: ::std::option::Option<
        unsafe extern "C" fn(locktype: ::std::os::raw::c_uint) -> *mut ::std::os::raw::c_void,
    >,
    #[doc = " Funtion to release all storage held in 'lock', which was created\n with type 'locktype'."]
    pub free: ::std::option::Option<
        unsafe extern "C" fn(lock: *mut ::std::os::raw::c_void, locktype: ::std::os::raw::c_uint),
    >,
    #[doc = " Acquire an already-allocated lock at 'lock' with mode 'mode'.\n Returns 0 on success, and nonzero on failure."]
    pub lock: ::std::option::Option<
        unsafe extern "C" fn(
            mode: ::std::os::raw::c_uint,
            lock: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Release a lock at 'lock' using mode 'mode'.  Returns 0 on success,\n and nonzero on failure."]
    pub unlock: ::std::option::Option<
        unsafe extern "C" fn(
            mode: ::std::os::raw::c_uint,
            lock: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
}
#[test]
fn bindgen_test_layout_evthread_lock_callbacks() {
    const UNINIT: ::std::mem::MaybeUninit<evthread_lock_callbacks> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<evthread_lock_callbacks>(),
        40usize,
        concat!("Size of: ", stringify!(evthread_lock_callbacks))
    );
    assert_eq!(
        ::std::mem::align_of::<evthread_lock_callbacks>(),
        8usize,
        concat!("Alignment of ", stringify!(evthread_lock_callbacks))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lock_api_version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(evthread_lock_callbacks),
            "::",
            stringify!(lock_api_version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).supported_locktypes) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(evthread_lock_callbacks),
            "::",
            stringify!(supported_locktypes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).alloc) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(evthread_lock_callbacks),
            "::",
            stringify!(alloc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).free) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(evthread_lock_callbacks),
            "::",
            stringify!(free)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lock) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(evthread_lock_callbacks),
            "::",
            stringify!(lock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unlock) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(evthread_lock_callbacks),
            "::",
            stringify!(unlock)
        )
    );
}
extern "C" {
    #[doc = " Sets a group of functions that Libevent should use for locking.\n For full information on the required callback API, see the\n documentation for the individual members of evthread_lock_callbacks.\n\n Note that if you're using Windows or the Pthreads threading library, you\n probably shouldn't call this function; instead, use\n evthread_use_windows_threads() or evthread_use_posix_threads() if you can."]
    pub fn evthread_set_lock_callbacks(
        arg1: *const evthread_lock_callbacks,
    ) -> ::std::os::raw::c_int;
}
#[doc = " This structure describes the interface a threading library uses for\n condition variables.  It's used to tell evthread_set_condition_callbacks\n how to use locking on this platform."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct evthread_condition_callbacks {
    #[doc = " The current version of the conditions API.  Set this to\n EVTHREAD_CONDITION_API_VERSION"]
    pub condition_api_version: ::std::os::raw::c_int,
    #[doc = " Function to allocate and initialize a new condition variable.\n Returns the condition variable on success, and NULL on failure.\n The 'condtype' argument will be 0 with this API version."]
    pub alloc_condition: ::std::option::Option<
        unsafe extern "C" fn(condtype: ::std::os::raw::c_uint) -> *mut ::std::os::raw::c_void,
    >,
    #[doc = " Function to free a condition variable."]
    pub free_condition:
        ::std::option::Option<unsafe extern "C" fn(cond: *mut ::std::os::raw::c_void)>,
    #[doc = " Function to signal a condition variable.  If 'broadcast' is 1, all\n threads waiting on 'cond' should be woken; otherwise, only on one\n thread is worken.  Should return 0 on success, -1 on failure.\n This function will only be called while holding the associated\n lock for the condition."]
    pub signal_condition: ::std::option::Option<
        unsafe extern "C" fn(
            cond: *mut ::std::os::raw::c_void,
            broadcast: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Function to wait for a condition variable.  The lock 'lock'\n will be held when this function is called; should be released\n while waiting for the condition to be come signalled, and\n should be held again when this function returns.\n If timeout is provided, it is interval of seconds to wait for\n the event to become signalled; if it is NULL, the function\n should wait indefinitely.\n\n The function should return -1 on error; 0 if the condition\n was signalled, or 1 on a timeout."]
    pub wait_condition: ::std::option::Option<
        unsafe extern "C" fn(
            cond: *mut ::std::os::raw::c_void,
            lock: *mut ::std::os::raw::c_void,
            timeout: *const timeval,
        ) -> ::std::os::raw::c_int,
    >,
}
#[test]
fn bindgen_test_layout_evthread_condition_callbacks() {
    const UNINIT: ::std::mem::MaybeUninit<evthread_condition_callbacks> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<evthread_condition_callbacks>(),
        40usize,
        concat!("Size of: ", stringify!(evthread_condition_callbacks))
    );
    assert_eq!(
        ::std::mem::align_of::<evthread_condition_callbacks>(),
        8usize,
        concat!("Alignment of ", stringify!(evthread_condition_callbacks))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).condition_api_version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(evthread_condition_callbacks),
            "::",
            stringify!(condition_api_version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).alloc_condition) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(evthread_condition_callbacks),
            "::",
            stringify!(alloc_condition)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).free_condition) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(evthread_condition_callbacks),
            "::",
            stringify!(free_condition)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).signal_condition) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(evthread_condition_callbacks),
            "::",
            stringify!(signal_condition)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).wait_condition) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(evthread_condition_callbacks),
            "::",
            stringify!(wait_condition)
        )
    );
}
extern "C" {
    #[doc = " Sets a group of functions that Libevent should use for condition variables.\n For full information on the required callback API, see the\n documentation for the individual members of evthread_condition_callbacks.\n\n Note that if you're using Windows or the Pthreads threading library, you\n probably shouldn't call this function; instead, use\n evthread_use_windows_threads() or evthread_use_pthreads() if you can."]
    pub fn evthread_set_condition_callbacks(
        arg1: *const evthread_condition_callbacks,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Sets the function for determining the thread id.\n\n@param base the event base for which to set the id function\n@param id_fn the identify function Libevent should invoke to\ndetermine the identity of a thread."]
    pub fn evthread_set_id_callback(
        id_fn: ::std::option::Option<unsafe extern "C" fn() -> ::std::os::raw::c_ulong>,
    );
}
extern "C" {
    #[doc = " Sets up Libevent for use with Pthreads locking and thread ID functions.\nUnavailable if Libevent is not build for use with pthreads.  Requires\nlibraries to link against Libevent_pthreads as well as Libevent.\n\n@return 0 on success, -1 on failure."]
    pub fn evthread_use_pthreads() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Enable debugging wrappers around the current lock callbacks.  If Libevent\n makes one of several common locking errors, exit with an assertion failure.\n\n If you're going to call this function, you must do so before any locks are\n allocated."]
    pub fn evthread_enable_lock_debugging();
}
extern "C" {
    pub fn evthread_enable_lock_debuging();
}
extern "C" {
    #[doc = " Make sure it's safe to tell an event base to wake up from another thread\nor a signal handler.\n\nYou shouldn't need to call this by hand; configuring the base with thread\nsupport should be necessary and sufficient.\n\n@return 0 on success, -1 on failure."]
    pub fn evthread_make_base_notifiable(base: *mut event_base) -> ::std::os::raw::c_int;
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    const UNINIT: ::std::mem::MaybeUninit<__va_list_tag> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__va_list_tag>(),
        24usize,
        concat!("Size of: ", stringify!(__va_list_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<__va_list_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__va_list_tag))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gp_offset) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(gp_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fp_offset) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(fp_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).overflow_arg_area) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(overflow_arg_area)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reg_save_area) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(reg_save_area)
        )
    );
}
#[doc = " Pointer to a table of function pointers to set up how this\nbufferevent behaves."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bufferevent_ops {
    pub _address: u8,
}
